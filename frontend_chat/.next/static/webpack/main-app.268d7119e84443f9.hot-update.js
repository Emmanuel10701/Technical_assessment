"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main-app",{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/app-find-source-map-url.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findSourceMapURL\", ({\n    enumerable: true,\n    get: function() {\n        return findSourceMapURL;\n    }\n}));\nconst basePath =  false || '';\nconst pathname = \"\" + basePath + \"/__nextjs_source-map\";\nconst findSourceMapURL =  true ? function findSourceMapURL(filename) {\n    if (filename === '') {\n        return null;\n    }\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\n        // This is a request for a client chunk. This can only happen when\n        // using Turbopack. In this case, since we control how those source\n        // maps are generated, we can safely assume that the sourceMappingURL\n        // is relative to the filename, with an added `.map` extension. The\n        // browser can just request this file, and it gets served through the\n        // normal dev server, without the need to route this through\n        // the `/__nextjs_source-map` dev middleware.\n        return \"\" + filename + \".map\";\n    }\n    const url = new URL(pathname, document.location.origin);\n    url.searchParams.set('filename', filename);\n    return url.href;\n} : 0;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-find-source-map-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1maW5kLXNvdXJjZS1tYXAtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7b0RBR2FBOzs7ZUFBQUE7OztBQUhiLE1BQU1DLFdBQVdDLE1BQWtDLElBQUk7QUFDdkQsTUFBTUcsV0FBWSxLQUFFSixXQUFTO0FBRXRCLE1BQU1ELG1CQUNYRSxLQUFvQixHQUNoQixTQUFTRixpQkFBaUJPLFFBQWdCO0lBQ3hDLElBQUlBLGFBQWEsSUFBSTtRQUNuQixPQUFPO0lBQ1Q7SUFFQSxJQUNFQSxTQUFTQyxVQUFVLENBQUNDLFNBQVNDLFFBQVEsQ0FBQ0MsTUFBTSxLQUM1Q0osU0FBU0ssUUFBUSxDQUFDLGtCQUNsQjtRQUNBLGtFQUFrRTtRQUNsRSxtRUFBbUU7UUFDbkUscUVBQXFFO1FBQ3JFLG1FQUFtRTtRQUNuRSxxRUFBcUU7UUFDckUsNERBQTREO1FBQzVELDZDQUE2QztRQUM3QyxPQUFRLEtBQUVMLFdBQVM7SUFDckI7SUFFQSxNQUFNTSxNQUFNLElBQUlDLElBQUlULFVBQVVJLFNBQVNDLFFBQVEsQ0FBQ0MsTUFBTTtJQUN0REUsSUFBSUUsWUFBWSxDQUFDQyxHQUFHLENBQUMsWUFBWVQ7SUFFakMsT0FBT00sSUFBSUksSUFBSTtBQUNqQixJQUNBQyxDQUFTQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcT25lRHJpdmVcXERlc2t0b3BcXHNyY1xcY2xpZW50XFxhcHAtZmluZC1zb3VyY2UtbWFwLXVybC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJydcbmNvbnN0IHBhdGhuYW1lID0gYCR7YmFzZVBhdGh9L19fbmV4dGpzX3NvdXJjZS1tYXBgXG5cbmV4cG9ydCBjb25zdCBmaW5kU291cmNlTWFwVVJMID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcbiAgICA/IGZ1bmN0aW9uIGZpbmRTb3VyY2VNYXBVUkwoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBmaWxlbmFtZS5zdGFydHNXaXRoKGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbikgJiZcbiAgICAgICAgICBmaWxlbmFtZS5pbmNsdWRlcygnL19uZXh0L3N0YXRpYycpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSByZXF1ZXN0IGZvciBhIGNsaWVudCBjaHVuay4gVGhpcyBjYW4gb25seSBoYXBwZW4gd2hlblxuICAgICAgICAgIC8vIHVzaW5nIFR1cmJvcGFjay4gSW4gdGhpcyBjYXNlLCBzaW5jZSB3ZSBjb250cm9sIGhvdyB0aG9zZSBzb3VyY2VcbiAgICAgICAgICAvLyBtYXBzIGFyZSBnZW5lcmF0ZWQsIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXQgdGhlIHNvdXJjZU1hcHBpbmdVUkxcbiAgICAgICAgICAvLyBpcyByZWxhdGl2ZSB0byB0aGUgZmlsZW5hbWUsIHdpdGggYW4gYWRkZWQgYC5tYXBgIGV4dGVuc2lvbi4gVGhlXG4gICAgICAgICAgLy8gYnJvd3NlciBjYW4ganVzdCByZXF1ZXN0IHRoaXMgZmlsZSwgYW5kIGl0IGdldHMgc2VydmVkIHRocm91Z2ggdGhlXG4gICAgICAgICAgLy8gbm9ybWFsIGRldiBzZXJ2ZXIsIHdpdGhvdXQgdGhlIG5lZWQgdG8gcm91dGUgdGhpcyB0aHJvdWdoXG4gICAgICAgICAgLy8gdGhlIGAvX19uZXh0anNfc291cmNlLW1hcGAgZGV2IG1pZGRsZXdhcmUuXG4gICAgICAgICAgcmV0dXJuIGAke2ZpbGVuYW1lfS5tYXBgXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGhuYW1lLCBkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4pXG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdmaWxlbmFtZScsIGZpbGVuYW1lKVxuXG4gICAgICAgIHJldHVybiB1cmwuaHJlZlxuICAgICAgfVxuICAgIDogdW5kZWZpbmVkXG4iXSwibmFtZXMiOlsiZmluZFNvdXJjZU1hcFVSTCIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRobmFtZSIsIk5PREVfRU5WIiwiZmlsZW5hbWUiLCJzdGFydHNXaXRoIiwiZG9jdW1lbnQiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImluY2x1ZGVzIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiaHJlZiIsInVuZGVmaW5lZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-index.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/client/app-index.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// imports polyfill from `@next/polyfill-module` after build.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hydrate\", ({\n    enumerable: true,\n    get: function() {\n        return hydrate;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/polyfill-module.js\");\n__webpack_require__(/*! ./components/globals/patch-console */ \"(app-pages-browser)/./node_modules/next/dist/client/components/globals/patch-console.js\");\n__webpack_require__(/*! ./components/globals/handle-global-errors */ \"(app-pages-browser)/./node_modules/next/dist/client/components/globals/handle-global-errors.js\");\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/client.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _client1 = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _onrecoverableerror = __webpack_require__(/*! ./react-client-callbacks/on-recoverable-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\");\nconst _errorboundarycallbacks = __webpack_require__(/*! ./react-client-callbacks/error-boundary-callbacks */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\");\nconst _appcallserver = __webpack_require__(/*! ./app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ./app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _actionqueue = __webpack_require__(/*! ../shared/lib/router/action-queue */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/action-queue.js\");\nconst _approuter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./components/app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\"));\nconst _createinitialrouterstate = __webpack_require__(/*! ./components/router-reducer/create-initial-router-state */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _appbuildid = __webpack_require__(/*! ./app-build-id */ \"(app-pages-browser)/./node_modules/next/dist/client/app-build-id.js\");\nconst _iserrorthrownwhilerenderingrsc = __webpack_require__(/*! ./lib/is-error-thrown-while-rendering-rsc */ \"(app-pages-browser)/./node_modules/next/dist/client/lib/is-error-thrown-while-rendering-rsc.js\");\n/// <reference types=\"react-dom/experimental\" />\nconst appElement = document;\nconst encoder = new TextEncoder();\nlet initialServerDataBuffer = undefined;\nlet initialServerDataWriter = undefined;\nlet initialServerDataLoaded = false;\nlet initialServerDataFlushed = false;\nlet initialFormStateData = null;\nfunction nextServerDataCallback(seg) {\n    if (seg[0] === 0) {\n        initialServerDataBuffer = [];\n    } else if (seg[0] === 1) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(encoder.encode(seg[1]));\n        } else {\n            initialServerDataBuffer.push(seg[1]);\n        }\n    } else if (seg[0] === 2) {\n        initialFormStateData = seg[1];\n    } else if (seg[0] === 3) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        // Decode the base64 string back to binary data.\n        const binaryString = atob(seg[1]);\n        const decodedChunk = new Uint8Array(binaryString.length);\n        for(var i = 0; i < binaryString.length; i++){\n            decodedChunk[i] = binaryString.charCodeAt(i);\n        }\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(decodedChunk);\n        } else {\n            initialServerDataBuffer.push(decodedChunk);\n        }\n    }\n}\nfunction isStreamErrorOrUnfinished(ctr) {\n    // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n    return ctr.desiredSize === null || ctr.desiredSize < 0;\n}\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr) {\n    if (initialServerDataBuffer) {\n        initialServerDataBuffer.forEach((val)=>{\n            ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val);\n        });\n        if (initialServerDataLoaded && !initialServerDataFlushed) {\n            if (isStreamErrorOrUnfinished(ctr)) {\n                ctr.error(Object.defineProperty(new Error('The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E117\",\n                    enumerable: false,\n                    configurable: true\n                }));\n            } else {\n                ctr.close();\n            }\n            initialServerDataFlushed = true;\n            initialServerDataBuffer = undefined;\n        }\n    }\n    initialServerDataWriter = ctr;\n}\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function() {\n    if (initialServerDataWriter && !initialServerDataFlushed) {\n        initialServerDataWriter.close();\n        initialServerDataFlushed = true;\n        initialServerDataBuffer = undefined;\n    }\n    initialServerDataLoaded = true;\n};\n_c = DOMContentLoaded;\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);\n} else {\n    // Delayed in marco task to ensure it's executed later than hydration\n    setTimeout(DOMContentLoaded);\n}\nconst nextServerDataLoadingGlobal = self.__next_f = self.__next_f || [];\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback);\nnextServerDataLoadingGlobal.push = nextServerDataCallback;\nconst readable = new ReadableStream({\n    start (controller) {\n        nextServerDataRegisterWriter(controller);\n    }\n});\nconst initialServerResponse = (0, _client1.createFromReadableStream)(readable, {\n    callServer: _appcallserver.callServer,\n    findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n});\n// React overrides `.then` and doesn't return a new promise chain,\n// so we wrap the action queue in a promise to ensure that its value\n// is defined when the promise resolves.\n// https://github.com/facebook/react/blob/163365a07872337e04826c4f501565d43dbd2fd4/packages/react-client/src/ReactFlightClient.js#L189-L190\nconst pendingActionQueue = new Promise((resolve, reject)=>{\n    initialServerResponse.then((initialRSCPayload)=>{\n        // setAppBuildId should be called only once, during JS initialization\n        // and before any components have hydrated.\n        (0, _appbuildid.setAppBuildId)(initialRSCPayload.b);\n        resolve((0, _actionqueue.createMutableActionQueue)((0, _createinitialrouterstate.createInitialRouterState)({\n            initialFlightData: initialRSCPayload.f,\n            initialCanonicalUrlParts: initialRSCPayload.c,\n            initialParallelRoutes: new Map(),\n            location: window.location,\n            couldBeIntercepted: initialRSCPayload.i,\n            postponed: initialRSCPayload.s,\n            prerendered: initialRSCPayload.S\n        })));\n    }, (err)=>reject(err));\n});\nfunction ServerRoot() {\n    const initialRSCPayload = (0, _react.use)(initialServerResponse);\n    const actionQueue = (0, _react.use)(pendingActionQueue);\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuter.default, {\n        actionQueue: actionQueue,\n        globalErrorComponentAndStyles: initialRSCPayload.G,\n        assetPrefix: initialRSCPayload.p\n    });\n    if ( true && initialRSCPayload.m) {\n        // We provide missing slot information in a context provider only during development\n        // as we log some additional information about the missing slots in the console.\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.MissingSlotContext, {\n            value: initialRSCPayload.m,\n            children: router\n        });\n    }\n    return router;\n}\n_c1 = ServerRoot;\nconst StrictModeIfEnabled =  true ? _react.default.StrictMode : 0;\nfunction Root(param) {\n    let { children } = param;\n    if (false) {}\n    return children;\n}\n_c2 = Root;\nconst reactRootOptions = {\n    onRecoverableError: _onrecoverableerror.onRecoverableError,\n    onCaughtError: _errorboundarycallbacks.onCaughtError,\n    onUncaughtError: _errorboundarycallbacks.onUncaughtError\n};\nfunction hydrate() {\n    var _window___next_root_layout_missing_tags;\n    const reactEl = /*#__PURE__*/ (0, _jsxruntime.jsx)(StrictModeIfEnabled, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n            value: {\n                appDir: true\n            },\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ServerRoot, {})\n            })\n        })\n    });\n    if (document.documentElement.id === '__next_error__' || !!((_window___next_root_layout_missing_tags = window.__next_root_layout_missing_tags) == null ? void 0 : _window___next_root_layout_missing_tags.length)) {\n        let element = reactEl;\n        // Server rendering failed, fall back to client-side rendering\n        if ( true && (0, _iserrorthrownwhilerenderingrsc.shouldRenderRootLevelErrorOverlay)()) {\n            const { createRootLevelDevOverlayElement } = __webpack_require__(/*! ./components/react-dev-overlay/app/client-entry */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/client-entry.js\");\n            // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n            element = createRootLevelDevOverlayElement(element);\n        }\n        _client.default.createRoot(appElement, reactRootOptions).render(element);\n    } else {\n        _react.default.startTransition(()=>{\n            _client.default.hydrateRoot(appElement, reactEl, {\n                ...reactRootOptions,\n                formState: initialFormStateData\n            });\n        });\n    }\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const { linkGc } = __webpack_require__(/*! ./app-link-gc */ \"(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js\");\n        linkGc();\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"DOMContentLoaded\");\n$RefreshReg$(_c1, \"ServerRoot\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2REFBNkQ7Ozs7OzJDQWdQN0NBOzs7ZUFBQUE7Ozs7OztvQkEvT1Q7b0JBRUE7b0JBQ0E7NkVBRW9COzZFQUNBO3FDQUVjOzZEQUNOO2dEQUNBO29EQUk1QjsyQ0FDb0I7aURBQ007eUNBSTFCO2dGQUNlO3NEQUVtQjsyREFDTjt3Q0FDTDs0REFDb0I7QUFFbEQsZ0RBQWdEO0FBRWhELE1BQU1DLGFBQXFDQztBQUUzQyxNQUFNQyxVQUFVLElBQUlDO0FBRXBCLElBQUlDLDBCQUErREM7QUFDbkUsSUFBSUMsMEJBQ0ZEO0FBQ0YsSUFBSUUsMEJBQTBCO0FBQzlCLElBQUlDLDJCQUEyQjtBQUUvQixJQUFJQyx1QkFBbUM7QUFtQnZDLFNBQVNDLHVCQUF1QkMsR0FBa0I7SUFDaEQsSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ2hCUCwwQkFBMEIsRUFBRTtJQUM5QixPQUFPLElBQUlPLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUN2QixJQUFJLENBQUNQLHlCQUNILE1BQU0scUJBQThELENBQTlELElBQUlRLE1BQU0sc0RBQVY7bUJBQUE7d0JBQUE7MEJBQUE7UUFBNkQ7UUFFckUsSUFBSU4seUJBQXlCO1lBQzNCQSx3QkFBd0JPLE9BQU8sQ0FBQ1gsUUFBUVksTUFBTSxDQUFDSCxHQUFHLENBQUMsRUFBRTtRQUN2RCxPQUFPO1lBQ0xQLHdCQUF3QlcsSUFBSSxDQUFDSixHQUFHLENBQUMsRUFBRTtRQUNyQztJQUNGLE9BQU8sSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ3ZCRix1QkFBdUJFLEdBQUcsQ0FBQyxFQUFFO0lBQy9CLE9BQU8sSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ3ZCLElBQUksQ0FBQ1AseUJBQ0gsTUFBTSxxQkFBOEQsQ0FBOUQsSUFBSVEsTUFB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QixpQ0FBQUEsa0JBQWtCLENBQUNDLFFBQVE7WUFBQ2xCLE9BQU87Z0JBQUVtQixRQUFRO1lBQUs7c0JBQ2pELG1DQUFDYixNQUFBQTswQkFDQyxtQ0FBQ3BCLFlBQUFBLENBQUFBOzs7O0lBTVQsSUFDRXJFLFNBQVN1RyxlQUFlLENBQUNDLEVBQUUsS0FBSyxvQkFDaEMsQ0FBQyxHQUFDMUMsMENBQUFBLE9BQU8yQywrQkFBQUEsS0FBK0IsZ0JBQXRDM0Msd0NBQXdDM0MsTUFBQUEsR0FDMUM7UUFDQSxJQUFJdUYsVUFBVVA7UUFDZCw4REFBOEQ7UUFDOUQsSUFoTVEsS0FpTWMsSUFDcEJRLENBQUFBLEdBQUFBLGdDQUFBQSxpQ0FBQUEsS0FDQTtZQUNBLE1BQU0sRUFBRUMsZ0NBQWdDLEVBQUUsR0FDeENDLG1CQUFPQSxDQUFDLDZKQUFpRDtZQUUzRCxrRkFBa0Y7WUFDbEZILFVBQVVFLGlDQUFpQ0Y7UUFDN0M7UUFFQUksUUFBQUEsT0FBYyxDQUFDQyxVQUFVLENBQUNoSCxZQUFZZ0csa0JBQWtCaUIsTUFBTSxDQUFDTjtJQUNqRSxPQUFPO1FBQ0xwQixPQUFBQSxPQUFLLENBQUMyQixlQUFlLENBQUM7WUFDcEJILFFBQUFBLE9BQWMsQ0FBQ0ksV0FBVyxDQUFDbkgsWUFBWW9HLFNBQVM7Z0JBQzlDLEdBQUdKLGdCQUFnQjtnQkFDbkJvQixXQUFXM0c7WUFDYjtRQUNGO0lBQ0Y7SUFFQSx5RUFBeUU7SUFDekUsSUF0TlUsSUFzTmMsRUFBbUI7UUFDekMsTUFBTSxFQUFFNEcsTUFBTSxFQUFFLEdBQ2RQLG1CQUFPQSxDQUFDLHlGQUFlO1FBQ3pCTztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXE9uZURyaXZlXFxEZXNrdG9wXFxzcmNcXGNsaWVudFxcYXBwLWluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRzIHBvbHlmaWxsIGZyb20gYEBuZXh0L3BvbHlmaWxsLW1vZHVsZWAgYWZ0ZXIgYnVpbGQuXG5pbXBvcnQgJy4uL2J1aWxkL3BvbHlmaWxscy9wb2x5ZmlsbC1tb2R1bGUnXG5cbmltcG9ydCAnLi9jb21wb25lbnRzL2dsb2JhbHMvcGF0Y2gtY29uc29sZSdcbmltcG9ydCAnLi9jb21wb25lbnRzL2dsb2JhbHMvaGFuZGxlLWdsb2JhbC1lcnJvcnMnXG5cbmltcG9ydCBSZWFjdERPTUNsaWVudCBmcm9tICdyZWFjdC1kb20vY2xpZW50J1xuaW1wb3J0IFJlYWN0LCB7IHVzZSB9IGZyb20gJ3JlYWN0J1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuaW1wb3J0IHsgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIH0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBvblJlY292ZXJhYmxlRXJyb3IgfSBmcm9tICcuL3JlYWN0LWNsaWVudC1jYWxsYmFja3Mvb24tcmVjb3ZlcmFibGUtZXJyb3InXG5pbXBvcnQge1xuICBvbkNhdWdodEVycm9yLFxuICBvblVuY2F1Z2h0RXJyb3IsXG59IGZyb20gJy4vcmVhY3QtY2xpZW50LWNhbGxiYWNrcy9lcnJvci1ib3VuZGFyeS1jYWxsYmFja3MnXG5pbXBvcnQgeyBjYWxsU2VydmVyIH0gZnJvbSAnLi9hcHAtY2FsbC1zZXJ2ZXInXG5pbXBvcnQgeyBmaW5kU291cmNlTWFwVVJMIH0gZnJvbSAnLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybCdcbmltcG9ydCB7XG4gIHR5cGUgQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIGNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZSxcbn0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvYWN0aW9uLXF1ZXVlJ1xuaW1wb3J0IEFwcFJvdXRlciBmcm9tICcuL2NvbXBvbmVudHMvYXBwLXJvdXRlcidcbmltcG9ydCB0eXBlIHsgSW5pdGlhbFJTQ1BheWxvYWQgfSBmcm9tICcuLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IGNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSB9IGZyb20gJy4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaW5pdGlhbC1yb3V0ZXItc3RhdGUnXG5pbXBvcnQgeyBNaXNzaW5nU2xvdENvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHNldEFwcEJ1aWxkSWQgfSBmcm9tICcuL2FwcC1idWlsZC1pZCdcbmltcG9ydCB7IHNob3VsZFJlbmRlclJvb3RMZXZlbEVycm9yT3ZlcmxheSB9IGZyb20gJy4vbGliL2lzLWVycm9yLXRocm93bi13aGlsZS1yZW5kZXJpbmctcnNjJ1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlYWN0LWRvbS9leHBlcmltZW50YWxcIiAvPlxuXG5jb25zdCBhcHBFbGVtZW50OiBIVE1MRWxlbWVudCB8IERvY3VtZW50ID0gZG9jdW1lbnRcblxuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbmxldCBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlcjogKHN0cmluZyB8IFVpbnQ4QXJyYXkpW10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbmxldCBpbml0aWFsU2VydmVyRGF0YVdyaXRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB8IHVuZGVmaW5lZCA9XG4gIHVuZGVmaW5lZFxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkID0gZmFsc2VcbmxldCBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQgPSBmYWxzZVxuXG5sZXQgaW5pdGlhbEZvcm1TdGF0ZURhdGE6IG51bGwgfCBhbnkgPSBudWxsXG5cbnR5cGUgRmxpZ2h0U2VnbWVudCA9XG4gIHwgW2lzQm9vdFN0cmFwOiAwXVxuICB8IFtpc05vdEJvb3RzdHJhcDogMSwgcmVzcG9uc2VQYXJ0aWFsOiBzdHJpbmddXG4gIHwgW2lzRm9ybVN0YXRlOiAyLCBmb3JtU3RhdGU6IGFueV1cbiAgfCBbaXNCaW5hcnk6IDMsIHJlc3BvbnNlQmFzZTY0UGFydGlhbDogc3RyaW5nXVxuXG50eXBlIE5leHRGbGlnaHQgPSBPbWl0PEFycmF5PEZsaWdodFNlZ21lbnQ+LCAncHVzaCc+ICYge1xuICBwdXNoOiAoc2VnOiBGbGlnaHRTZWdtZW50KSA9PiB2b2lkXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gSWYgeW91J3JlIHdvcmtpbmcgaW4gYSBicm93c2VyIGVudmlyb25tZW50XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fbmV4dF9mOiBOZXh0RmxpZ2h0XG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dFNlcnZlckRhdGFDYWxsYmFjayhzZWc6IEZsaWdodFNlZ21lbnQpOiB2b2lkIHtcbiAgaWYgKHNlZ1swXSA9PT0gMCkge1xuICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyID0gW11cbiAgfSBlbHNlIGlmIChzZWdbMF0gPT09IDEpIHtcbiAgICBpZiAoIWluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNlcnZlciBkYXRhOiBtaXNzaW5nIGJvb3RzdHJhcCBzY3JpcHQuJylcblxuICAgIGlmIChpbml0aWFsU2VydmVyRGF0YVdyaXRlcikge1xuICAgICAgaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShzZWdbMV0pKVxuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlci5wdXNoKHNlZ1sxXSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2VnWzBdID09PSAyKSB7XG4gICAgaW5pdGlhbEZvcm1TdGF0ZURhdGEgPSBzZWdbMV1cbiAgfSBlbHNlIGlmIChzZWdbMF0gPT09IDMpIHtcbiAgICBpZiAoIWluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNlcnZlciBkYXRhOiBtaXNzaW5nIGJvb3RzdHJhcCBzY3JpcHQuJylcblxuICAgIC8vIERlY29kZSB0aGUgYmFzZTY0IHN0cmluZyBiYWNrIHRvIGJpbmFyeSBkYXRhLlxuICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2Ioc2VnWzFdKVxuICAgIGNvbnN0IGRlY29kZWRDaHVuayA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlY29kZWRDaHVua1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpXG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyKSB7XG4gICAgICBpbml0aWFsU2VydmVyRGF0YVdyaXRlci5lbnF1ZXVlKGRlY29kZWRDaHVuaylcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIucHVzaChkZWNvZGVkQ2h1bmspXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RyZWFtRXJyb3JPclVuZmluaXNoZWQoY3RyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKSB7XG4gIC8vIElmIGBkZXNpcmVkU2l6ZWAgaXMgbnVsbCwgaXQgbWVhbnMgdGhlIHN0cmVhbSBpcyBjbG9zZWQgb3IgZXJyb3JlZC4gSWYgaXQgaXMgbG93ZXIgdGhhbiAwLCB0aGUgc3RyZWFtIGlzIHN0aWxsIHVuZmluaXNoZWQuXG4gIHJldHVybiBjdHIuZGVzaXJlZFNpemUgPT09IG51bGwgfHwgY3RyLmRlc2lyZWRTaXplIDwgMFxufVxuXG4vLyBUaGVyZSBtaWdodCBiZSByYWNlIGNvbmRpdGlvbnMgYmV0d2VlbiBgbmV4dFNlcnZlckRhdGFSZWdpc3RlcldyaXRlcmAgYW5kXG4vLyBgRE9NQ29udGVudExvYWRlZGAuIFRoZSBmb3JtZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiBSZWFjdCBzdGFydHMgdG8gaHlkcmF0ZVxuLy8gdGhlIHJvb3QsIHRoZSBsYXR0ZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgRE9NIGlzIGZ1bGx5IGxvYWRlZC5cbi8vIEZvciBzdHJlYW1pbmcsIHRoZSBmb3JtZXIgaXMgY2FsbGVkIGZpcnN0IGR1ZSB0byBwYXJ0aWFsIGh5ZHJhdGlvbi5cbi8vIEZvciBub24tc3RyZWFtaW5nLCB0aGUgbGF0dGVyIGNhbiBiZSBjYWxsZWQgZmlyc3QuXG4vLyBIZW5jZSwgd2UgdXNlIHR3byB2YXJpYWJsZXMgYGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkYCBhbmRcbi8vIGBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWRgIHRvIG1ha2Ugc3VyZSB0aGUgd3JpdGVyIHdpbGwgYmUgY2xvc2VkIGFuZFxuLy8gYGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyYCB3aWxsIGJlIGNsZWFyZWQgaW4gdGhlIHJpZ2h0IHRpbWUuXG5mdW5jdGlvbiBuZXh0U2VydmVyRGF0YVJlZ2lzdGVyV3JpdGVyKGN0cjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikge1xuICBpZiAoaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIpIHtcbiAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlci5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgIGN0ci5lbnF1ZXVlKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gZW5jb2Rlci5lbmNvZGUodmFsKSA6IHZhbClcbiAgICB9KVxuICAgIGlmIChpbml0aWFsU2VydmVyRGF0YUxvYWRlZCAmJiAhaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkKSB7XG4gICAgICBpZiAoaXNTdHJlYW1FcnJvck9yVW5maW5pc2hlZChjdHIpKSB7XG4gICAgICAgIGN0ci5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGNvbm5lY3Rpb24gdG8gdGhlIHBhZ2Ugd2FzIHVuZXhwZWN0ZWRseSBjbG9zZWQsIHBvc3NpYmx5IGR1ZSB0byB0aGUgc3RvcCBidXR0b24gYmVpbmcgY2xpY2tlZCwgbG9zcyBvZiBXaS1GaSwgb3IgYW4gdW5zdGFibGUgaW50ZXJuZXQgY29ubmVjdGlvbi4nXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHIuY2xvc2UoKVxuICAgICAgfVxuICAgICAgaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkID0gdHJ1ZVxuICAgICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBpbml0aWFsU2VydmVyRGF0YVdyaXRlciA9IGN0clxufVxuXG4vLyBXaGVuIGBET01Db250ZW50TG9hZGVkYCwgd2UgY2FuIGNsb3NlIGFsbCBwZW5kaW5nIHdyaXRlcnMgdG8gZmluaXNoIGh5ZHJhdGlvbi5cbmNvbnN0IERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChpbml0aWFsU2VydmVyRGF0YVdyaXRlciAmJiAhaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkKSB7XG4gICAgaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIuY2xvc2UoKVxuICAgIGluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCA9IHRydWVcbiAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlciA9IHVuZGVmaW5lZFxuICB9XG4gIGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkID0gdHJ1ZVxufVxuXG4vLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIERPTSBpcyBhbHJlYWR5IGxvYWRlZC5cbmlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIERPTUNvbnRlbnRMb2FkZWQsIGZhbHNlKVxufSBlbHNlIHtcbiAgLy8gRGVsYXllZCBpbiBtYXJjbyB0YXNrIHRvIGVuc3VyZSBpdCdzIGV4ZWN1dGVkIGxhdGVyIHRoYW4gaHlkcmF0aW9uXG4gIHNldFRpbWVvdXQoRE9NQ29udGVudExvYWRlZClcbn1cblxuY29uc3QgbmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsID0gKHNlbGYuX19uZXh0X2YgPSBzZWxmLl9fbmV4dF9mIHx8IFtdKVxubmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsLmZvckVhY2gobmV4dFNlcnZlckRhdGFDYWxsYmFjaylcbm5leHRTZXJ2ZXJEYXRhTG9hZGluZ0dsb2JhbC5wdXNoID0gbmV4dFNlcnZlckRhdGFDYWxsYmFja1xuXG5jb25zdCByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICBuZXh0U2VydmVyRGF0YVJlZ2lzdGVyV3JpdGVyKGNvbnRyb2xsZXIpXG4gIH0sXG59KVxuXG5jb25zdCBpbml0aWFsU2VydmVyUmVzcG9uc2UgPSBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW08SW5pdGlhbFJTQ1BheWxvYWQ+KFxuICByZWFkYWJsZSxcbiAgeyBjYWxsU2VydmVyLCBmaW5kU291cmNlTWFwVVJMIH1cbilcblxuLy8gUmVhY3Qgb3ZlcnJpZGVzIGAudGhlbmAgYW5kIGRvZXNuJ3QgcmV0dXJuIGEgbmV3IHByb21pc2UgY2hhaW4sXG4vLyBzbyB3ZSB3cmFwIHRoZSBhY3Rpb24gcXVldWUgaW4gYSBwcm9taXNlIHRvIGVuc3VyZSB0aGF0IGl0cyB2YWx1ZVxuLy8gaXMgZGVmaW5lZCB3aGVuIHRoZSBwcm9taXNlIHJlc29sdmVzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvMTYzMzY1YTA3ODcyMzM3ZTA0ODI2YzRmNTAxNTY1ZDQzZGJkMmZkNC9wYWNrYWdlcy9yZWFjdC1jbGllbnQvc3JjL1JlYWN0RmxpZ2h0Q2xpZW50LmpzI0wxODktTDE5MFxuY29uc3QgcGVuZGluZ0FjdGlvblF1ZXVlOiBQcm9taXNlPEFwcFJvdXRlckFjdGlvblF1ZXVlPiA9IG5ldyBQcm9taXNlKFxuICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaW5pdGlhbFNlcnZlclJlc3BvbnNlLnRoZW4oXG4gICAgICAoaW5pdGlhbFJTQ1BheWxvYWQpID0+IHtcbiAgICAgICAgLy8gc2V0QXBwQnVpbGRJZCBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSwgZHVyaW5nIEpTIGluaXRpYWxpemF0aW9uXG4gICAgICAgIC8vIGFuZCBiZWZvcmUgYW55IGNvbXBvbmVudHMgaGF2ZSBoeWRyYXRlZC5cbiAgICAgICAgc2V0QXBwQnVpbGRJZChpbml0aWFsUlNDUGF5bG9hZC5iKVxuXG4gICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlKFxuICAgICAgICAgICAgY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlKHtcbiAgICAgICAgICAgICAgaW5pdGlhbEZsaWdodERhdGE6IGluaXRpYWxSU0NQYXlsb2FkLmYsXG4gICAgICAgICAgICAgIGluaXRpYWxDYW5vbmljYWxVcmxQYXJ0czogaW5pdGlhbFJTQ1BheWxvYWQuYyxcbiAgICAgICAgICAgICAgaW5pdGlhbFBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgICAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogaW5pdGlhbFJTQ1BheWxvYWQuaSxcbiAgICAgICAgICAgICAgcG9zdHBvbmVkOiBpbml0aWFsUlNDUGF5bG9hZC5zLFxuICAgICAgICAgICAgICBwcmVyZW5kZXJlZDogaW5pdGlhbFJTQ1BheWxvYWQuUyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgKGVycjogRXJyb3IpID0+IHJlamVjdChlcnIpXG4gICAgKVxuICB9XG4pXG5cbmZ1bmN0aW9uIFNlcnZlclJvb3QoKTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgY29uc3QgaW5pdGlhbFJTQ1BheWxvYWQgPSB1c2UoaW5pdGlhbFNlcnZlclJlc3BvbnNlKVxuICBjb25zdCBhY3Rpb25RdWV1ZSA9IHVzZTxBcHBSb3V0ZXJBY3Rpb25RdWV1ZT4ocGVuZGluZ0FjdGlvblF1ZXVlKVxuXG4gIGNvbnN0IHJvdXRlciA9IChcbiAgICA8QXBwUm91dGVyXG4gICAgICBhY3Rpb25RdWV1ZT17YWN0aW9uUXVldWV9XG4gICAgICBnbG9iYWxFcnJvckNvbXBvbmVudEFuZFN0eWxlcz17aW5pdGlhbFJTQ1BheWxvYWQuR31cbiAgICAgIGFzc2V0UHJlZml4PXtpbml0aWFsUlNDUGF5bG9hZC5wfVxuICAgIC8+XG4gIClcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgaW5pdGlhbFJTQ1BheWxvYWQubSkge1xuICAgIC8vIFdlIHByb3ZpZGUgbWlzc2luZyBzbG90IGluZm9ybWF0aW9uIGluIGEgY29udGV4dCBwcm92aWRlciBvbmx5IGR1cmluZyBkZXZlbG9wbWVudFxuICAgIC8vIGFzIHdlIGxvZyBzb21lIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1pc3Npbmcgc2xvdHMgaW4gdGhlIGNvbnNvbGUuXG4gICAgcmV0dXJuIChcbiAgICAgIDxNaXNzaW5nU2xvdENvbnRleHQgdmFsdWU9e2luaXRpYWxSU0NQYXlsb2FkLm19PlxuICAgICAgICB7cm91dGVyfVxuICAgICAgPC9NaXNzaW5nU2xvdENvbnRleHQ+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHJvdXRlclxufVxuXG5jb25zdCBTdHJpY3RNb2RlSWZFbmFibGVkID0gcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFX0FQUFxuICA/IFJlYWN0LlN0cmljdE1vZGVcbiAgOiBSZWFjdC5GcmFnbWVudFxuXG5mdW5jdGlvbiBSb290KHsgY2hpbGRyZW4gfTogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e30+KSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlXG4gICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCPy4oKVxuICAgIH0sIFtdKVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbmNvbnN0IHJlYWN0Um9vdE9wdGlvbnM6IFJlYWN0RE9NQ2xpZW50LlJvb3RPcHRpb25zID0ge1xuICBvblJlY292ZXJhYmxlRXJyb3IsXG4gIG9uQ2F1Z2h0RXJyb3IsXG4gIG9uVW5jYXVnaHRFcnJvcixcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUoKSB7XG4gIGNvbnN0IHJlYWN0RWwgPSAoXG4gICAgPFN0cmljdE1vZGVJZkVuYWJsZWQ+XG4gICAgICA8SGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IGFwcERpcjogdHJ1ZSB9fT5cbiAgICAgICAgPFJvb3Q+XG4gICAgICAgICAgPFNlcnZlclJvb3QgLz5cbiAgICAgICAgPC9Sb290PlxuICAgICAgPC9IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9TdHJpY3RNb2RlSWZFbmFibGVkPlxuICApXG5cbiAgaWYgKFxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5pZCA9PT0gJ19fbmV4dF9lcnJvcl9fJyB8fFxuICAgICEhd2luZG93Ll9fbmV4dF9yb290X2xheW91dF9taXNzaW5nX3RhZ3M/Lmxlbmd0aFxuICApIHtcbiAgICBsZXQgZWxlbWVudCA9IHJlYWN0RWxcbiAgICAvLyBTZXJ2ZXIgcmVuZGVyaW5nIGZhaWxlZCwgZmFsbCBiYWNrIHRvIGNsaWVudC1zaWRlIHJlbmRlcmluZ1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNob3VsZFJlbmRlclJvb3RMZXZlbEVycm9yT3ZlcmxheSgpXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGNyZWF0ZVJvb3RMZXZlbERldk92ZXJsYXlFbGVtZW50IH0gPVxuICAgICAgICByZXF1aXJlKCcuL2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvYXBwL2NsaWVudC1lbnRyeScpIGFzIHR5cGVvZiBpbXBvcnQoJy4vY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9hcHAvY2xpZW50LWVudHJ5JylcblxuICAgICAgLy8gTm90ZSB0aGlzIHdvbid0IGNhdXNlIGh5ZHJhdGlvbiBtaXNtYXRjaCBiZWNhdXNlIHdlIGFyZSBkb2luZyBDU1Igdy9vIGh5ZHJhdGlvblxuICAgICAgZWxlbWVudCA9IGNyZWF0ZVJvb3RMZXZlbERldk92ZXJsYXlFbGVtZW50KGVsZW1lbnQpXG4gICAgfVxuXG4gICAgUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdChhcHBFbGVtZW50LCByZWFjdFJvb3RPcHRpb25zKS5yZW5kZXIoZWxlbWVudClcbiAgfSBlbHNlIHtcbiAgICBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgUmVhY3RET01DbGllbnQuaHlkcmF0ZVJvb3QoYXBwRWxlbWVudCwgcmVhY3RFbCwge1xuICAgICAgICAuLi5yZWFjdFJvb3RPcHRpb25zLFxuICAgICAgICBmb3JtU3RhdGU6IGluaXRpYWxGb3JtU3RhdGVEYXRhLFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLy8gVE9ETy1BUFA6IFJlbW92ZSB0aGlzIGxvZ2ljIHdoZW4gRmxvYXQgaGFzIEdDIGJ1aWx0LWluIGluIGRldmVsb3BtZW50LlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHsgbGlua0djIH0gPVxuICAgICAgcmVxdWlyZSgnLi9hcHAtbGluay1nYycpIGFzIHR5cGVvZiBpbXBvcnQoJy4vYXBwLWxpbmstZ2MnKVxuICAgIGxpbmtHYygpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJoeWRyYXRlIiwiYXBwRWxlbWVudCIsImRvY3VtZW50IiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIiLCJ1bmRlZmluZWQiLCJpbml0aWFsU2VydmVyRGF0YVdyaXRlciIsImluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkIiwiaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkIiwiaW5pdGlhbEZvcm1TdGF0ZURhdGEiLCJuZXh0U2VydmVyRGF0YUNhbGxiYWNrIiwic2VnIiwiRXJyb3IiLCJlbnF1ZXVlIiwiZW5jb2RlIiwicHVzaCIsImJpbmFyeVN0cmluZyIsImF0b2IiLCJkZWNvZGVkQ2h1bmsiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwiaSIsImNoYXJDb2RlQXQiLCJpc1N0cmVhbUVycm9yT3JVbmZpbmlzaGVkIiwiY3RyIiwiZGVzaXJlZFNpemUiLCJuZXh0U2VydmVyRGF0YVJlZ2lzdGVyV3JpdGVyIiwiZm9yRWFjaCIsInZhbCIsImVycm9yIiwiY2xvc2UiLCJET01Db250ZW50TG9hZGVkIiwicmVhZHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJzZXRUaW1lb3V0IiwibmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsIiwic2VsZiIsIl9fbmV4dF9mIiwicmVhZGFibGUiLCJSZWFkYWJsZVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsImluaXRpYWxTZXJ2ZXJSZXNwb25zZSIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwicGVuZGluZ0FjdGlvblF1ZXVlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0aGVuIiwiaW5pdGlhbFJTQ1BheWxvYWQiLCJzZXRBcHBCdWlsZElkIiwiYiIsImNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZSIsImNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSIsImluaXRpYWxGbGlnaHREYXRhIiwiZiIsImluaXRpYWxDYW5vbmljYWxVcmxQYXJ0cyIsImMiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJsb2NhdGlvbiIsIndpbmRvdyIsImNvdWxkQmVJbnRlcmNlcHRlZCIsInBvc3Rwb25lZCIsInMiLCJwcmVyZW5kZXJlZCIsIlMiLCJlcnIiLCJTZXJ2ZXJSb290IiwidXNlIiwiYWN0aW9uUXVldWUiLCJyb3V0ZXIiLCJBcHBSb3V0ZXIiLCJnbG9iYWxFcnJvckNvbXBvbmVudEFuZFN0eWxlcyIsIkciLCJhc3NldFByZWZpeCIsInAiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtIiwiTWlzc2luZ1Nsb3RDb250ZXh0IiwidmFsdWUiLCJTdHJpY3RNb2RlSWZFbmFibGVkIiwiX19ORVhUX1NUUklDVF9NT0RFX0FQUCIsIlJlYWN0IiwiU3RyaWN0TW9kZSIsIkZyYWdtZW50IiwiUm9vdCIsImNoaWxkcmVuIiwiX19ORVhUX1RFU1RfTU9ERSIsInVzZUVmZmVjdCIsIl9fTkVYVF9IWURSQVRFRCIsIl9fTkVYVF9IWURSQVRFRF9DQiIsInJlYWN0Um9vdE9wdGlvbnMiLCJvblJlY292ZXJhYmxlRXJyb3IiLCJvbkNhdWdodEVycm9yIiwib25VbmNhdWdodEVycm9yIiwicmVhY3RFbCIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIlByb3ZpZGVyIiwiYXBwRGlyIiwiZG9jdW1lbnRFbGVtZW50IiwiaWQiLCJfX25leHRfcm9vdF9sYXlvdXRfbWlzc2luZ190YWdzIiwiZWxlbWVudCIsInNob3VsZFJlbmRlclJvb3RMZXZlbEVycm9yT3ZlcmxheSIsImNyZWF0ZVJvb3RMZXZlbERldk92ZXJsYXlFbGVtZW50IiwicmVxdWlyZSIsIlJlYWN0RE9NQ2xpZW50IiwiY3JlYXRlUm9vdCIsInJlbmRlciIsInN0YXJ0VHJhbnNpdGlvbiIsImh5ZHJhdGVSb290IiwiZm9ybVN0YXRlIiwibGlua0djIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/app-link-gc.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"linkGc\", ({\n    enumerable: true,\n    get: function() {\n        return linkGc;\n    }\n}));\nfunction linkGc() {\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const callback = (mutationList)=>{\n            for (const mutation of mutationList){\n                if (mutation.type === 'childList') {\n                    for (const node of mutation.addedNodes){\n                        if ('tagName' in node && node.tagName === 'LINK') {\n                            var _link_dataset_precedence;\n                            const link = node;\n                            if ((_link_dataset_precedence = link.dataset.precedence) == null ? void 0 : _link_dataset_precedence.startsWith('next')) {\n                                const href = link.getAttribute('href');\n                                if (href) {\n                                    const [resource, version] = href.split('?v=', 2);\n                                    if (version) {\n                                        const currentOrigin = window.location.origin;\n                                        const allLinks = [\n                                            ...document.querySelectorAll('link[href^=\"' + resource + '\"]'),\n                                            // It's possible that the resource is a full URL or only pathname,\n                                            // so we need to remove the alternative href as well.\n                                            ...document.querySelectorAll('link[href^=\"' + (resource.startsWith(currentOrigin) ? resource.slice(currentOrigin.length) : currentOrigin + resource) + '\"]')\n                                        ];\n                                        for (const otherLink of allLinks){\n                                            var _otherLink_dataset_precedence;\n                                            if ((_otherLink_dataset_precedence = otherLink.dataset.precedence) == null ? void 0 : _otherLink_dataset_precedence.startsWith('next')) {\n                                                const otherHref = otherLink.getAttribute('href');\n                                                if (otherHref) {\n                                                    const [, otherVersion] = otherHref.split('?v=', 2);\n                                                    if (!otherVersion || +otherVersion < +version) {\n                                                        // Delay the removal of the stylesheet to avoid FOUC\n                                                        // caused by `@font-face` rules, as they seem to be\n                                                        // a couple of ticks delayed between the old and new\n                                                        // styles being swapped even if the font is cached.\n                                                        setTimeout(()=>{\n                                                            otherLink.remove();\n                                                        }, 5);\n                                                        const preloadLink = document.querySelector('link[rel=\"preload\"][as=\"style\"][href=\"' + otherHref + '\"]');\n                                                        if (preloadLink) {\n                                                            preloadLink.remove();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        // Create an observer instance linked to the callback function\n        const observer = new MutationObserver(callback);\n        observer.observe(document.head, {\n            childList: true\n        });\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-link-gc.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1saW5rLWdjLmpzIiwibWFwcGluZ3MiOiI7Ozs7MENBQWdCQTs7O2VBQUFBOzs7QUFBVCxTQUFTQTtJQUNkLHlFQUF5RTtJQUN6RSxJQUFJQyxJQUFvQixFQUFtQjtRQUN6QyxNQUFNRyxXQUFXLENBQUNDO1lBQ2hCLEtBQUssTUFBTUMsWUFBWUQsYUFBYztnQkFDbkMsSUFBSUMsU0FBU0MsSUFBSSxLQUFLLGFBQWE7b0JBQ2pDLEtBQUssTUFBTUMsUUFBUUYsU0FBU0csVUFBVSxDQUFFO3dCQUN0QyxJQUNFLGFBQWFELFFBQ1pBLEtBQXlCRSxPQUFPLEtBQUssUUFDdEM7Z0NBRUlDOzRCQURKLE1BQU1BLE9BQU9IOzRCQUNiLEtBQUlHLDJCQUFBQSxLQUFLQyxPQUFPLENBQUNDLFVBQUFBLEtBQVUsZ0JBQXZCRix5QkFBeUJHLFVBQVUsQ0FBQyxTQUFTO2dDQUMvQyxNQUFNQyxPQUFPSixLQUFLSyxZQUFZLENBQUM7Z0NBQy9CLElBQUlELE1BQU07b0NBQ1IsTUFBTSxDQUFDRSxVQUFVQyxRQUFRLEdBQUdILEtBQUtJLEtBQUssQ0FBQyxPQUFPO29DQUM5QyxJQUFJRCxTQUFTO3dDQUNYLE1BQU1FLGdCQUFnQkMsT0FBT0MsUUFBUSxDQUFDQyxNQUFNO3dDQUM1QyxNQUFNQyxXQUFXOytDQUNaQyxTQUFTQyxnQkFBZ0IsQ0FDMUIsaUJBQWlCVCxXQUFXOzRDQUU5QixrRUFBa0U7NENBQ2xFLHFEQUFxRDsrQ0FDbERRLFNBQVNDLGdCQUFnQixDQUMxQixpQkFDR1QsQ0FBQUEsU0FBU0gsVUFBVSxDQUFDTSxpQkFDakJILFNBQVNVLEtBQUssQ0FBQ1AsY0FBY1EsTUFBTSxJQUNuQ1IsZ0JBQWdCSCxRQUFBQSxDQUFPLEdBQzNCO3lDQUVMO3dDQUVELEtBQUssTUFBTVksYUFBYUwsU0FBVTtnREFDNUJLOzRDQUFKLEtBQUlBLGdDQUFBQSxVQUFVakIsT0FBTyxDQUFDQyxVQUFBQSxLQUFVLGdCQUE1QmdCLDhCQUE4QmYsVUFBVSxDQUFDLFNBQVM7Z0RBQ3BELE1BQU1nQixZQUFZRCxVQUFVYixZQUFZLENBQUM7Z0RBQ3pDLElBQUljLFdBQVc7b0RBQ2IsTUFBTSxHQUFHQyxhQUFhLEdBQUdELFVBQVVYLEtBQUssQ0FBQyxPQUFPO29EQUNoRCxJQUFJLENBQUNZLGdCQUFnQixDQUFDQSxlQUFlLENBQUNiLFNBQVM7d0RBQzdDLG9EQUFvRDt3REFDcEQsbURBQW1EO3dEQUNuRCxvREFBb0Q7d0RBQ3BELG1EQUFtRDt3REFDbkRjLFdBQVc7NERBQ1RILFVBQVVJLE1BQU07d0RBQ2xCLEdBQUc7d0RBQ0gsTUFBTUMsY0FBY1QsU0FBU1UsYUFBYSxDQUN2QywyQ0FBd0NMLFlBQVU7d0RBRXJELElBQUlJLGFBQWE7NERBQ2ZBLFlBQVlELE1BQU07d0RBQ3BCO29EQUNGO2dEQUNGOzRDQUNGO3dDQUNGO29DQUNGO2dDQUNGOzRCQUNGO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLDhEQUE4RDtRQUM5RCxNQUFNRyxXQUFXLElBQUlDLGlCQUFpQmpDO1FBQ3RDZ0MsU0FBU0UsT0FBTyxDQUFDYixTQUFTYyxJQUFJLEVBQUU7WUFDOUJDLFdBQVc7UUFDYjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXE9uZURyaXZlXFxEZXNrdG9wXFxzcmNcXGNsaWVudFxcYXBwLWxpbmstZ2MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGxpbmtHYygpIHtcbiAgLy8gVE9ETy1BUFA6IFJlbW92ZSB0aGlzIGxvZ2ljIHdoZW4gRmxvYXQgaGFzIEdDIGJ1aWx0LWluIGluIGRldmVsb3BtZW50LlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKG11dGF0aW9uTGlzdDogTXV0YXRpb25SZWNvcmRbXSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbkxpc3QpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG11dGF0aW9uLmFkZGVkTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgJ3RhZ05hbWUnIGluIG5vZGUgJiZcbiAgICAgICAgICAgICAgKG5vZGUgYXMgSFRNTExpbmtFbGVtZW50KS50YWdOYW1lID09PSAnTElOSydcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCBsaW5rID0gbm9kZSBhcyBIVE1MTGlua0VsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKGxpbmsuZGF0YXNldC5wcmVjZWRlbmNlPy5zdGFydHNXaXRoKCduZXh0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBbcmVzb3VyY2UsIHZlcnNpb25dID0gaHJlZi5zcGxpdCgnP3Y9JywgMilcbiAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbExpbmtzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlua1tocmVmXj1cIicgKyByZXNvdXJjZSArICdcIl0nXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHJlc291cmNlIGlzIGEgZnVsbCBVUkwgb3Igb25seSBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgYWx0ZXJuYXRpdmUgaHJlZiBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICAgIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlua1tocmVmXj1cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzb3VyY2Uuc3RhcnRzV2l0aChjdXJyZW50T3JpZ2luKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzb3VyY2Uuc2xpY2UoY3VycmVudE9yaWdpbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50T3JpZ2luICsgcmVzb3VyY2UpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiXSdcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBdIGFzIEhUTUxMaW5rRWxlbWVudFtdXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvdGhlckxpbmsgb2YgYWxsTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJMaW5rLmRhdGFzZXQucHJlY2VkZW5jZT8uc3RhcnRzV2l0aCgnbmV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckhyZWYgPSBvdGhlckxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgb3RoZXJWZXJzaW9uXSA9IG90aGVySHJlZi5zcGxpdCgnP3Y9JywgMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlclZlcnNpb24gfHwgK290aGVyVmVyc2lvbiA8ICt2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsYXkgdGhlIHJlbW92YWwgb2YgdGhlIHN0eWxlc2hlZXQgdG8gYXZvaWQgRk9VQ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdXNlZCBieSBgQGZvbnQtZmFjZWAgcnVsZXMsIGFzIHRoZXkgc2VlbSB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgY291cGxlIG9mIHRpY2tzIGRlbGF5ZWQgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgYmVpbmcgc3dhcHBlZCBldmVuIGlmIHRoZSBmb250IGlzIGNhY2hlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyTGluay5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlbG9hZExpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxpbmtbcmVsPVwicHJlbG9hZFwiXVthcz1cInN0eWxlXCJdW2hyZWY9XCIke290aGVySHJlZn1cIl1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVsb2FkTGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlbG9hZExpbmsucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgbGlua2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5oZWFkLCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbImxpbmtHYyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNhbGxiYWNrIiwibXV0YXRpb25MaXN0IiwibXV0YXRpb24iLCJ0eXBlIiwibm9kZSIsImFkZGVkTm9kZXMiLCJ0YWdOYW1lIiwibGluayIsImRhdGFzZXQiLCJwcmVjZWRlbmNlIiwic3RhcnRzV2l0aCIsImhyZWYiLCJnZXRBdHRyaWJ1dGUiLCJyZXNvdXJjZSIsInZlcnNpb24iLCJzcGxpdCIsImN1cnJlbnRPcmlnaW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImFsbExpbmtzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwic2xpY2UiLCJsZW5ndGgiLCJvdGhlckxpbmsiLCJvdGhlckhyZWYiLCJvdGhlclZlcnNpb24iLCJzZXRUaW1lb3V0IiwicmVtb3ZlIiwicHJlbG9hZExpbmsiLCJxdWVyeVNlbGVjdG9yIiwib2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImhlYWQiLCJjaGlsZExpc3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createEmptyCacheNode: function() {\n        return createEmptyCacheNode;\n    },\n    createPrefetchURL: function() {\n        return createPrefetchURL;\n    },\n    default: function() {\n        return AppRouter;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _createhreffromurl = __webpack_require__(/*! ./router-reducer/create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _usereducer = __webpack_require__(/*! ./use-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/use-reducer.js\");\nconst _errorboundary = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\"));\nconst _isbot = __webpack_require__(/*! ../../shared/lib/router/utils/is-bot */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _approuterannouncer = __webpack_require__(/*! ./app-router-announcer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-announcer.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _findheadincache = __webpack_require__(/*! ./router-reducer/reducers/find-head-in-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\");\nconst _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/unresolved-thenable.js\");\nconst _removebasepath = __webpack_require__(/*! ../remove-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _computechangedpath = __webpack_require__(/*! ./router-reducer/compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _navfailurehandler = __webpack_require__(/*! ./nav-failure-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/nav-failure-handler.js\");\nconst _appcallserver = __webpack_require__(/*! ../app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _segmentcache = __webpack_require__(/*! ./segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nconst _redirect = __webpack_require__(/*! ./redirect */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ./redirect-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-error.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./router-reducer/reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _links = __webpack_require__(/*! ./links */ \"(app-pages-browser)/./node_modules/next/dist/client/components/links.js\");\nconst globalMutable = {};\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\nfunction createPrefetchURL(href) {\n    // Don't prefetch for bots as they don't navigate.\n    if ((0, _isbot.isBot)(window.navigator.userAgent)) {\n        return null;\n    }\n    let url;\n    try {\n        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);\n    } catch (_) {\n        // TODO: Does this need to throw or can we just console.error instead? Does\n        // anyone rely on this throwing? (Seems unlikely.)\n        throw Object.defineProperty(new Error(\"Cannot prefetch '\" + href + \"' because it cannot be converted to a URL.\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E234\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Don't prefetch during development (improves compilation performance)\n    if (true) {\n        return null;\n    }\n    // External urls can't be prefetched in the same way.\n    if (isExternalURL(url)) {\n        return null;\n    }\n    return url;\n}\nfunction HistoryUpdater(param) {\n    let { appRouterState } = param;\n    (0, _react.useInsertionEffect)(()=>{\n        if (false) {}\n        const { tree, pushRef, canonicalUrl } = appRouterState;\n        const historyState = {\n            ...pushRef.preserveCustomHistoryState ? window.history.state : {},\n            // Identifier is shortened intentionally.\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            // __N is used to identify if the history entry can be handled by the old router.\n            __NA: true,\n            __PRIVATE_NEXTJS_INTERNALS_TREE: tree\n        };\n        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n        // This mirrors the browser behavior for normal navigation.\n        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, '', canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, '', canonicalUrl);\n        }\n    }, [\n        appRouterState\n    ]);\n    (0, _react.useEffect)(()=>{\n        // The Next-Url and the base tree may affect the result of a prefetch\n        // task. Re-prefetch all visible links with the updated values. In most\n        // cases, this will not result in any new network requests, only if\n        // the prefetch result actually varies on one of these inputs.\n        if (false) {}\n    }, [\n        appRouterState.nextUrl,\n        appRouterState.tree\n    ]);\n    return null;\n}\n_c = HistoryUpdater;\nfunction createEmptyCacheNode() {\n    return {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null\n    };\n}\n/**\n * Server response that only patches the cache and tree.\n */ function useChangeByServerResponse(dispatch) {\n    return (0, _react.useCallback)((param)=>{\n        let { previousTree, serverResponse } = param;\n        (0, _react.startTransition)(()=>{\n            dispatch({\n                type: _routerreducertypes.ACTION_SERVER_PATCH,\n                previousTree,\n                serverResponse\n            });\n        });\n    }, [\n        dispatch\n    ]);\n}\nfunction useNavigate(dispatch) {\n    return (0, _react.useCallback)((href, navigateType, shouldScroll)=>{\n        const url = new URL((0, _addbasepath.addBasePath)(href), location.href);\n        if (false) {}\n        return dispatch({\n            type: _routerreducertypes.ACTION_NAVIGATE,\n            url,\n            isExternalUrl: isExternalURL(url),\n            locationSearch: location.search,\n            shouldScroll: shouldScroll != null ? shouldScroll : true,\n            navigateType,\n            allowAliasing: true\n        });\n    }, [\n        dispatch\n    ]);\n}\nfunction copyNextJsInternalHistoryState(data) {\n    if (data == null) data = {};\n    const currentState = window.history.state;\n    const __NA = currentState == null ? void 0 : currentState.__NA;\n    if (__NA) {\n        data.__NA = __NA;\n    }\n    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState == null ? void 0 : currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;\n    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;\n    }\n    return data;\n}\nfunction Head(param) {\n    let { headCacheNode } = param;\n    // If this segment has a `prefetchHead`, it's the statically prefetched data.\n    // We should use that on initial render instead of `head`. Then we'll switch\n    // to `head` when the dynamic response streams in.\n    const head = headCacheNode !== null ? headCacheNode.head : null;\n    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;\n    // If no prefetch data is available, then we go straight to rendering `head`.\n    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);\n}\n_c1 = Head;\n/**\n * The global router that wraps the application components.\n */ function Router(param) {\n    _s();\n    let { actionQueue, assetPrefix, globalError } = param;\n    const [state, dispatch] = (0, _usereducer.useReducer)(actionQueue);\n    const { canonicalUrl } = (0, _usereducer.useUnwrapState)(state);\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams, pathname } = (0, _react.useMemo)(()=>{\n        const url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    const changeByServerResponse = useChangeByServerResponse(dispatch);\n    const navigate = useNavigate(dispatch);\n    (0, _appcallserver.useServerActionDispatcher)(dispatch);\n    /**\n   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.\n   */ const appRouter = (0, _react.useMemo)(()=>{\n        const routerInstance = {\n            back: ()=>window.history.back(),\n            forward: ()=>window.history.forward(),\n            prefetch:  false ? // cache. So we don't need to dispatch an action.\n            0 : (href, options)=>{\n                // Use the old prefetch implementation.\n                const url = createPrefetchURL(href);\n                if (url !== null) {\n                    var _options_kind;\n                    // The prefetch reducer doesn't actually update any state or\n                    // trigger a rerender. It just writes to a mutable cache. So we\n                    // shouldn't bother calling setState/dispatch; we can just re-run\n                    // the reducer directly using the current state.\n                    // TODO: Refactor this away from a \"reducer\" so it's\n                    // less confusing.\n                    (0, _prefetchreducer.prefetchReducer)(actionQueue.state, {\n                        type: _routerreducertypes.ACTION_PREFETCH,\n                        url,\n                        kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : _routerreducertypes.PrefetchKind.FULL\n                    });\n                }\n            },\n            replace: (href, options)=>{\n                if (options === void 0) options = {};\n                (0, _react.startTransition)(()=>{\n                    var _options_scroll;\n                    navigate(href, 'replace', (_options_scroll = options.scroll) != null ? _options_scroll : true);\n                });\n            },\n            push: (href, options)=>{\n                if (options === void 0) options = {};\n                (0, _react.startTransition)(()=>{\n                    var _options_scroll;\n                    navigate(href, 'push', (_options_scroll = options.scroll) != null ? _options_scroll : true);\n                });\n            },\n            refresh: ()=>{\n                (0, _react.startTransition)(()=>{\n                    dispatch({\n                        type: _routerreducertypes.ACTION_REFRESH,\n                        origin: window.location.origin\n                    });\n                });\n            },\n            hmrRefresh: ()=>{\n                if (false) {} else {\n                    (0, _react.startTransition)(()=>{\n                        dispatch({\n                            type: _routerreducertypes.ACTION_HMR_REFRESH,\n                            origin: window.location.origin\n                        });\n                    });\n                }\n            }\n        };\n        return routerInstance;\n    }, [\n        actionQueue,\n        dispatch,\n        navigate\n    ]);\n    (0, _react.useEffect)(()=>{\n        // Exists for debugging purposes. Don't use in application code.\n        if (window.next) {\n            window.next.router = appRouter;\n        }\n    }, [\n        appRouter\n    ]);\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const { cache, prefetchCache, tree } = (0, _usereducer.useUnwrapState)(state);\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            // Add `window.nd` for debugging purposes.\n            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n            // @ts-ignore this is for debugging\n            window.nd = {\n                router: appRouter,\n                cache,\n                prefetchCache,\n                tree\n            };\n        }, [\n            appRouter,\n            cache,\n            prefetchCache,\n            tree\n        ]);\n    }\n    (0, _react.useEffect)(()=>{\n        // If the app is restored from bfcache, it's possible that\n        // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n        // would trigger the mpa navigation logic again from the lines below.\n        // This will restore the router to the initial state in the event that the app is restored from bfcache.\n        function handlePageShow(event) {\n            var _window_history_state;\n            if (!event.persisted || !((_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE)) {\n                return;\n            }\n            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n            // of the last MPA navigation.\n            globalMutable.pendingMpaPath = undefined;\n            dispatch({\n                type: _routerreducertypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n            });\n        }\n        window.addEventListener('pageshow', handlePageShow);\n        return ()=>{\n            window.removeEventListener('pageshow', handlePageShow);\n        };\n    }, [\n        dispatch\n    ]);\n    (0, _react.useEffect)(()=>{\n        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n        // are caught and handled by the router.\n        function handleUnhandledRedirect(event) {\n            const error = 'reason' in event ? event.reason : event.error;\n            if ((0, _redirecterror.isRedirectError)(error)) {\n                event.preventDefault();\n                const url = (0, _redirect.getURLFromRedirectError)(error);\n                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n                if (redirectType === _redirecterror.RedirectType.push) {\n                    appRouter.push(url, {});\n                } else {\n                    appRouter.replace(url, {});\n                }\n            }\n        }\n        window.addEventListener('error', handleUnhandledRedirect);\n        window.addEventListener('unhandledrejection', handleUnhandledRedirect);\n        return ()=>{\n            window.removeEventListener('error', handleUnhandledRedirect);\n            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);\n        };\n    }, [\n        appRouter\n    ]);\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    // Infinitely suspend because we don't actually want to rerender any child\n    // components with the new URL and any entangled state updates shouldn't\n    // commit either (eg: useTransition isPending should stay true until the page\n    // unloads).\n    //\n    // This is a side effect in render. Don't try this at home, kids. It's\n    // probably safe because we know this is a singleton component and it's never\n    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n    // but that's... fine?)\n    const { pushRef } = (0, _usereducer.useUnwrapState)(state);\n    if (pushRef.mpaNavigation) {\n        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n        if (globalMutable.pendingMpaPath !== canonicalUrl) {\n            const location1 = window.location;\n            if (pushRef.pendingPush) {\n                location1.assign(canonicalUrl);\n            } else {\n                location1.replace(canonicalUrl);\n            }\n            globalMutable.pendingMpaPath = canonicalUrl;\n        }\n        // TODO-APP: Should we listen to navigateerror here to catch failed\n        // navigations somehow? And should we call window.stop() if a SPA navigation\n        // should interrupt an MPA one?\n        (0, _react.use)(_unresolvedthenable.unresolvedThenable);\n    }\n    (0, _react.useEffect)(()=>{\n        const originalPushState = window.history.pushState.bind(window.history);\n        const originalReplaceState = window.history.replaceState.bind(window.history);\n        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n        const applyUrlFromHistoryPushReplace = (url)=>{\n            var _window_history_state;\n            const href = window.location.href;\n            const tree = (_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE;\n            (0, _react.startTransition)(()=>{\n                dispatch({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(url != null ? url : href, href),\n                    tree\n                });\n            });\n        };\n        /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.pushState = function pushState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {\n                return originalPushState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalPushState(data, _unused, url);\n        };\n        /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.replaceState = function replaceState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {\n                return originalReplaceState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalReplaceState(data, _unused, url);\n        };\n        /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */ const onPopState = (event)=>{\n            if (!event.state) {\n                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n                return;\n            }\n            // This case happens when the history entry was pushed by the `pages` router.\n            if (!event.state.__NA) {\n                window.location.reload();\n                return;\n            }\n            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n            // Without startTransition works if the cache is there for this path\n            (0, _react.startTransition)(()=>{\n                dispatch({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(window.location.href),\n                    tree: event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n                });\n            });\n        };\n        // Register popstate event to call onPopstate.\n        window.addEventListener('popstate', onPopState);\n        return ()=>{\n            window.history.pushState = originalPushState;\n            window.history.replaceState = originalReplaceState;\n            window.removeEventListener('popstate', onPopState);\n        };\n    }, [\n        dispatch\n    ]);\n    const { cache, tree, nextUrl, focusAndScrollRef } = (0, _usereducer.useUnwrapState)(state);\n    const matchingHead = (0, _react.useMemo)(()=>{\n        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);\n    }, [\n        cache,\n        tree\n    ]);\n    // Add memoized pathParams for useParams.\n    const pathParams = (0, _react.useMemo)(()=>{\n        return (0, _computechangedpath.getSelectedParams)(tree);\n    }, [\n        tree\n    ]);\n    const layoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            parentTree: tree,\n            parentCacheNode: cache,\n            parentSegmentPath: null,\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl\n        };\n    }, [\n        tree,\n        cache,\n        canonicalUrl\n    ]);\n    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            changeByServerResponse,\n            tree,\n            focusAndScrollRef,\n            nextUrl\n        };\n    }, [\n        changeByServerResponse,\n        tree,\n        focusAndScrollRef,\n        nextUrl\n    ]);\n    let head;\n    if (matchingHead !== null) {\n        // The head is wrapped in an extra component so we can use\n        // `useDeferredValue` to swap between the prefetched and final versions of\n        // the head. (This is what LayoutRouter does for segment data, too.)\n        //\n        // The `key` is used to remount the component whenever the head moves to\n        // a different segment.\n        const [headCacheNode, headKey] = matchingHead;\n        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n            headCacheNode: headCacheNode\n        }, headKey);\n    } else {\n        head = null;\n    }\n    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {\n        children: [\n            head,\n            cache.rsc,\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {\n                tree: tree\n            })\n        ]\n    });\n    if (true) {\n        // In development, we apply few error boundaries and hot-reloader:\n        // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n        // - HotReloader:\n        //  - hot-reload the app when the code changes\n        //  - render dev overlay\n        //  - catch runtime errors and display global-error when necessary\n        if (true) {\n            const { DevRootHTTPAccessFallbackBoundary } = __webpack_require__(/*! ./dev-root-http-access-fallback-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js\");\n            content = /*#__PURE__*/ (0, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {\n                children: content\n            });\n        }\n        const HotReloader = (__webpack_require__(/*! ./react-dev-overlay/app/hot-reloader-client */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js\")[\"default\"]);\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {\n            assetPrefix: assetPrefix,\n            globalError: globalError,\n            children: content\n        });\n    } else {}\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {\n                appRouterState: (0, _usereducer.useUnwrapState)(state)\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                value: pathParams,\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {\n                    value: pathname,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                        value: searchParams,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {\n                            value: globalLayoutRouterContext,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n                                value: appRouter,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n                                    value: layoutRouterContext,\n                                    children: content\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        ]\n    });\n}\n_s(Router, \"bU8t8nCPb2ycaFr1siwKA2Gych0=\", false, function() {\n    return [\n        useChangeByServerResponse,\n        useNavigate\n    ];\n});\n_c2 = Router;\nfunction AppRouter(param) {\n    let { actionQueue, globalErrorComponentAndStyles: [globalErrorComponent, globalErrorStyles], assetPrefix } = param;\n    (0, _navfailurehandler.useNavFailureHandler)();\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n        // At the very top level, use the default GlobalError component as the final fallback.\n        // When the app router itself fails, which means the framework itself fails, we show the default error.\n        errorComponent: _errorboundary.default,\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {\n            actionQueue: actionQueue,\n            assetPrefix: assetPrefix,\n            globalError: [\n                globalErrorComponent,\n                globalErrorStyles\n            ]\n        })\n    });\n}\n_c3 = AppRouter;\nconst runtimeStyles = new Set();\nlet runtimeStyleChanged = new Set();\nglobalThis._N_E_STYLE_LOAD = function(href) {\n    let len = runtimeStyles.size;\n    runtimeStyles.add(href);\n    if (runtimeStyles.size !== len) {\n        runtimeStyleChanged.forEach((cb)=>cb());\n    }\n    // TODO figure out how to get a promise here\n    // But maybe it's not necessary as react would block rendering until it's loaded\n    return Promise.resolve();\n};\nfunction RuntimeStyles() {\n    _s1();\n    const [, forceUpdate] = _react.default.useState(0);\n    const renderedStylesSize = runtimeStyles.size;\n    (0, _react.useEffect)(()=>{\n        const changed = ()=>forceUpdate((c)=>c + 1);\n        runtimeStyleChanged.add(changed);\n        if (renderedStylesSize !== runtimeStyles.size) {\n            changed();\n        }\n        return ()=>{\n            runtimeStyleChanged.delete(changed);\n        };\n    }, [\n        renderedStylesSize,\n        forceUpdate\n    ]);\n    const dplId =  false ? 0 : '';\n    return [\n        ...runtimeStyles\n    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"stylesheet\",\n            href: \"\" + href + dplId,\n            // @ts-ignore\n            precedence: \"next\"\n        }, i));\n}\n_s1(RuntimeStyles, \"Eht7Kgdrrgt5B4LSklQ7qDPo8Aw=\");\n_c4 = RuntimeStyles;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"HistoryUpdater\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Router\");\n$RefreshReg$(_c3, \"AppRouter\");\n$RefreshReg$(_c4, \"RuntimeStyles\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQStKZ0JBLG9CQUFvQjtlQUFwQkE7O0lBOUVBQyxpQkFBaUI7ZUFBakJBOztJQWdtQmhCLE9Bd0JDO2VBeEJ1QkM7Ozs7OzZFQXZxQmpCOzJEQUtBO2dEQWFBOytDQU8yQjs2REFLM0I7d0NBQ29DO3FGQUtwQzttQ0FDZTt5Q0FDTTtnREFDTzs4Q0FDRjs2Q0FDRDtnREFDRzs0Q0FDSjt5Q0FDSDtnREFDTTsrQ0FFRzsyQ0FDSzswQ0FFVztzQ0FDYTsyQ0FDcEI7NkNBQ2Q7bUNBQ0M7QUFFakMsTUFBTUMsZ0JBRUYsQ0FBQztBQUVMLFNBQVNDLGNBQWNDLEdBQVE7SUFDN0IsT0FBT0EsSUFBSUMsTUFBTSxLQUFLQyxPQUFPQyxRQUFRLENBQUNGLE1BQU07QUFDOUM7QUFTTyxTQUFTTCxrQkFBa0JRLElBQVk7SUFDNUMsa0RBQWtEO0lBQ2xELElBQUlDLENBQUFBLEdBQUFBLE9BQUFBLEtBQUFBLEVBQU1ILE9BQU9JLFNBQVMsQ0FBQ0MsU0FBUyxHQUFHO1FBQ3JDLE9BQU87SUFDVDtJQUVBLElBQUlQO0lBQ0osSUFBSTtRQUNGQSxNQUFNLElBQUlRLElBQUlDLENBQUFBLEdBQUFBLGFBQUFBLFdBQUFBLEVBQVlMLE9BQU9GLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSTtJQUN2RCxFQUFFLE9BQU9NLEdBQUc7UUFDViwyRUFBMkU7UUFDM0Usa0RBQWtEO1FBQ2xELE1BQU0scUJBRUwsQ0FGSyxJQUFJQyxNQUNQLHNCQUFtQlAsT0FBSywrQ0FEckI7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGO0lBRUEsdUVBQXVFO0lBQ3ZFLElBQUlRLElBQW9CLEVBQW9CO1FBQzFDLE9BQU87SUFDVDtJQUVBLHFEQUFxRDtJQUNyRCxJQUFJYixjQUFjQyxNQUFNO1FBQ3RCLE9BQU87SUFDVDtJ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Y0FBY00sSUFBSTtJQUM3QzdJLENBQUFBLEdBQUFBLE9BQUFBLFNBQUFBLEVBQVU7UUFDUixNQUFNdUosVUFBVSxJQUFNSixZQUFZLENBQUNLLElBQU1BLElBQUk7UUFDN0NmLG9CQUFvQkssR0FBRyxDQUFDUztRQUN4QixJQUFJRCx1QkFBdUJmLGNBQWNNLElBQUksRUFBRTtZQUM3Q1U7UUFDRjtRQUNBLE9BQU87WUFDTGQsb0JBQW9CZ0IsTUFBTSxDQUFDRjtRQUM3QjtJQUNGLEdBQUc7UUFBQ0Q7UUFBb0JIO0tBQVk7SUFFcEMsTUFBTU8sUUFBUWpMLE1BQThCLEdBQ3ZDLENBQXFDLEdBQ3RDO0lBQ0osT0FBTztXQUFJOEo7S0FBYyxDQUFDcUIsR0FBRyxDQUFDLENBQUMzTCxNQUFNNEwsSUFBQUEsV0FBQUEsR0FDbkMscUJBQUNDLFFBQUFBO1lBRUNDLEtBQUk7WUFDSjlMLE1BQU8sS0FBRUEsT0FBT3lMO1lBQ2hCLGFBQWE7WUFDYk0sWUFBVztXQUpOSDtBQVVYOztNQTdCU3BDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxPbmVEcml2ZVxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXGFwcC1yb3V0ZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHtcbiAgdXNlLFxuICB1c2VFZmZlY3QsXG4gIHVzZU1lbW8sXG4gIHVzZUNhbGxiYWNrLFxuICBzdGFydFRyYW5zaXRpb24sXG4gIHVzZUluc2VydGlvbkVmZmVjdCxcbiAgdXNlRGVmZXJyZWRWYWx1ZSxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQge1xuICBBcHBSb3V0ZXJDb250ZXh0LFxuICBMYXlvdXRSb3V0ZXJDb250ZXh0LFxuICBHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHtcbiAgQ2FjaGVOb2RlLFxuICBBcHBSb3V0ZXJJbnN0YW5jZSxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQge1xuICBBQ1RJT05fSE1SX1JFRlJFU0gsXG4gIEFDVElPTl9OQVZJR0FURSxcbiAgQUNUSU9OX1BSRUZFVENILFxuICBBQ1RJT05fUkVGUkVTSCxcbiAgQUNUSU9OX1JFU1RPUkUsXG4gIEFDVElPTl9TRVJWRVJfUEFUQ0gsXG4gIFByZWZldGNoS2luZCxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgQXBwUm91dGVyU3RhdGUsXG4gIFJlZHVjZXJBY3Rpb25zLFxuICBSb3V0ZXJDaGFuZ2VCeVNlcnZlclJlc3BvbnNlLFxuICBSb3V0ZXJOYXZpZ2F0ZSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7XG4gIFNlYXJjaFBhcmFtc0NvbnRleHQsXG4gIFBhdGhuYW1lQ29udGV4dCxcbiAgUGF0aFBhcmFtc0NvbnRleHQsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyB1c2VSZWR1Y2VyLCB1c2VVbndyYXBTdGF0ZSB9IGZyb20gJy4vdXNlLXJlZHVjZXInXG5pbXBvcnQge1xuICBkZWZhdWx0IGFzIERlZmF1bHRHbG9iYWxFcnJvcixcbiAgRXJyb3JCb3VuZGFyeSxcbiAgdHlwZSBHbG9iYWxFcnJvckNvbXBvbmVudCxcbn0gZnJvbSAnLi9lcnJvci1ib3VuZGFyeSdcbmltcG9ydCB7IGlzQm90IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtYm90J1xuaW1wb3J0IHsgYWRkQmFzZVBhdGggfSBmcm9tICcuLi9hZGQtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgQXBwUm91dGVyQW5ub3VuY2VyIH0gZnJvbSAnLi9hcHAtcm91dGVyLWFubm91bmNlcidcbmltcG9ydCB7IFJlZGlyZWN0Qm91bmRhcnkgfSBmcm9tICcuL3JlZGlyZWN0LWJvdW5kYXJ5J1xuaW1wb3J0IHsgZmluZEhlYWRJbkNhY2hlIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9maW5kLWhlYWQtaW4tY2FjaGUnXG5pbXBvcnQgeyB1bnJlc29sdmVkVGhlbmFibGUgfSBmcm9tICcuL3VucmVzb2x2ZWQtdGhlbmFibGUnXG5pbXBvcnQgeyByZW1vdmVCYXNlUGF0aCB9IGZyb20gJy4uL3JlbW92ZS1iYXNlLXBhdGgnXG5pbXBvcnQgeyBoYXNCYXNlUGF0aCB9IGZyb20gJy4uL2hhcy1iYXNlLXBhdGgnXG5pbXBvcnQgeyBnZXRTZWxlY3RlZFBhcmFtcyB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvY29tcHV0ZS1jaGFuZ2VkLXBhdGgnXG5pbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyB1c2VOYXZGYWlsdXJlSGFuZGxlciB9IGZyb20gJy4vbmF2LWZhaWx1cmUtaGFuZGxlcidcbmltcG9ydCB7IHVzZVNlcnZlckFjdGlvbkRpc3BhdGNoZXIgfSBmcm9tICcuLi9hcHAtY2FsbC1zZXJ2ZXInXG5pbXBvcnQgdHlwZSB7IEFwcFJvdXRlckFjdGlvblF1ZXVlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvYWN0aW9uLXF1ZXVlJ1xuaW1wb3J0IHsgcHJlZmV0Y2ggYXMgcHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlIH0gZnJvbSAnLi9zZWdtZW50LWNhY2hlJ1xuaW1wb3J0IHsgZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yLCBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciB9IGZyb20gJy4vcmVkaXJlY3QnXG5pbXBvcnQgeyBpc1JlZGlyZWN0RXJyb3IsIFJlZGlyZWN0VHlwZSB9IGZyb20gJy4vcmVkaXJlY3QtZXJyb3InXG5pbXBvcnQgeyBwcmVmZXRjaFJlZHVjZXIgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXInXG5pbXBvcnQgeyBwaW5nVmlzaWJsZUxpbmtzIH0gZnJvbSAnLi9saW5rcydcblxuY29uc3QgZ2xvYmFsTXV0YWJsZToge1xuICBwZW5kaW5nTXBhUGF0aD86IHN0cmluZ1xufSA9IHt9XG5cbmZ1bmN0aW9uIGlzRXh0ZXJuYWxVUkwodXJsOiBVUkwpIHtcbiAgcmV0dXJuIHVybC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxpbmsgaHJlZiwgY29uc3RydWN0cyB0aGUgVVJMIHRoYXQgc2hvdWxkIGJlIHByZWZldGNoZWQuIFJldHVybnMgbnVsbFxuICogaW4gY2FzZXMgd2hlcmUgcHJlZmV0Y2hpbmcgc2hvdWxkIGJlIGRpc2FibGVkLCBsaWtlIGV4dGVybmFsIFVSTHMsIG9yXG4gKiBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gKiBAcGFyYW0gaHJlZiBUaGUgaHJlZiBwYXNzZWQgdG8gPExpbms+LCByb3V0ZXIucHJlZmV0Y2goKSwgb3Igc2ltaWxhclxuICogQHJldHVybnMgQSBVUkwgb2JqZWN0IHRvIHByZWZldGNoLCBvciBudWxsIGlmIHByZWZldGNoaW5nIHNob3VsZCBiZSBkaXNhYmxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hVUkwoaHJlZjogc3RyaW5nKTogVVJMIHwgbnVsbCB7XG4gIC8vIERvbid0IHByZWZldGNoIGZvciBib3RzIGFzIHRoZXkgZG9uJ3QgbmF2aWdhdGUuXG4gIGlmIChpc0JvdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IHVybDogVVJMXG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChhZGRCYXNlUGF0aChocmVmKSwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBUT0RPOiBEb2VzIHRoaXMgbmVlZCB0byB0aHJvdyBvciBjYW4gd2UganVzdCBjb25zb2xlLmVycm9yIGluc3RlYWQ/IERvZXNcbiAgICAvLyBhbnlvbmUgcmVseSBvbiB0aGlzIHRocm93aW5nPyAoU2VlbXMgdW5saWtlbHkuKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgcHJlZmV0Y2ggJyR7aHJlZn0nIGJlY2F1c2UgaXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIFVSTC5gXG4gICAgKVxuICB9XG5cbiAgLy8gRG9uJ3QgcHJlZmV0Y2ggZHVyaW5nIGRldmVsb3BtZW50IChpbXByb3ZlcyBjb21waWxhdGlvbiBwZXJmb3JtYW5jZSlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEV4dGVybmFsIHVybHMgY2FuJ3QgYmUgcHJlZmV0Y2hlZCBpbiB0aGUgc2FtZSB3YXkuXG4gIGlmIChpc0V4dGVybmFsVVJMKHVybCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBIaXN0b3J5VXBkYXRlcih7XG4gIGFwcFJvdXRlclN0YXRlLFxufToge1xuICBhcHBSb3V0ZXJTdGF0ZTogQXBwUm91dGVyU3RhdGVcbn0pIHtcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORykge1xuICAgICAgLy8gY2xlYXIgcGVuZGluZyBVUkwgYXMgbmF2aWdhdGlvbiBpcyBubyBsb25nZXJcbiAgICAgIC8vIGluIGZsaWdodFxuICAgICAgd2luZG93Lm5leHQuX19wZW5kaW5nVXJsID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgY29uc3QgeyB0cmVlLCBwdXNoUmVmLCBjYW5vbmljYWxVcmwgfSA9IGFwcFJvdXRlclN0YXRlXG4gICAgY29uc3QgaGlzdG9yeVN0YXRlID0ge1xuICAgICAgLi4uKHB1c2hSZWYucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPyB3aW5kb3cuaGlzdG9yeS5zdGF0ZSA6IHt9KSxcbiAgICAgIC8vIElkZW50aWZpZXIgaXMgc2hvcnRlbmVkIGludGVudGlvbmFsbHkuXG4gICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAvLyBfX04gaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgb2xkIHJvdXRlci5cbiAgICAgIF9fTkE6IHRydWUsXG4gICAgICBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFOiB0cmVlLFxuICAgIH1cbiAgICBpZiAoXG4gICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoICYmXG4gICAgICAvLyBTa2lwIHB1c2hpbmcgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5IGlmIHRoZSBjYW5vbmljYWxVcmwgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgdXJsLlxuICAgICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBicm93c2VyIGJlaGF2aW9yIGZvciBub3JtYWwgbmF2aWdhdGlvbi5cbiAgICAgIGNyZWF0ZUhyZWZGcm9tVXJsKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpKSAhPT0gY2Fub25pY2FsVXJsXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIGludGVudGlvbmFsbHkgbXV0YXRlcyBSZWFjdCBzdGF0ZSwgcHVzaFJlZiBpcyBvdmVyd3JpdHRlbiB0byBlbnN1cmUgYWRkaXRpb25hbCBwdXNoL3JlcGxhY2UgY2FsbHMgZG8gbm90IHRyaWdnZXIgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5LlxuICAgICAgcHVzaFJlZi5wZW5kaW5nUHVzaCA9IGZhbHNlXG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKVxuICAgIH1cbiAgfSwgW2FwcFJvdXRlclN0YXRlXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFRoZSBOZXh0LVVybCBhbmQgdGhlIGJhc2UgdHJlZSBtYXkgYWZmZWN0IHRoZSByZXN1bHQgb2YgYSBwcmVmZXRjaFxuICAgIC8vIHRhc2suIFJlLXByZWZldGNoIGFsbCB2aXNpYmxlIGxpbmtzIHdpdGggdGhlIHVwZGF0ZWQgdmFsdWVzLiBJbiBtb3N0XG4gICAgLy8gY2FzZXMsIHRoaXMgd2lsbCBub3QgcmVzdWx0IGluIGFueSBuZXcgbmV0d29yayByZXF1ZXN0cywgb25seSBpZlxuICAgIC8vIHRoZSBwcmVmZXRjaCByZXN1bHQgYWN0dWFsbHkgdmFyaWVzIG9uIG9uZSBvZiB0aGVzZSBpbnB1dHMuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgcGluZ1Zpc2libGVMaW5rcyhhcHBSb3V0ZXJTdGF0ZS5uZXh0VXJsLCBhcHBSb3V0ZXJTdGF0ZS50cmVlKVxuICAgIH1cbiAgfSwgW2FwcFJvdXRlclN0YXRlLm5leHRVcmwsIGFwcFJvdXRlclN0YXRlLnRyZWVdKVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpOiBDYWNoZU5vZGUge1xuICByZXR1cm4ge1xuICAgIGxhenlEYXRhOiBudWxsLFxuICAgIHJzYzogbnVsbCxcbiAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICBoZWFkOiBudWxsLFxuICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgIGxvYWRpbmc6IG51bGwsXG4gIH1cbn1cblxuLyoqXG4gKiBTZXJ2ZXIgcmVzcG9uc2UgdGhhdCBvbmx5IHBhdGNoZXMgdGhlIGNhY2hlIGFuZCB0cmVlLlxuICovXG5mdW5jdGlvbiB1c2VDaGFuZ2VCeVNlcnZlclJlc3BvbnNlKFxuICBkaXNwYXRjaDogUmVhY3QuRGlzcGF0Y2g8UmVkdWNlckFjdGlvbnM+XG4pOiBSb3V0ZXJDaGFuZ2VCeVNlcnZlclJlc3BvbnNlIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrKFxuICAgICh7IHByZXZpb3VzVHJlZSwgc2VydmVyUmVzcG9uc2UgfSkgPT4ge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IEFDVElPTl9TRVJWRVJfUEFUQ0gsXG4gICAgICAgICAgcHJldmlvdXNUcmVlLFxuICAgICAgICAgIHNlcnZlclJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9LFxuICAgIFtkaXNwYXRjaF1cbiAgKVxufVxuXG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZShkaXNwYXRjaDogUmVhY3QuRGlzcGF0Y2g8UmVkdWNlckFjdGlvbnM+KTogUm91dGVyTmF2aWdhdGUge1xuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgKGhyZWYsIG5hdmlnYXRlVHlwZSwgc2hvdWxkU2Nyb2xsKSA9PiB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGFkZEJhc2VQYXRoKGhyZWYpLCBsb2NhdGlvbi5ocmVmKVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORykge1xuICAgICAgICB3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwgPSB1cmxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogQUNUSU9OX05BVklHQVRFLFxuICAgICAgICB1cmwsXG4gICAgICAgIGlzRXh0ZXJuYWxVcmw6IGlzRXh0ZXJuYWxVUkwodXJsKSxcbiAgICAgICAgbG9jYXRpb25TZWFyY2g6IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgc2hvdWxkU2Nyb2xsOiBzaG91bGRTY3JvbGwgPz8gdHJ1ZSxcbiAgICAgICAgbmF2aWdhdGVUeXBlLFxuICAgICAgICBhbGxvd0FsaWFzaW5nOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuICAgIFtkaXNwYXRjaF1cbiAgKVxufVxuXG5mdW5jdGlvbiBjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUoZGF0YTogYW55KSB7XG4gIGlmIChkYXRhID09IG51bGwpIGRhdGEgPSB7fVxuICBjb25zdCBjdXJyZW50U3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICBjb25zdCBfX05BID0gY3VycmVudFN0YXRlPy5fX05BXG4gIGlmIChfX05BKSB7XG4gICAgZGF0YS5fX05BID0gX19OQVxuICB9XG4gIGNvbnN0IF9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUgPVxuICAgIGN1cnJlbnRTdGF0ZT8uX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICBpZiAoX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSkge1xuICAgIGRhdGEuX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSA9IF9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgfVxuXG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIEhlYWQoe1xuICBoZWFkQ2FjaGVOb2RlLFxufToge1xuICBoZWFkQ2FjaGVOb2RlOiBDYWNoZU5vZGUgfCBudWxsXG59KTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgLy8gSWYgdGhpcyBzZWdtZW50IGhhcyBhIGBwcmVmZXRjaEhlYWRgLCBpdCdzIHRoZSBzdGF0aWNhbGx5IHByZWZldGNoZWQgZGF0YS5cbiAgLy8gV2Ugc2hvdWxkIHVzZSB0aGF0IG9uIGluaXRpYWwgcmVuZGVyIGluc3RlYWQgb2YgYGhlYWRgLiBUaGVuIHdlJ2xsIHN3aXRjaFxuICAvLyB0byBgaGVhZGAgd2hlbiB0aGUgZHluYW1pYyByZXNwb25zZSBzdHJlYW1zIGluLlxuICBjb25zdCBoZWFkID0gaGVhZENhY2hlTm9kZSAhPT0gbnVsbCA/IGhlYWRDYWNoZU5vZGUuaGVhZCA6IG51bGxcbiAgY29uc3QgcHJlZmV0Y2hIZWFkID1cbiAgICBoZWFkQ2FjaGVOb2RlICE9PSBudWxsID8gaGVhZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQgOiBudWxsXG5cbiAgLy8gSWYgbm8gcHJlZmV0Y2ggZGF0YSBpcyBhdmFpbGFibGUsIHRoZW4gd2UgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIGBoZWFkYC5cbiAgY29uc3QgcmVzb2x2ZWRQcmVmZXRjaFJzYyA9IHByZWZldGNoSGVhZCAhPT0gbnVsbCA/IHByZWZldGNoSGVhZCA6IGhlYWRcblxuICAvLyBXZSB1c2UgYHVzZURlZmVycmVkVmFsdWVgIHRvIGhhbmRsZSBzd2l0Y2hpbmcgYmV0d2VlbiB0aGUgcHJlZmV0Y2hlZCBhbmRcbiAgLy8gZmluYWwgdmFsdWVzLiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHJldHVybmVkIG9uIGluaXRpYWwgcmVuZGVyLCB0aGVuIGl0XG4gIC8vIHJlLXJlbmRlcnMgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQuXG4gIHJldHVybiB1c2VEZWZlcnJlZFZhbHVlKGhlYWQsIHJlc29sdmVkUHJlZmV0Y2hSc2MpXG59XG5cbi8qKlxuICogVGhlIGdsb2JhbCByb3V0ZXIgdGhhdCB3cmFwcyB0aGUgYXBwbGljYXRpb24gY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gUm91dGVyKHtcbiAgYWN0aW9uUXVldWUsXG4gIGFzc2V0UHJlZml4LFxuICBnbG9iYWxFcnJvcixcbn06IHtcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlXG4gIGFzc2V0UHJlZml4OiBzdHJpbmdcbiAgZ2xvYmFsRXJyb3I6IFtHbG9iYWxFcnJvckNvbXBvbmVudCwgUmVhY3QuUmVhY3ROb2RlXVxufSkge1xuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXIoYWN0aW9uUXVldWUpXG4gIGNvbnN0IHsgY2Fub25pY2FsVXJsIH0gPSB1c2VVbndyYXBTdGF0ZShzdGF0ZSlcbiAgLy8gQWRkIG1lbW9pemVkIHBhdGhuYW1lL3F1ZXJ5IGZvciB1c2VTZWFyY2hQYXJhbXMgYW5kIHVzZVBhdGhuYW1lLlxuICBjb25zdCB7IHNlYXJjaFBhcmFtcywgcGF0aG5hbWUgfSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXG4gICAgICBjYW5vbmljYWxVcmwsXG4gICAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgIClcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGlzIGlzIHR1cm5lZCBpbnRvIGEgcmVhZG9ubHkgY2xhc3MgaW4gYHVzZVNlYXJjaFBhcmFtc2BcbiAgICAgIHNlYXJjaFBhcmFtczogdXJsLnNlYXJjaFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBoYXNCYXNlUGF0aCh1cmwucGF0aG5hbWUpXG4gICAgICAgID8gcmVtb3ZlQmFzZVBhdGgodXJsLnBhdGhuYW1lKVxuICAgICAgICA6IHVybC5wYXRobmFtZSxcbiAgICB9XG4gIH0sIFtjYW5vbmljYWxVcmxdKVxuXG4gIGNvbnN0IGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgPSB1c2VDaGFuZ2VCeVNlcnZlclJlc3BvbnNlKGRpc3BhdGNoKVxuICBjb25zdCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKGRpc3BhdGNoKVxuICB1c2VTZXJ2ZXJBY3Rpb25EaXNwYXRjaGVyKGRpc3BhdGNoKVxuXG4gIC8qKlxuICAgKiBUaGUgYXBwIHJvdXRlciB0aGF0IGlzIGV4cG9zZWQgdGhyb3VnaCBgdXNlUm91dGVyYC4gSXQncyBvbmx5IGNvbmNlcm5lZCB3aXRoIGRpc3BhdGNoaW5nIGFjdGlvbnMgdG8gdGhlIHJlZHVjZXIsIGRvZXMgbm90IGhvbGQgc3RhdGUuXG4gICAqL1xuICBjb25zdCBhcHBSb3V0ZXIgPSB1c2VNZW1vPEFwcFJvdXRlckluc3RhbmNlPigoKSA9PiB7XG4gICAgY29uc3Qgcm91dGVySW5zdGFuY2U6IEFwcFJvdXRlckluc3RhbmNlID0ge1xuICAgICAgYmFjazogKCkgPT4gd2luZG93Lmhpc3RvcnkuYmFjaygpLFxuICAgICAgZm9yd2FyZDogKCkgPT4gd2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpLFxuICAgICAgcHJlZmV0Y2g6IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICAgICAgICA/IC8vIFVubGlrZSB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCB0aGUgU2VnbWVudCBDYWNoZSBkb2Vzbid0IHN0b3JlIGl0c1xuICAgICAgICAgIC8vIGRhdGEgaW4gdGhlIHJvdXRlciByZWR1Y2VyIHN0YXRlOyBpdCB3cml0ZXMgaW50byBhIGdsb2JhbCBtdXRhYmxlXG4gICAgICAgICAgLy8gY2FjaGUuIFNvIHdlIGRvbid0IG5lZWQgdG8gZGlzcGF0Y2ggYW4gYWN0aW9uLlxuICAgICAgICAgIChocmVmLCBvcHRpb25zKSA9PlxuICAgICAgICAgICAgcHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlKFxuICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICBhY3Rpb25RdWV1ZS5zdGF0ZS5uZXh0VXJsLFxuICAgICAgICAgICAgICBhY3Rpb25RdWV1ZS5zdGF0ZS50cmVlLFxuICAgICAgICAgICAgICBvcHRpb25zPy5raW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTFxuICAgICAgICAgICAgKVxuICAgICAgICA6IChocmVmLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIG9sZCBwcmVmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGNyZWF0ZVByZWZldGNoVVJMKGhyZWYpXG4gICAgICAgICAgICBpZiAodXJsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBwcmVmZXRjaCByZWR1Y2VyIGRvZXNuJ3QgYWN0dWFsbHkgdXBkYXRlIGFueSBzdGF0ZSBvclxuICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGEgcmVyZW5kZXIuIEl0IGp1c3Qgd3JpdGVzIHRvIGEgbXV0YWJsZSBjYWNoZS4gU28gd2VcbiAgICAgICAgICAgICAgLy8gc2hvdWxkbid0IGJvdGhlciBjYWxsaW5nIHNldFN0YXRlL2Rpc3BhdGNoOyB3ZSBjYW4ganVzdCByZS1ydW5cbiAgICAgICAgICAgICAgLy8gdGhlIHJlZHVjZXIgZGlyZWN0bHkgdXNpbmcgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICAgICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgYXdheSBmcm9tIGEgXCJyZWR1Y2VyXCIgc28gaXQnc1xuICAgICAgICAgICAgICAvLyBsZXNzIGNvbmZ1c2luZy5cbiAgICAgICAgICAgICAgcHJlZmV0Y2hSZWR1Y2VyKGFjdGlvblF1ZXVlLnN0YXRlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogQUNUSU9OX1BSRUZFVENILFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBraW5kOiBvcHRpb25zPy5raW5kID8/IFByZWZldGNoS2luZC5GVUxMLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICByZXBsYWNlOiAoaHJlZiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgbmF2aWdhdGUoaHJlZiwgJ3JlcGxhY2UnLCBvcHRpb25zLnNjcm9sbCA/PyB0cnVlKVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHB1c2g6IChocmVmLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBuYXZpZ2F0ZShocmVmLCAncHVzaCcsIG9wdGlvbnMuc2Nyb2xsID8/IHRydWUpXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmVmcmVzaDogKCkgPT4ge1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IEFDVElPTl9SRUZSRVNILFxuICAgICAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgaG1yUmVmcmVzaDogKCkgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnaG1yUmVmcmVzaCBjYW4gb25seSBiZSB1c2VkIGluIGRldmVsb3BtZW50IG1vZGUuIFBsZWFzZSB1c2UgcmVmcmVzaCBpbnN0ZWFkLidcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgdHlwZTogQUNUSU9OX0hNUl9SRUZSRVNILFxuICAgICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdXRlckluc3RhbmNlXG4gIH0sIFthY3Rpb25RdWV1ZSwgZGlzcGF0Y2gsIG5hdmlnYXRlXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEV4aXN0cyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLiBEb24ndCB1c2UgaW4gYXBwbGljYXRpb24gY29kZS5cbiAgICBpZiAod2luZG93Lm5leHQpIHtcbiAgICAgIHdpbmRvdy5uZXh0LnJvdXRlciA9IGFwcFJvdXRlclxuICAgIH1cbiAgfSwgW2FwcFJvdXRlcl0pXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCB7IGNhY2hlLCBwcmVmZXRjaENhY2hlLCB0cmVlIH0gPSB1c2VVbndyYXBTdGF0ZShzdGF0ZSlcblxuICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIEFkZCBgd2luZG93Lm5kYCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgICAgLy8gVGhpcyBpcyBub3QgbWVhbnQgZm9yIHVzZSBpbiBhcHBsaWNhdGlvbnMgYXMgY29uY3VycmVudCByZW5kZXJpbmcgd2lsbCBhZmZlY3QgdGhlIGNhY2hlL3RyZWUvcm91dGVyLlxuICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIGZvciBkZWJ1Z2dpbmdcbiAgICAgIHdpbmRvdy5uZCA9IHtcbiAgICAgICAgcm91dGVyOiBhcHBSb3V0ZXIsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBwcmVmZXRjaENhY2hlLFxuICAgICAgICB0cmVlLFxuICAgICAgfVxuICAgIH0sIFthcHBSb3V0ZXIsIGNhY2hlLCBwcmVmZXRjaENhY2hlLCB0cmVlXSlcbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSWYgdGhlIGFwcCBpcyByZXN0b3JlZCBmcm9tIGJmY2FjaGUsIGl0J3MgcG9zc2libGUgdGhhdFxuICAgIC8vIHB1c2hSZWYubXBhTmF2aWdhdGlvbiBpcyB0cnVlLCB3aGljaCB3b3VsZCBtZWFuIHRoYXQgYW55IHJlLXJlbmRlciBvZiB0aGlzIGNvbXBvbmVudFxuICAgIC8vIHdvdWxkIHRyaWdnZXIgdGhlIG1wYSBuYXZpZ2F0aW9uIGxvZ2ljIGFnYWluIGZyb20gdGhlIGxpbmVzIGJlbG93LlxuICAgIC8vIFRoaXMgd2lsbCByZXN0b3JlIHRoZSByb3V0ZXIgdG8gdGhlIGluaXRpYWwgc3RhdGUgaW4gdGhlIGV2ZW50IHRoYXQgdGhlIGFwcCBpcyByZXN0b3JlZCBmcm9tIGJmY2FjaGUuXG4gICAgZnVuY3Rpb24gaGFuZGxlUGFnZVNob3coZXZlbnQ6IFBhZ2VUcmFuc2l0aW9uRXZlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWV2ZW50LnBlcnNpc3RlZCB8fFxuICAgICAgICAhd2luZG93Lmhpc3Rvcnkuc3RhdGU/Ll9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgdGhlIHBlbmRpbmdNcGFQYXRoIHZhbHVlIHNvIHRoYXQgYSBzdWJzZXF1ZW50IE1QQSBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lIFVSTCBjYW4gYmUgdHJpZ2dlcmVkLlxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBpZiB0aGUgYnJvd3NlciByZXN0b3JlZCBmcm9tIGJmY2FjaGUsIHRoZSBwZW5kaW5nTXBhUGF0aCB3b3VsZCBzdGlsbCBiZSBzZXQgdG8gdGhlIHZhbHVlXG4gICAgICAvLyBvZiB0aGUgbGFzdCBNUEEgbmF2aWdhdGlvbi5cbiAgICAgIGdsb2JhbE11dGFibGUucGVuZGluZ01wYVBhdGggPSB1bmRlZmluZWRcblxuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBBQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgdXJsOiBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSxcbiAgICAgICAgdHJlZTogd2luZG93Lmhpc3Rvcnkuc3RhdGUuX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VzaG93JywgaGFuZGxlUGFnZVNob3cpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VzaG93JywgaGFuZGxlUGFnZVNob3cpXG4gICAgfVxuICB9LCBbZGlzcGF0Y2hdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRW5zdXJlIHRoYXQgYW55IHJlZGlyZWN0IGVycm9ycyB0aGF0IGJ1YmJsZSB1cCBvdXRzaWRlIG9mIHRoZSBSZWRpcmVjdEJvdW5kYXJ5XG4gICAgLy8gYXJlIGNhdWdodCBhbmQgaGFuZGxlZCBieSB0aGUgcm91dGVyLlxuICAgIGZ1bmN0aW9uIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KFxuICAgICAgZXZlbnQ6IEVycm9yRXZlbnQgfCBQcm9taXNlUmVqZWN0aW9uRXZlbnRcbiAgICApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gJ3JlYXNvbicgaW4gZXZlbnQgPyBldmVudC5yZWFzb24gOiBldmVudC5lcnJvclxuICAgICAgaWYgKGlzUmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCB1cmwgPSBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvcihlcnJvcilcbiAgICAgICAgY29uc3QgcmVkaXJlY3RUeXBlID0gZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yKGVycm9yKVxuICAgICAgICBpZiAocmVkaXJlY3RUeXBlID09PSBSZWRpcmVjdFR5cGUucHVzaCkge1xuICAgICAgICAgIGFwcFJvdXRlci5wdXNoKHVybCwge30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwUm91dGVyLnJlcGxhY2UodXJsLCB7fSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG4gICAgfVxuICB9LCBbYXBwUm91dGVyXSlcblxuICAvLyBXaGVuIG1wYU5hdmlnYXRpb24gZmxhZyBpcyBzZXQgZG8gYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIG5ldyB1cmwuXG4gIC8vIEluZmluaXRlbHkgc3VzcGVuZCBiZWNhdXNlIHdlIGRvbid0IGFjdHVhbGx5IHdhbnQgdG8gcmVyZW5kZXIgYW55IGNoaWxkXG4gIC8vIGNvbXBvbmVudHMgd2l0aCB0aGUgbmV3IFVSTCBhbmQgYW55IGVudGFuZ2xlZCBzdGF0ZSB1cGRhdGVzIHNob3VsZG4ndFxuICAvLyBjb21taXQgZWl0aGVyIChlZzogdXNlVHJhbnNpdGlvbiBpc1BlbmRpbmcgc2hvdWxkIHN0YXkgdHJ1ZSB1bnRpbCB0aGUgcGFnZVxuICAvLyB1bmxvYWRzKS5cbiAgLy9cbiAgLy8gVGhpcyBpcyBhIHNpZGUgZWZmZWN0IGluIHJlbmRlci4gRG9uJ3QgdHJ5IHRoaXMgYXQgaG9tZSwga2lkcy4gSXQnc1xuICAvLyBwcm9iYWJseSBzYWZlIGJlY2F1c2Ugd2Uga25vdyB0aGlzIGlzIGEgc2luZ2xldG9uIGNvbXBvbmVudCBhbmQgaXQncyBuZXZlclxuICAvLyBpbiA8T2Zmc2NyZWVuPi4gQXQgbGVhc3QgSSBob3BlIHNvLiAoSXQgd2lsbCBydW4gdHdpY2UgaW4gZGV2IHN0cmljdCBtb2RlLFxuICAvLyBidXQgdGhhdCdzLi4uIGZpbmU/KVxuICBjb25zdCB7IHB1c2hSZWYgfSA9IHVzZVVud3JhcFN0YXRlKHN0YXRlKVxuICBpZiAocHVzaFJlZi5tcGFOYXZpZ2F0aW9uKSB7XG4gICAgLy8gaWYgdGhlcmUncyBhIHJlLXJlbmRlciwgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGFub3RoZXIgcmVkaXJlY3QgaWYgb25lIGlzIGFscmVhZHkgaW4gZmxpZ2h0IHRvIHRoZSBzYW1lIFVSTFxuICAgIGlmIChnbG9iYWxNdXRhYmxlLnBlbmRpbmdNcGFQYXRoICE9PSBjYW5vbmljYWxVcmwpIHtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uXG4gICAgICBpZiAocHVzaFJlZi5wZW5kaW5nUHVzaCkge1xuICAgICAgICBsb2NhdGlvbi5hc3NpZ24oY2Fub25pY2FsVXJsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShjYW5vbmljYWxVcmwpXG4gICAgICB9XG5cbiAgICAgIGdsb2JhbE11dGFibGUucGVuZGluZ01wYVBhdGggPSBjYW5vbmljYWxVcmxcbiAgICB9XG4gICAgLy8gVE9ETy1BUFA6IFNob3VsZCB3ZSBsaXN0ZW4gdG8gbmF2aWdhdGVlcnJvciBoZXJlIHRvIGNhdGNoIGZhaWxlZFxuICAgIC8vIG5hdmlnYXRpb25zIHNvbWVob3c/IEFuZCBzaG91bGQgd2UgY2FsbCB3aW5kb3cuc3RvcCgpIGlmIGEgU1BBIG5hdmlnYXRpb25cbiAgICAvLyBzaG91bGQgaW50ZXJydXB0IGFuIE1QQSBvbmU/XG4gICAgdXNlKHVucmVzb2x2ZWRUaGVuYWJsZSlcbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxQdXNoU3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUuYmluZCh3aW5kb3cuaGlzdG9yeSlcbiAgICBjb25zdCBvcmlnaW5hbFJlcGxhY2VTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZS5iaW5kKFxuICAgICAgd2luZG93Lmhpc3RvcnlcbiAgICApXG5cbiAgICAvLyBFbnN1cmUgdGhlIGNhbm9uaWNhbCBVUkwgaW4gdGhlIE5leHQuanMgUm91dGVyIGlzIHVwZGF0ZWQgd2hlbiB0aGUgVVJMIGlzIGNoYW5nZWQgc28gdGhhdCBgdXNlUGF0aG5hbWVgIGFuZCBgdXNlU2VhcmNoUGFyYW1zYCBob2xkIHRoZSBwdXNoZWQgdmFsdWVzLlxuICAgIGNvbnN0IGFwcGx5VXJsRnJvbUhpc3RvcnlQdXNoUmVwbGFjZSA9IChcbiAgICAgIHVybDogc3RyaW5nIHwgVVJMIHwgbnVsbCB8IHVuZGVmaW5lZFxuICAgICkgPT4ge1xuICAgICAgY29uc3QgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgICBjb25zdCB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHVuZGVmaW5lZCA9XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnN0YXRlPy5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG5cbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBBQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgICB1cmw6IG5ldyBVUkwodXJsID8/IGhyZWYsIGhyZWYpLFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGNoIHB1c2hTdGF0ZSB0byBlbnN1cmUgZXh0ZXJuYWwgY2hhbmdlcyB0byB0aGUgaGlzdG9yeSBhcmUgcmVmbGVjdGVkIGluIHRoZSBOZXh0LmpzIFJvdXRlci5cbiAgICAgKiBFbnN1cmVzIE5leHQuanMgaW50ZXJuYWwgaGlzdG9yeSBzdGF0ZSBpcyBjb3BpZWQgdG8gdGhlIG5ldyBoaXN0b3J5IGVudHJ5LlxuICAgICAqIEVuc3VyZXMgdXNlUGF0aG5hbWUgYW5kIHVzZVNlYXJjaFBhcmFtcyBob2xkIHRoZSBuZXdseSBwcm92aWRlZCB1cmwuXG4gICAgICovXG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID0gZnVuY3Rpb24gcHVzaFN0YXRlKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgX3VudXNlZDogc3RyaW5nLFxuICAgICAgdXJsPzogc3RyaW5nIHwgVVJMIHwgbnVsbFxuICAgICk6IHZvaWQge1xuICAgICAgLy8gQXZvaWQgYSBsb29wIHdoZW4gTmV4dC5qcyBpbnRlcm5hbHMgdHJpZ2dlciBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlXG4gICAgICBpZiAoZGF0YT8uX19OQSB8fCBkYXRhPy5fTikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxQdXNoU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgICAgfVxuXG4gICAgICBkYXRhID0gY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlKGRhdGEpXG5cbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlKHVybClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yaWdpbmFsUHVzaFN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRjaCByZXBsYWNlU3RhdGUgdG8gZW5zdXJlIGV4dGVybmFsIGNoYW5nZXMgdG8gdGhlIGhpc3RvcnkgYXJlIHJlZmxlY3RlZCBpbiB0aGUgTmV4dC5qcyBSb3V0ZXIuXG4gICAgICogRW5zdXJlcyBOZXh0LmpzIGludGVybmFsIGhpc3Rvcnkgc3RhdGUgaXMgY29waWVkIHRvIHRoZSBuZXcgaGlzdG9yeSBlbnRyeS5cbiAgICAgKiBFbnN1cmVzIHVzZVBhdGhuYW1lIGFuZCB1c2VTZWFyY2hQYXJhbXMgaG9sZCB0aGUgbmV3bHkgcHJvdmlkZWQgdXJsLlxuICAgICAqL1xuICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShcbiAgICAgIGRhdGE6IGFueSxcbiAgICAgIF91bnVzZWQ6IHN0cmluZyxcbiAgICAgIHVybD86IHN0cmluZyB8IFVSTCB8IG51bGxcbiAgICApOiB2b2lkIHtcbiAgICAgIC8vIEF2b2lkIGEgbG9vcCB3aGVuIE5leHQuanMgaW50ZXJuYWxzIHRyaWdnZXIgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZVxuICAgICAgaWYgKGRhdGE/Ll9fTkEgfHwgZGF0YT8uX04pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVwbGFjZVN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUoZGF0YSlcblxuICAgICAgaWYgKHVybCkge1xuICAgICAgICBhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UodXJsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsUmVwbGFjZVN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcG9wc3RhdGUgZXZlbnQsIHRoaXMgaXMgdXNlZCB0byBoYW5kbGUgYmFjay9mb3J3YXJkIGluIHRoZSBicm93c2VyLlxuICAgICAqIEJ5IGRlZmF1bHQgZGlzcGF0Y2hlcyBBQ1RJT05fUkVTVE9SRSwgaG93ZXZlciBpZiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgbm90IHB1c2hlZC9yZXBsYWNlZCBieSBhcHAtcm91dGVyIGl0IHdpbGwgcmVsb2FkIHRoZSBwYWdlLlxuICAgICAqIFRoYXQgY2FzZSBjYW4gaGFwcGVuIHdoZW4gdGhlIG9sZCByb3V0ZXIgaW5qZWN0ZWQgdGhlIGhpc3RvcnkgZW50cnkuXG4gICAgICovXG4gICAgY29uc3Qgb25Qb3BTdGF0ZSA9IChldmVudDogUG9wU3RhdGVFdmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC5zdGF0ZSkge1xuICAgICAgICAvLyBUT0RPLUFQUDogdGhpcyBjYXNlIG9ubHkgaGFwcGVucyB3aGVuIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUgd2FzIGNhbGxlZCBvdXRzaWRlIG9mIE5leHQuanMuIEl0IHNob3VsZCBwcm9iYWJseSByZWxvYWQgdGhlIHBhZ2UgaW4gdGhpcyBjYXNlLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgcHVzaGVkIGJ5IHRoZSBgcGFnZXNgIHJvdXRlci5cbiAgICAgIGlmICghZXZlbnQuc3RhdGUuX19OQSkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8tQVBQOiBJZGVhbGx5IHRoZSBiYWNrIGJ1dHRvbiBzaG91bGQgbm90IHVzZSBzdGFydFRyYW5zaXRpb24gYXMgaXQgc2hvdWxkIGFwcGx5IHRoZSB1cGRhdGVzIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIFdpdGhvdXQgc3RhcnRUcmFuc2l0aW9uIHdvcmtzIGlmIHRoZSBjYWNoZSBpcyB0aGVyZSBmb3IgdGhpcyBwYXRoXG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogQUNUSU9OX1JFU1RPUkUsXG4gICAgICAgICAgdXJsOiBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSxcbiAgICAgICAgICB0cmVlOiBldmVudC5zdGF0ZS5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBwb3BzdGF0ZSBldmVudCB0byBjYWxsIG9uUG9wc3RhdGUuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID0gb3JpZ2luYWxQdXNoU3RhdGVcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IG9yaWdpbmFsUmVwbGFjZVN0YXRlXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKVxuICAgIH1cbiAgfSwgW2Rpc3BhdGNoXSlcblxuICBjb25zdCB7IGNhY2hlLCB0cmVlLCBuZXh0VXJsLCBmb2N1c0FuZFNjcm9sbFJlZiB9ID0gdXNlVW53cmFwU3RhdGUoc3RhdGUpXG5cbiAgY29uc3QgbWF0Y2hpbmdIZWFkID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgdHJlZVsxXSlcbiAgfSwgW2NhY2hlLCB0cmVlXSlcblxuICAvLyBBZGQgbWVtb2l6ZWQgcGF0aFBhcmFtcyBmb3IgdXNlUGFyYW1zLlxuICBjb25zdCBwYXRoUGFyYW1zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGdldFNlbGVjdGVkUGFyYW1zKHRyZWUpXG4gIH0sIFt0cmVlXSlcblxuICBjb25zdCBsYXlvdXRSb3V0ZXJDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudFRyZWU6IHRyZWUsXG4gICAgICBwYXJlbnRDYWNoZU5vZGU6IGNhY2hlLFxuICAgICAgcGFyZW50U2VnbWVudFBhdGg6IG51bGwsXG4gICAgICAvLyBSb290IG5vZGUgYWx3YXlzIGhhcyBgdXJsYFxuICAgICAgLy8gUHJvdmlkZWQgaW4gQXBwVHJlZUNvbnRleHQgdG8gZW5zdXJlIGl0IGNhbiBiZSBvdmVyd3JpdHRlbiBpbiBsYXlvdXQtcm91dGVyXG4gICAgICB1cmw6IGNhbm9uaWNhbFVybCxcbiAgICB9XG4gIH0sIFt0cmVlLCBjYWNoZSwgY2Fub25pY2FsVXJsXSlcblxuICBjb25zdCBnbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UsXG4gICAgICB0cmVlLFxuICAgICAgZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgICBuZXh0VXJsLFxuICAgIH1cbiAgfSwgW2NoYW5nZUJ5U2VydmVyUmVzcG9uc2UsIHRyZWUsIGZvY3VzQW5kU2Nyb2xsUmVmLCBuZXh0VXJsXSlcblxuICBsZXQgaGVhZFxuICBpZiAobWF0Y2hpbmdIZWFkICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIGhlYWQgaXMgd3JhcHBlZCBpbiBhbiBleHRyYSBjb21wb25lbnQgc28gd2UgY2FuIHVzZVxuICAgIC8vIGB1c2VEZWZlcnJlZFZhbHVlYCB0byBzd2FwIGJldHdlZW4gdGhlIHByZWZldGNoZWQgYW5kIGZpbmFsIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIGhlYWQuIChUaGlzIGlzIHdoYXQgTGF5b3V0Um91dGVyIGRvZXMgZm9yIHNlZ21lbnQgZGF0YSwgdG9vLilcbiAgICAvL1xuICAgIC8vIFRoZSBga2V5YCBpcyB1c2VkIHRvIHJlbW91bnQgdGhlIGNvbXBvbmVudCB3aGVuZXZlciB0aGUgaGVhZCBtb3ZlcyB0b1xuICAgIC8vIGEgZGlmZmVyZW50IHNlZ21lbnQuXG4gICAgY29uc3QgW2hlYWRDYWNoZU5vZGUsIGhlYWRLZXldID0gbWF0Y2hpbmdIZWFkXG4gICAgaGVhZCA9IDxIZWFkIGtleT17aGVhZEtleX0gaGVhZENhY2hlTm9kZT17aGVhZENhY2hlTm9kZX0gLz5cbiAgfSBlbHNlIHtcbiAgICBoZWFkID0gbnVsbFxuICB9XG5cbiAgbGV0IGNvbnRlbnQgPSAoXG4gICAgPFJlZGlyZWN0Qm91bmRhcnk+XG4gICAgICB7aGVhZH1cbiAgICAgIHtjYWNoZS5yc2N9XG4gICAgICA8QXBwUm91dGVyQW5ub3VuY2VyIHRyZWU9e3RyZWV9IC8+XG4gICAgPC9SZWRpcmVjdEJvdW5kYXJ5PlxuICApXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgd2UgYXBwbHkgZmV3IGVycm9yIGJvdW5kYXJpZXMgYW5kIGhvdC1yZWxvYWRlcjpcbiAgICAvLyAtIERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeTogYXZvaWQgdXNpbmcgbmF2aWdhdGlvbiBBUEkgbGlrZSBub3RGb3VuZCgpIGluIHJvb3QgbGF5b3V0XG4gICAgLy8gLSBIb3RSZWxvYWRlcjpcbiAgICAvLyAgLSBob3QtcmVsb2FkIHRoZSBhcHAgd2hlbiB0aGUgY29kZSBjaGFuZ2VzXG4gICAgLy8gIC0gcmVuZGVyIGRldiBvdmVybGF5XG4gICAgLy8gIC0gY2F0Y2ggcnVudGltZSBlcnJvcnMgYW5kIGRpc3BsYXkgZ2xvYmFsLWVycm9yIHdoZW4gbmVjZXNzYXJ5XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7IERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSB9ID1cbiAgICAgICAgcmVxdWlyZSgnLi9kZXYtcm9vdC1odHRwLWFjY2Vzcy1mYWxsYmFjay1ib3VuZGFyeScpIGFzIHR5cGVvZiBpbXBvcnQoJy4vZGV2LXJvb3QtaHR0cC1hY2Nlc3MtZmFsbGJhY2stYm91bmRhcnknKVxuICAgICAgY29udGVudCA9IChcbiAgICAgICAgPERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeT5cbiAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgPC9EZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnk+XG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IEhvdFJlbG9hZGVyOiB0eXBlb2YgaW1wb3J0KCcuL3JlYWN0LWRldi1vdmVybGF5L2FwcC9ob3QtcmVsb2FkZXItY2xpZW50JykuZGVmYXVsdCA9XG4gICAgICByZXF1aXJlKCcuL3JlYWN0LWRldi1vdmVybGF5L2FwcC9ob3QtcmVsb2FkZXItY2xpZW50JykuZGVmYXVsdFxuXG4gICAgY29udGVudCA9IChcbiAgICAgIDxIb3RSZWxvYWRlciBhc3NldFByZWZpeD17YXNzZXRQcmVmaXh9IGdsb2JhbEVycm9yPXtnbG9iYWxFcnJvcn0+XG4gICAgICAgIHtjb250ZW50fVxuICAgICAgPC9Ib3RSZWxvYWRlcj5cbiAgICApXG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgd2Ugb25seSBhcHBseSB0aGUgdXNlci1jdXN0b21pemVkIGdsb2JhbCBlcnJvciBib3VuZGFyeS5cbiAgICBjb250ZW50ID0gKFxuICAgICAgPEVycm9yQm91bmRhcnlcbiAgICAgICAgZXJyb3JDb21wb25lbnQ9e2dsb2JhbEVycm9yWzBdfVxuICAgICAgICBlcnJvclN0eWxlcz17Z2xvYmFsRXJyb3JbMV19XG4gICAgICA+XG4gICAgICAgIHtjb250ZW50fVxuICAgICAgPC9FcnJvckJvdW5kYXJ5PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxIaXN0b3J5VXBkYXRlciBhcHBSb3V0ZXJTdGF0ZT17dXNlVW53cmFwU3RhdGUoc3RhdGUpfSAvPlxuICAgICAgPFJ1bnRpbWVTdHlsZXMgLz5cbiAgICAgIDxQYXRoUGFyYW1zQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cGF0aFBhcmFtc30+XG4gICAgICAgIDxQYXRobmFtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3BhdGhuYW1lfT5cbiAgICAgICAgICA8U2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c2VhcmNoUGFyYW1zfT5cbiAgICAgICAgICAgIDxHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgICAgIHZhbHVlPXtnbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8QXBwUm91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17YXBwUm91dGVyfT5cbiAgICAgICAgICAgICAgICA8TGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bGF5b3V0Um91dGVyQ29udGV4dH0+XG4gICAgICAgICAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgICAgICAgICA8L0xheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICAgIDwvQXBwUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgIDwvR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICA8L1NlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgIDwvUGF0aG5hbWVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9QYXRoUGFyYW1zQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8Lz5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHBSb3V0ZXIoe1xuICBhY3Rpb25RdWV1ZSxcbiAgZ2xvYmFsRXJyb3JDb21wb25lbnRBbmRTdHlsZXM6IFtnbG9iYWxFcnJvckNvbXBvbmVudCwgZ2xvYmFsRXJyb3JTdHlsZXNdLFxuICBhc3NldFByZWZpeCxcbn06IHtcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlXG4gIGdsb2JhbEVycm9yQ29tcG9uZW50QW5kU3R5bGVzOiBbR2xvYmFsRXJyb3JDb21wb25lbnQsIFJlYWN0LlJlYWN0Tm9kZV1cbiAgYXNzZXRQcmVmaXg6IHN0cmluZ1xufSkge1xuICB1c2VOYXZGYWlsdXJlSGFuZGxlcigpXG5cbiAgcmV0dXJuIChcbiAgICA8RXJyb3JCb3VuZGFyeVxuICAgICAgLy8gQXQgdGhlIHZlcnkgdG9wIGxldmVsLCB1c2UgdGhlIGRlZmF1bHQgR2xvYmFsRXJyb3IgY29tcG9uZW50IGFzIHRoZSBmaW5hbCBmYWxsYmFjay5cbiAgICAgIC8vIFdoZW4gdGhlIGFwcCByb3V0ZXIgaXRzZWxmIGZhaWxzLCB3aGljaCBtZWFucyB0aGUgZnJhbWV3b3JrIGl0c2VsZiBmYWlscywgd2Ugc2hvdyB0aGUgZGVmYXVsdCBlcnJvci5cbiAgICAgIGVycm9yQ29tcG9uZW50PXtEZWZhdWx0R2xvYmFsRXJyb3J9XG4gICAgPlxuICAgICAgPFJvdXRlclxuICAgICAgICBhY3Rpb25RdWV1ZT17YWN0aW9uUXVldWV9XG4gICAgICAgIGFzc2V0UHJlZml4PXthc3NldFByZWZpeH1cbiAgICAgICAgZ2xvYmFsRXJyb3I9e1tnbG9iYWxFcnJvckNvbXBvbmVudCwgZ2xvYmFsRXJyb3JTdHlsZXNdfVxuICAgICAgLz5cbiAgICA8L0Vycm9yQm91bmRhcnk+XG4gIClcbn1cblxuY29uc3QgcnVudGltZVN0eWxlcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG5sZXQgcnVudGltZVN0eWxlQ2hhbmdlZCA9IG5ldyBTZXQ8KCkgPT4gdm9pZD4oKVxuXG5nbG9iYWxUaGlzLl9OX0VfU1RZTEVfTE9BRCA9IGZ1bmN0aW9uIChocmVmOiBzdHJpbmcpIHtcbiAgbGV0IGxlbiA9IHJ1bnRpbWVTdHlsZXMuc2l6ZVxuICBydW50aW1lU3R5bGVzLmFkZChocmVmKVxuICBpZiAocnVudGltZVN0eWxlcy5zaXplICE9PSBsZW4pIHtcbiAgICBydW50aW1lU3R5bGVDaGFuZ2VkLmZvckVhY2goKGNiKSA9PiBjYigpKVxuICB9XG4gIC8vIFRPRE8gZmlndXJlIG91dCBob3cgdG8gZ2V0IGEgcHJvbWlzZSBoZXJlXG4gIC8vIEJ1dCBtYXliZSBpdCdzIG5vdCBuZWNlc3NhcnkgYXMgcmVhY3Qgd291bGQgYmxvY2sgcmVuZGVyaW5nIHVudGlsIGl0J3MgbG9hZGVkXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxufVxuXG5mdW5jdGlvbiBSdW50aW1lU3R5bGVzKCkge1xuICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgwKVxuICBjb25zdCByZW5kZXJlZFN0eWxlc1NpemUgPSBydW50aW1lU3R5bGVzLnNpemVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjaGFuZ2VkID0gKCkgPT4gZm9yY2VVcGRhdGUoKGMpID0+IGMgKyAxKVxuICAgIHJ1bnRpbWVTdHlsZUNoYW5nZWQuYWRkKGNoYW5nZWQpXG4gICAgaWYgKHJlbmRlcmVkU3R5bGVzU2l6ZSAhPT0gcnVudGltZVN0eWxlcy5zaXplKSB7XG4gICAgICBjaGFuZ2VkKClcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJ1bnRpbWVTdHlsZUNoYW5nZWQuZGVsZXRlKGNoYW5nZWQpXG4gICAgfVxuICB9LCBbcmVuZGVyZWRTdHlsZXNTaXplLCBmb3JjZVVwZGF0ZV0pXG5cbiAgY29uc3QgZHBsSWQgPSBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSURcbiAgICA/IGA/ZHBsPSR7cHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEfWBcbiAgICA6ICcnXG4gIHJldHVybiBbLi4ucnVudGltZVN0eWxlc10ubWFwKChocmVmLCBpKSA9PiAoXG4gICAgPGxpbmtcbiAgICAgIGtleT17aX1cbiAgICAgIHJlbD1cInN0eWxlc2hlZXRcIlxuICAgICAgaHJlZj17YCR7aHJlZn0ke2RwbElkfWB9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBwcmVjZWRlbmNlPVwibmV4dFwiXG4gICAgICAvLyBUT0RPIGZpZ3VyZSBvdXQgY3Jvc3NPcmlnaW4gYW5kIG5vbmNlXG4gICAgICAvLyBjcm9zc09yaWdpbj17VE9ET31cbiAgICAgIC8vIG5vbmNlPXtUT0RPfVxuICAgIC8+XG4gICkpXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJjcmVhdGVQcmVmZXRjaFVSTCIsIkFwcFJvdXRlciIsImdsb2JhbE11dGFibGUiLCJpc0V4dGVybmFsVVJMIiwidXJsIiwib3JpZ2luIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJVUkwiLCJhZGRCYXNlUGF0aCIsIl8iLCJFcnJvciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIkhpc3RvcnlVcGRhdGVyIiwiYXBwUm91dGVyU3RhdGUiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJfX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HIiwibmV4dCIsIl9fcGVuZGluZ1VybCIsInVuZGVmaW5lZCIsInRyZWUiLCJwdXNoUmVmIiwiY2Fub25pY2FsVXJsIiwiaGlzdG9yeVN0YXRlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJoaXN0b3J5Iiwic3RhdGUiLCJfX05BIiwiX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSIsInBlbmRpbmdQdXNoIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwdXNoU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJwaW5nVmlzaWJsZUxpbmtzIiwibmV4dFVybCIsImxhenlEYXRhIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJoZWFkIiwicHJlZmV0Y2hIZWFkIiwicGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJsb2FkaW5nIiwidXNlQ2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSIsImRpc3BhdGNoIiwidXNlQ2FsbGJhY2siLCJwcmV2aW91c1RyZWUiLCJzZXJ2ZXJSZXNwb25zZSIsInN0YXJ0VHJhbnNpdGlvbiIsInR5cGUiLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwidXNlTmF2aWdhdGUiLCJuYXZpZ2F0ZVR5cGUiLCJzaG91bGRTY3JvbGwiLCJBQ1RJT05fTkFWSUdBVEUiLCJpc0V4dGVybmFsVXJsIiwibG9jYXRpb25TZWFyY2giLCJzZWFyY2giLCJhbGxvd0FsaWFzaW5nIiwiY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlIiwiZGF0YSIsImN1cnJlbnRTdGF0ZSIsIkhlYWQiLCJoZWFkQ2FjaGVOb2RlIiwicmVzb2x2ZWRQcmVmZXRjaFJzYyIsInVzZURlZmVycmVkVmFsdWUiLCJSb3V0ZXIiLCJhY3Rpb25RdWV1ZSIsImFzc2V0UHJlZml4IiwiZ2xvYmFsRXJyb3IiLCJ1c2VSZWR1Y2VyIiwidXNlVW53cmFwU3RhdGUiLCJzZWFyY2hQYXJhbXMiLCJwYXRobmFtZSIsInVzZU1lbW8iLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSIsIm5hdmlnYXRlIiwidXNlU2VydmVyQWN0aW9uRGlzcGF0Y2hlciIsImFwcFJvdXRlciIsInJvdXRlckluc3RhbmNlIiwiYmFjayIsImZvcndhcmQiLCJwcmVmZXRjaCIsIm9wdGlvbnMiLCJwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUiLCJraW5kIiwiUHJlZmV0Y2hLaW5kIiwiRlVMTCIsInByZWZldGNoUmVkdWNlciIsIkFDVElPTl9QUkVGRVRDSCIsInJlcGxhY2UiLCJzY3JvbGwiLCJwdXNoIiwicmVmcmVzaCIsIkFDVElPTl9SRUZSRVNIIiwiaG1yUmVmcmVzaCIsIkFDVElPTl9ITVJfUkVGUkVTSCIsInJvdXRlciIsImNhY2hlIiwicHJlZmV0Y2hDYWNoZSIsIm5kIiwiaGFuZGxlUGFnZVNob3ciLCJldmVudCIsInBlcnNpc3RlZCIsInBlbmRpbmdNcGFQYXRoIiwiQUNUSU9OX1JFU1RPUkUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0IiwiZXJyb3IiLCJyZWFzb24iLCJpc1JlZGlyZWN0RXJyb3IiLCJwcmV2ZW50RGVmYXVsdCIsImdldFVSTEZyb21SZWRpcmVjdEVycm9yIiwicmVkaXJlY3RUeXBlIiwiZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yIiwiUmVkaXJlY3RUeXBlIiwibXBhTmF2aWdhdGlvbiIsImFzc2lnbiIsInVzZSIsInVucmVzb2x2ZWRUaGVuYWJsZSIsIm9yaWdpbmFsUHVzaFN0YXRlIiwiYmluZCIsIm9yaWdpbmFsUmVwbGFjZVN0YXRlIiwiYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlIiwiX3VudXNlZCIsIl9OIiwib25Qb3BTdGF0ZSIsInJlbG9hZCIsImZvY3VzQW5kU2Nyb2xsUmVmIiwibWF0Y2hpbmdIZWFkIiwiZmluZEhlYWRJbkNhY2hlIiwicGF0aFBhcmFtcyIsImdldFNlbGVjdGVkUGFyYW1zIiwibGF5b3V0Um91dGVyQ29udGV4dCIsInBhcmVudFRyZWUiLCJwYXJlbnRDYWNoZU5vZGUiLCJwYXJlbnRTZWdtZW50UGF0aCIsImdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJoZWFkS2V5IiwiY29udGVudCIsIlJlZGlyZWN0Qm91bmRhcnkiLCJBcHBSb3V0ZXJBbm5vdW5jZXIiLCJEZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkiLCJyZXF1aXJlIiwiSG90UmVsb2FkZXIiLCJkZWZhdWx0IiwiRXJyb3JCb3VuZGFyeSIsImVycm9yQ29tcG9uZW50IiwiZXJyb3JTdHlsZXMiLCJSdW50aW1lU3R5bGVzIiwiUGF0aFBhcmFtc0NvbnRleHQiLCJQcm92aWRlciIsInZhbHVlIiwiUGF0aG5hbWVDb250ZXh0IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsImdsb2JhbEVycm9yQ29tcG9uZW50QW5kU3R5bGVzIiwiZ2xvYmFsRXJyb3JDb21wb25lbnQiLCJnbG9iYWxFcnJvclN0eWxlcyIsInVzZU5hdkZhaWx1cmVIYW5kbGVyIiwiRGVmYXVsdEdsb2JhbEVycm9yIiwicnVudGltZVN0eWxlcyIsIlNldCIsInJ1bnRpbWVTdHlsZUNoYW5nZWQiLCJnbG9iYWxUaGlzIiwiX05fRV9TVFlMRV9MT0FEIiwibGVuIiwic2l6ZSIsImFkZCIsImZvckVhY2giLCJjYiIsIlByb21pc2UiLCJyZXNvbHZlIiwiZm9yY2VVcGRhdGUiLCJSZWFjdCIsInVzZVN0YXRlIiwicmVuZGVyZWRTdHlsZXNTaXplIiwiY2hhbmdlZCIsImMiLCJkZWxldGUiLCJkcGxJZCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIm1hcCIsImkiLCJsaW5rIiwicmVsIiwicHJlY2VkZW5jZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/globals/intercept-console-error.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/globals/intercept-console-error.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    originConsoleError: function() {\n        return originConsoleError;\n    },\n    patchConsoleError: function() {\n        return patchConsoleError;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../../lib/is-error */ \"(app-pages-browser)/./node_modules/next/dist/lib/is-error.js\"));\nconst _isnextroutererror = __webpack_require__(/*! ../is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _useerrorhandler = __webpack_require__(/*! ../errors/use-error-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/use-error-handler.js\");\nconst _console = __webpack_require__(/*! ../../lib/console */ \"(app-pages-browser)/./node_modules/next/dist/client/lib/console.js\");\nconst originConsoleError = globalThis.console.error;\nfunction patchConsoleError() {\n    // Ensure it's only patched once\n    if (false) {}\n    window.console.error = function error() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        let maybeError;\n        if (true) {\n            const { error: replayedError } = (0, _console.parseConsoleArgs)(args);\n            if (replayedError) {\n                maybeError = replayedError;\n            } else if ((0, _iserror.default)(args[0])) {\n                maybeError = args[0];\n            } else {\n                // See https://github.com/facebook/react/blob/d50323eb845c5fde0d720cae888bf35dedd05506/packages/react-reconciler/src/ReactFiberErrorLogger.js#L78\n                maybeError = args[1];\n            }\n        } else {}\n        if (!(0, _isnextroutererror.isNextRouterError)(maybeError)) {\n            if (true) {\n                (0, _useerrorhandler.handleClientError)(// but if we pass the error directly, `handleClientError` will ignore it\n                maybeError, args, true);\n            }\n            originConsoleError.apply(window.console, args);\n        }\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=intercept-console-error.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvZ2xvYmFscy9pbnRlcmNlcHQtY29uc29sZS1lcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFLYUEsa0JBQWtCO2VBQWxCQTs7SUFHR0MsaUJBQWlCO2VBQWpCQTs7Ozs4RUFSSTsrQ0FDYzs2Q0FDQTtxQ0FDRDtBQUUxQixNQUFNRCxxQkFBcUJFLFdBQVdDLE9BQU8sQ0FBQ0MsS0FBSztBQUduRCxTQUFTSDtJQUNkLGdDQUFnQztJQUNoQyxJQUFJLEtBQTZCLEVBQUUsRUFFbEM7SUFDREksT0FBT0YsT0FBTyxDQUFDQyxLQUFLLEdBQUcsU0FBU0E7UUFBTSxpQ0FBR0UsT0FBSDtZQUFHQSxJQUFBQSxDQUFILHVCQUFjOztRQUNsRCxJQUFJQztRQUNKLElBQUlDLElBQW9CLEVBQW1CO1lBQ3pDLE1BQU0sRUFBRUosT0FBT08sYUFBYSxFQUFFLEdBQUdDLENBQUFBLEdBQUFBLFNBQUFBLGdCQUFBQSxFQUFpQk47WUFDbEQsSUFBSUssZUFBZTtnQkFDakJKLGFBQWFJO1lBQ2YsT0FBTyxJQUFJRSxDQUFBQSxHQUFBQSxTQUFBQSxPQUFBQSxFQUFRUCxJQUFJLENBQUMsRUFBRSxHQUFHO2dCQUMzQkMsYUFBYUQsSUFBSSxDQUFDLEVBQUU7WUFDdEIsT0FBTztnQkFDTCxpSkFBaUo7Z0JBQ2pKQyxhQUFhRCxJQUFJLENBQUMsRUFBRTtZQUN0QjtRQUNGLE9BQU8sRUFFTjtRQUVELElBQUksQ0FBQ1EsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDUCxhQUFhO1lBQ2xDLElBQUlDLElBQW9CLEVBQW1CO2dCQUN6Q08sQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUNFLHdFQUN3RTtnQkFDeEVSLFlBQ0FELE1BQ0E7WUFFSjtZQUVBTixtQkFBbUJnQixLQUFLLENBQUNYLE9BQU9GLE9BQU8sRUFBRUc7UUFDM0M7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xcZ2xvYmFsc1xcaW50ZXJjZXB0LWNvbnNvbGUtZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi4vLi4vLi4vbGliL2lzLWVycm9yJ1xuaW1wb3J0IHsgaXNOZXh0Um91dGVyRXJyb3IgfSBmcm9tICcuLi9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IGhhbmRsZUNsaWVudEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3VzZS1lcnJvci1oYW5kbGVyJ1xuaW1wb3J0IHsgcGFyc2VDb25zb2xlQXJncyB9IGZyb20gJy4uLy4uL2xpYi9jb25zb2xlJ1xuXG5leHBvcnQgY29uc3Qgb3JpZ2luQ29uc29sZUVycm9yID0gZ2xvYmFsVGhpcy5jb25zb2xlLmVycm9yXG5cbi8vIFBhdGNoIGNvbnNvbGUuZXJyb3IgdG8gY29sbGVjdCBpbmZvcm1hdGlvbiBhYm91dCBoeWRyYXRpb24gZXJyb3JzXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDb25zb2xlRXJyb3IoKSB7XG4gIC8vIEVuc3VyZSBpdCdzIG9ubHkgcGF0Y2hlZCBvbmNlXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVyblxuICB9XG4gIHdpbmRvdy5jb25zb2xlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoLi4uYXJnczogYW55W10pIHtcbiAgICBsZXQgbWF5YmVFcnJvcjogdW5rbm93blxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCB7IGVycm9yOiByZXBsYXllZEVycm9yIH0gPSBwYXJzZUNvbnNvbGVBcmdzKGFyZ3MpXG4gICAgICBpZiAocmVwbGF5ZWRFcnJvcikge1xuICAgICAgICBtYXliZUVycm9yID0gcmVwbGF5ZWRFcnJvclxuICAgICAgfSBlbHNlIGlmIChpc0Vycm9yKGFyZ3NbMF0pKSB7XG4gICAgICAgIG1heWJlRXJyb3IgPSBhcmdzWzBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvZDUwMzIzZWI4NDVjNWZkZTBkNzIwY2FlODg4YmYzNWRlZGQwNTUwNi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyRXJyb3JMb2dnZXIuanMjTDc4XG4gICAgICAgIG1heWJlRXJyb3IgPSBhcmdzWzFdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heWJlRXJyb3IgPSBhcmdzWzBdXG4gICAgfVxuXG4gICAgaWYgKCFpc05leHRSb3V0ZXJFcnJvcihtYXliZUVycm9yKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaGFuZGxlQ2xpZW50RXJyb3IoXG4gICAgICAgICAgLy8gcmVwbGF5ZWQgZXJyb3JzIGhhdmUgdGhlaXIgb3duIGNvbXBsZXggZm9ybWF0IHN0cmluZyB0aGF0IHNob3VsZCBiZSB1c2VkLFxuICAgICAgICAgIC8vIGJ1dCBpZiB3ZSBwYXNzIHRoZSBlcnJvciBkaXJlY3RseSwgYGhhbmRsZUNsaWVudEVycm9yYCB3aWxsIGlnbm9yZSBpdFxuICAgICAgICAgIG1heWJlRXJyb3IsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgb3JpZ2luQ29uc29sZUVycm9yLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIm9yaWdpbkNvbnNvbGVFcnJvciIsInBhdGNoQ29uc29sZUVycm9yIiwiZ2xvYmFsVGhpcyIsImNvbnNvbGUiLCJlcnJvciIsIndpbmRvdyIsImFyZ3MiLCJtYXliZUVycm9yIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicmVwbGF5ZWRFcnJvciIsInBhcnNlQ29uc29sZUFyZ3MiLCJpc0Vycm9yIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJoYW5kbGVDbGllbnRFcnJvciIsImFwcGx5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/globals/intercept-console-error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"HTTPAccessFallbackBoundary\", ({\n    enumerable: true,\n    get: function() {\n        return HTTPAccessFallbackBoundary;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _navigationuntracked = __webpack_require__(/*! ../navigation-untracked */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation-untracked.js\");\nconst _httpaccessfallback = __webpack_require__(/*! ./http-access-fallback */ \"(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js\");\nconst _warnonce = __webpack_require__(/*! ../../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nclass HTTPAccessFallbackErrorBoundary extends _react.default.Component {\n    componentDidCatch() {\n        if ( true && this.props.missingSlots && this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn\n        !this.props.missingSlots.has('children')) {\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\n            const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>\"@\" + slot).join(', ');\n            warningMessage += 'Missing slots: ' + formattedSlots;\n            (0, _warnonce.warnOnce)(warningMessage);\n        }\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n            const httpStatus = (0, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);\n            return {\n                triggeredStatus: httpStatus\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n            return {\n                triggeredStatus: undefined,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            triggeredStatus: state.triggeredStatus,\n            previousPathname: props.pathname\n        };\n    }\n    render() {\n        const { notFound, forbidden, unauthorized, children } = this.props;\n        const { triggeredStatus } = this.state;\n        const errorComponents = {\n            [_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n            [_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n            [_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\n        };\n        if (triggeredStatus) {\n            const isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND && notFound;\n            const isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN && forbidden;\n            const isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\n                return children;\n            }\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }),\n                     true && /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"boundary-next-error\",\n                        content: (0, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)\n                    }),\n                    errorComponents[triggeredStatus]\n                ]\n            });\n        }\n        return children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            triggeredStatus: undefined,\n            previousPathname: props.pathname\n        };\n    }\n}\nfunction HTTPAccessFallbackBoundary(param) {\n    let { notFound, forbidden, unauthorized, children } = param;\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these error can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    const missingSlots = (0, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\n    if (hasErrorFallback) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {\n            pathname: pathname,\n            notFound: notFound,\n            forbidden: forbidden,\n            unauthorized: unauthorized,\n            missingSlots: missingSlots,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = HTTPAccessFallbackBoundary;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c;\n$RefreshReg$(_c, \"HTTPAccessFallbackBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs4REF1SmdCQTs7O2VBQUFBOzs7Ozs2RUExSWtCO2lEQUNHO2dEQU05QjtzQ0FDa0I7MkRBQ1U7QUFxQm5DLE1BQU1DLHdDQUF3Q0MsT0FBQUEsT0FBSyxDQUFDQyxTQUFTO0lBWTNEQyxvQkFBMEI7UUFDeEIsSUFDRUMsS0FBb0IsSUFDcEIsSUFBSSxDQUFDRyxLQUFLLENBQUNDLFlBQVksSUFDdkIsSUFBSSxDQUFDRCxLQUFLLENBQUNDLFlBQVksQ0FBQ0MsSUFBSSxHQUFHLEtBQy9CLDRFQUE0RTtRQUM1RSxDQUFDLElBQUksQ0FBQ0YsS0FBSyxDQUFDQyxZQUFZLENBQUNFLEdBQUcsQ0FBQyxhQUM3QjtZQUNBLElBQUlDLGlCQUNGLDRIQUNBO1lBRUYsTUFBTUMsaUJBQWlCQyxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDUCxLQUFLLENBQUNDLFlBQVksRUFDdERPLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFRSxhQUFhLENBQUNELElBQy9CRSxHQUFHLENBQUMsQ0FBQ0MsT0FBVSxNQUFHQSxNQUNsQkMsSUFBSSxDQUFDO1lBRVJWLGtCQUFrQixvQkFBb0JDO1lBRXRDVSxDQUFBQSxHQUFBQSxVQUFBQSxRQUFBQSxFQUFTWDtRQUNYO0lBQ0Y7SUFFQSxPQUFPWSx5QkFBeUJDLEtBQVUsRUFBRTtRQUMxQyxJQUFJQyxDQUFBQSxHQUFBQSxvQkFBQUEseUJBQXlCLEVBQUNELFFBQVE7WUFDcEMsTUFBTUUsYUFBYUMsQ0FBQUEsR0FBQUEsb0JBQUFBLDJCQUFBQSxFQUE0Qkg7WUFDL0MsT0FBTztnQkFDTEksaUJBQWlCRjtZQUNuQjtRQUNGO1FBQ0EsbUNBQW1DO1FBQ25DLE1BQU1GO0lBQ1I7SUFFQSxPQUFPSyx5QkFDTHRCLEtBQTJDLEVBQzNDdUIsS0FBOEIsRUFDRTtRQUNoQzs7Ozs7S0FLQyxHQUNELElBQUl2QixNQUFNd0IsUUFBUSxLQUFLRCxNQUFNRSxnQkFBZ0IsSUFBSUYsTUFBTUYsZUFBZSxFQUFFO1lBQ3RFLE9BQU87Z0JBQ0xBLGlCQUFpQks7Z0JBQ2pCRCxrQkFBa0J6QixNQUFNd0IsUUFBUTtZQUNsQztRQUNGO1FBQ0EsT0FBTztZQUNMSCxpQkFBaUJFLE1BQU1GLGVBQWU7WUFDdENJLGtCQUFrQnpCLE1BQU13QixRQUFRO1FBQ2xDO0lBQ0Y7SUFFQUcsU0FBUztRQUNQLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDL0IsS0FBSztRQUNsRSxNQUFNLEVBQUVxQixlQUFlLEVBQUUsR0FBRyxJQUFJLENBQUNFLEtBQUs7UUFDdEMsTUFBTVMsa0JBQWtCO1lBQ3RCLENBQUNDLG9CQUFBQSxxQkFBcUIsQ0FBQ0MsU0FBUyxDQUFDLEVBQUVOO1lBQ25DLENBQUNLLG9CQUFBQSxxQkFBcUIsQ0FBQ0UsU0FBUyxDQUFDLEVBQUVOO1lBQ25DLENBQUNJLG9CQUFBQSxxQkFBcUIsQ0FBQ0csWUFBWSxDQUFDLEVBQUVOO1FBQ3hDO1FBRUEsSUFBSVQsaUJBQWlCO1lBQ25CLE1BQU1nQixhQUNKaEIsb0JBQW9CWSxvQkFBQUEscUJBQXFCLENBQUNDLFNBQVMsSUFBSU47WUFDekQsTUFBTVUsY0FDSmpCLG9CQUFvQlksb0JBQUFBLHFCQUFxQixDQUFDRSxTQUFTLElBQUlOO1lBQ3pELE1BQU1VLGlCQUNKbEIsb0JBQW9CWSxvQkFBQUEscUJBQXFCLENBQUNHLFlBQVksSUFBSU47WUFFNUQsa0dBQWtHO1lBQ2xHLElBQUksQ0FBRU8sQ0FBQUEsY0FBY0MsZUFBZUMsY0FBQUEsQ0FBYSxFQUFJO2dCQUNsRCxPQUFPUjtZQUNUO1lBRUEscUJBQ0U7O2tDQUNFLHFCQUFDUyxRQUFBQTt3QkFBS0MsTUFBSzt3QkFBU0MsU0FBUTs7eUJBQ1csSUFBYixjQUN4QixxQkFBQ0YsUUFBQUE7d0JBQ0NDLE1BQUs7d0JBQ0xDLFNBQVNDLENBQUFBLEdBQUFBLG9CQUFBQSxrQ0FBQUEsRUFBbUN0Qjs7b0JBRy9DVyxlQUFlLENBQUNYLGdCQUFnQjs7O1FBR3ZDO1FBRUEsT0FBT1U7SUFDVDtJQXJHQWEsWUFBWTVDLEtBQTJDLENBQUU7UUFDdkQsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ3VCLEtBQUssR0FBRztZQUNYRixpQkFBaUJLO1lBQ2pCRCxrQkFBa0J6QixNQUFNd0IsUUFBUTtRQUNsQztJQUNGO0FBZ0dGO0FBRU8sb0NBQW9DLEtBS1Q7SUFMUyxNQUN6Q0ksUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFlBQVksRUFDWkMsUUFBUSxFQUN3QixHQUxTO0lBTXpDLDZFQUE2RTtJQUM3RSxxRUFBcUU7SUFDckUsd0VBQXdFO0lBQ3hFLG1FQUFtRTtJQUNuRSxNQUFNUCxXQUFXcUIsQ0FBQUEsR0FBQUEscUJBQUFBLG9CQUFBQTtJQUNqQixNQUFNNUMsZUFBZTZDLENBQUFBLEdBQUFBLE9BQUFBLFVBQUFBLEVBQVdDLCtCQUFBQSxrQkFBa0I7SUFDbEQsTUFBTUMsbUJBQW1CLENBQUMsQ0FBRXBCLENBQUFBLFlBQVlDLGFBQWFDLFlBQUFBLENBQVc7SUFFaEUsSUFBSWtCLGtCQUFrQjtRQUNwQixxQkFDRSxxQkFBQ3ZELGlDQUFBQTtZQUNDK0IsVUFBVUE7WUFDVkksVUFBVUE7WUFDVkMsV0FBV0E7WUFDWEMsY0FBY0E7WUFDZDdCLGNBQWNBO3NCQUViOEI7O0lBR1A7SUFFQSxxQkFBTztrQkFBR0E7O0FBQ1o7S0E3QmdCdkMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxodHRwLWFjY2Vzcy1mYWxsYmFja1xcZXJyb3ItYm91bmRhcnkudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG4vKipcbiAqIEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IGlzIGEgYm91bmRhcnkgdGhhdCBjYXRjaGVzIGVycm9ycyBhbmQgcmVuZGVycyBhXG4gKiBmYWxsYmFjayBjb21wb25lbnQgZm9yIEhUVFAgZXJyb3JzLlxuICpcbiAqIEl0IHJlY2VpdmVzIHRoZSBzdGF0dXMgY29kZSwgYW5kIGRldGVybWluZSBpZiBpdCBzaG91bGQgcmVuZGVyIGZhbGxiYWNrcyBmb3IgZmV3IEhUVFAgNHh4IGVycm9ycy5cbiAqXG4gKiBlLmcuIDQwNFxuICogNDA0IHJlcHJlc2VudHMgbm90IGZvdW5kLCBhbmQgdGhlIGZhbGxiYWNrIGNvbXBvbmVudCBwYWlyIGNvbnRhaW5zIHRoZSBjb21wb25lbnQgYW5kIGl0cyBzdHlsZXMuXG4gKlxuICovXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VVbnRyYWNrZWRQYXRobmFtZSB9IGZyb20gJy4uL25hdmlnYXRpb24tdW50cmFja2VkJ1xuaW1wb3J0IHtcbiAgSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLFxuICBnZXRBY2Nlc3NGYWxsYmFja0hUVFBTdGF0dXMsXG4gIGdldEFjY2Vzc0ZhbGxiYWNrRXJyb3JUeXBlQnlTdGF0dXMsXG4gIGlzSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3IsXG59IGZyb20gJy4vaHR0cC1hY2Nlc3MtZmFsbGJhY2snXG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvdXRpbHMvd2Fybi1vbmNlJ1xuaW1wb3J0IHsgTWlzc2luZ1Nsb3RDb250ZXh0IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5cbmludGVyZmFjZSBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeVByb3BzIHtcbiAgbm90Rm91bmQ/OiBSZWFjdC5SZWFjdE5vZGVcbiAgZm9yYmlkZGVuPzogUmVhY3QuUmVhY3ROb2RlXG4gIHVuYXV0aG9yaXplZD86IFJlYWN0LlJlYWN0Tm9kZVxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIG1pc3NpbmdTbG90cz86IFNldDxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHNcbiAgZXh0ZW5kcyBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeVByb3BzIHtcbiAgcGF0aG5hbWU6IHN0cmluZyB8IG51bGxcbiAgbWlzc2luZ1Nsb3RzPzogU2V0PHN0cmluZz5cbn1cblxuaW50ZXJmYWNlIEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlIHtcbiAgdHJpZ2dlcmVkU3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgcHJldmlvdXNQYXRobmFtZTogc3RyaW5nIHwgbnVsbFxufVxuXG5jbGFzcyBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlXG4+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnlQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB0cmlnZ2VyZWRTdGF0dXM6IHVuZGVmaW5lZCxcbiAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZENhdGNoKCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICB0aGlzLnByb3BzLm1pc3NpbmdTbG90cyAmJlxuICAgICAgdGhpcy5wcm9wcy5taXNzaW5nU2xvdHMuc2l6ZSA+IDAgJiZcbiAgICAgIC8vIEEgbWlzc2luZyBjaGlsZHJlbiBzbG90IGlzIHRoZSB0eXBpY2FsIG5vdC1mb3VuZCBjYXNlLCBzbyBubyBuZWVkIHRvIHdhcm5cbiAgICAgICF0aGlzLnByb3BzLm1pc3NpbmdTbG90cy5oYXMoJ2NoaWxkcmVuJylcbiAgICApIHtcbiAgICAgIGxldCB3YXJuaW5nTWVzc2FnZSA9XG4gICAgICAgICdObyBkZWZhdWx0IGNvbXBvbmVudCB3YXMgZm91bmQgZm9yIGEgcGFyYWxsZWwgcm91dGUgcmVuZGVyZWQgb24gdGhpcyBwYWdlLiBGYWxsaW5nIGJhY2sgdG8gbmVhcmVzdCBOb3RGb3VuZCBib3VuZGFyeS5cXG4nICtcbiAgICAgICAgJ0xlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcGFyYWxsZWwtcm91dGVzI2RlZmF1bHRqc1xcblxcbidcblxuICAgICAgY29uc3QgZm9ybWF0dGVkU2xvdHMgPSBBcnJheS5mcm9tKHRoaXMucHJvcHMubWlzc2luZ1Nsb3RzKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKVxuICAgICAgICAubWFwKChzbG90KSA9PiBgQCR7c2xvdH1gKVxuICAgICAgICAuam9pbignLCAnKVxuXG4gICAgICB3YXJuaW5nTWVzc2FnZSArPSAnTWlzc2luZyBzbG90czogJyArIGZvcm1hdHRlZFNsb3RzXG5cbiAgICAgIHdhcm5PbmNlKHdhcm5pbmdNZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIGlmIChpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKGVycm9yKSkge1xuICAgICAgY29uc3QgaHR0cFN0YXR1cyA9IGdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyhlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1czogaHR0cFN0YXR1cyxcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICBwcm9wczogSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzLFxuICAgIHN0YXRlOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZVxuICApOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZSB8IG51bGwge1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcmVzZXQgb2YgdGhlIGVycm9yIGJvdW5kYXJ5IHdoZW4gYSBuYXZpZ2F0aW9uIGhhcHBlbnMuXG4gICAgICogRW5zdXJlcyB0aGUgZXJyb3IgYm91bmRhcnkgZG9lcyBub3Qgc3RheSBlbmFibGVkIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLlxuICAgICAqIEFwcHJvYWNoIG9mIHNldFN0YXRlIGluIHJlbmRlciBpcyBzYWZlIGFzIGl0IGNoZWNrcyB0aGUgcHJldmlvdXMgcGF0aG5hbWUgYW5kIHRoZW4gb3ZlcnJpZGVzXG4gICAgICogaXQgYXMgb3V0bGluZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0L3VzZVN0YXRlI3N0b3JpbmctaW5mb3JtYXRpb24tZnJvbS1wcmV2aW91cy1yZW5kZXJzXG4gICAgICovXG4gICAgaWYgKHByb3BzLnBhdGhuYW1lICE9PSBzdGF0ZS5wcmV2aW91c1BhdGhuYW1lICYmIHN0YXRlLnRyaWdnZXJlZFN0YXR1cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzOiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHJpZ2dlcmVkU3RhdHVzOiBzdGF0ZS50cmlnZ2VyZWRTdGF0dXMsXG4gICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBub3RGb3VuZCwgZm9yYmlkZGVuLCB1bmF1dGhvcml6ZWQsIGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyB0cmlnZ2VyZWRTdGF0dXMgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBlcnJvckNvbXBvbmVudHMgPSB7XG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLk5PVF9GT1VORF06IG5vdEZvdW5kLFxuICAgICAgW0hUVFBBY2Nlc3NFcnJvclN0YXR1cy5GT1JCSURERU5dOiBmb3JiaWRkZW4sXG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLlVOQVVUSE9SSVpFRF06IHVuYXV0aG9yaXplZCxcbiAgICB9XG5cbiAgICBpZiAodHJpZ2dlcmVkU3RhdHVzKSB7XG4gICAgICBjb25zdCBpc05vdEZvdW5kID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuTk9UX0ZPVU5EICYmIG5vdEZvdW5kXG4gICAgICBjb25zdCBpc0ZvcmJpZGRlbiA9XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1cyA9PT0gSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLkZPUkJJRERFTiAmJiBmb3JiaWRkZW5cbiAgICAgIGNvbnN0IGlzVW5hdXRob3JpemVkID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuVU5BVVRIT1JJWkVEICYmIHVuYXV0aG9yaXplZFxuXG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG1hdGNoZWQgYm91bmRhcnkgaW4gdGhpcyBsYXllciwga2VlcCB0aHJvd2luZyB0aGUgZXJyb3IgYnkgcmVuZGVyaW5nIHRoZSBjaGlsZHJlblxuICAgICAgaWYgKCEoaXNOb3RGb3VuZCB8fCBpc0ZvcmJpZGRlbiB8fCBpc1VuYXV0aG9yaXplZCkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cInJvYm90c1wiIGNvbnRlbnQ9XCJub2luZGV4XCIgLz5cbiAgICAgICAgICB7cHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgKFxuICAgICAgICAgICAgPG1ldGFcbiAgICAgICAgICAgICAgbmFtZT1cImJvdW5kYXJ5LW5leHQtZXJyb3JcIlxuICAgICAgICAgICAgICBjb250ZW50PXtnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzKHRyaWdnZXJlZFN0YXR1cyl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAge2Vycm9yQ29tcG9uZW50c1t0cmlnZ2VyZWRTdGF0dXNdfVxuICAgICAgICA8Lz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkoe1xuICBub3RGb3VuZCxcbiAgZm9yYmlkZGVuLFxuICB1bmF1dGhvcml6ZWQsXG4gIGNoaWxkcmVuLFxufTogSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlQcm9wcykge1xuICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyB0aGUgbWlzc2luZyBwYXJhbXMgc2hlbGwsIHRoaXMgd2lsbCByZXR1cm4gbnVsbC4gVGhpc1xuICAvLyBpcyBiZWNhdXNlIHdlIHdvbid0IGJlIHJlbmRlcmluZyBhbnkgbm90IGZvdW5kIGJvdW5kYXJpZXMgb3IgZXJyb3JcbiAgLy8gYm91bmRhcmllcyBmb3IgdGhlIG1pc3NpbmcgcGFyYW1zIHNoZWxsLiBXaGVuIHRoaXMgcnVucyBvbiB0aGUgY2xpZW50XG4gIC8vICh3aGVyZSB0aGVzZSBlcnJvciBjYW4gb2NjdXIpLCB3ZSB3aWxsIGdldCB0aGUgY29ycmVjdCBwYXRobmFtZS5cbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VVbnRyYWNrZWRQYXRobmFtZSgpXG4gIGNvbnN0IG1pc3NpbmdTbG90cyA9IHVzZUNvbnRleHQoTWlzc2luZ1Nsb3RDb250ZXh0KVxuICBjb25zdCBoYXNFcnJvckZhbGxiYWNrID0gISEobm90Rm91bmQgfHwgZm9yYmlkZGVuIHx8IHVuYXV0aG9yaXplZClcblxuICBpZiAoaGFzRXJyb3JGYWxsYmFjaykge1xuICAgIHJldHVybiAoXG4gICAgICA8SFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVxuICAgICAgICBwYXRobmFtZT17cGF0aG5hbWV9XG4gICAgICAgIG5vdEZvdW5kPXtub3RGb3VuZH1cbiAgICAgICAgZm9yYmlkZGVuPXtmb3JiaWRkZW59XG4gICAgICAgIHVuYXV0aG9yaXplZD17dW5hdXRob3JpemVkfVxuICAgICAgICBtaXNzaW5nU2xvdHM9e21pc3NpbmdTbG90c31cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9IVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz5cbn1cbiJdLCJuYW1lcyI6WyJIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsIkhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnkiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZENhdGNoIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicHJvcHMiLCJtaXNzaW5nU2xvdHMiLCJzaXplIiwiaGFzIiwid2FybmluZ01lc3NhZ2UiLCJmb3JtYXR0ZWRTbG90cyIsIkFycmF5IiwiZnJvbSIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJtYXAiLCJzbG90Iiwiam9pbiIsIndhcm5PbmNlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZXJyb3IiLCJpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yIiwiaHR0cFN0YXR1cyIsImdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyIsInRyaWdnZXJlZFN0YXR1cyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsInN0YXRlIiwicGF0aG5hbWUiLCJwcmV2aW91c1BhdGhuYW1lIiwidW5kZWZpbmVkIiwicmVuZGVyIiwibm90Rm91bmQiLCJmb3JiaWRkZW4iLCJ1bmF1dGhvcml6ZWQiLCJjaGlsZHJlbiIsImVycm9yQ29tcG9uZW50cyIsIkhUVFBBY2Nlc3NFcnJvclN0YXR1cyIsIk5PVF9GT1VORCIsIkZPUkJJRERFTiIsIlVOQVVUSE9SSVpFRCIsImlzTm90Rm91bmQiLCJpc0ZvcmJpZGRlbiIsImlzVW5hdXRob3JpemVkIiwibWV0YSIsIm5hbWUiLCJjb250ZW50IiwiZ2V0QWNjZXNzRmFsbGJhY2tFcnJvclR5cGVCeVN0YXR1cyIsImNvbnN0cnVjdG9yIiwidXNlVW50cmFja2VkUGF0aG5hbWUiLCJ1c2VDb250ZXh0IiwiTWlzc2luZ1Nsb3RDb250ZXh0IiwiaGFzRXJyb3JGYWxsYmFjayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/links.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/components/links.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    mountLinkInstance: function() {\n        return mountLinkInstance;\n    },\n    onLinkVisibilityChanged: function() {\n        return onLinkVisibilityChanged;\n    },\n    onNavigationIntent: function() {\n        return onNavigationIntent;\n    },\n    pingVisibleLinks: function() {\n        return pingVisibleLinks;\n    },\n    unmountLinkInstance: function() {\n        return unmountLinkInstance;\n    }\n});\nconst _actionqueue = __webpack_require__(/*! ../../shared/lib/router/action-queue */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/action-queue.js\");\nconst _approuter = __webpack_require__(/*! ./app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _segmentcache = __webpack_require__(/*! ./segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst links = typeof WeakMap === 'function' ? new WeakMap() : new Map();\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst visibleLinks = new Set();\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {\n    rootMargin: '200px'\n}) : null;\nfunction mountLinkInstance(element, href, router, kind) {\n    let prefetchUrl = null;\n    try {\n        prefetchUrl = (0, _approuter.createPrefetchURL)(href);\n        if (prefetchUrl === null) {\n            // We only track the link if it's prefetchable. For example, this excludes\n            // links to external URLs.\n            return;\n        }\n    } catch (e) {\n        // createPrefetchURL sometimes throws an error if an invalid URL is\n        // provided, though I'm not sure if it's actually necessary.\n        // TODO: Consider removing the throw from the inner function, or change it\n        // to reportError. Or maybe the error isn't even necessary for automatic\n        // prefetches, just navigations.\n        const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;\n        reportErrorFn(\"Cannot prefetch '\" + href + \"' because it cannot be converted to a URL.\");\n        return;\n    }\n    const instance = {\n        prefetchHref: prefetchUrl.href,\n        router,\n        kind,\n        isVisible: false,\n        wasHoveredOrTouched: false,\n        prefetchTask: null,\n        cacheVersion: -1\n    };\n    const existingInstance = links.get(element);\n    if (existingInstance !== undefined) {\n        // This shouldn't happen because each <Link> component should have its own\n        // anchor tag instance, but it's defensive coding to avoid a memory leak in\n        // case there's a logical error somewhere else.\n        unmountLinkInstance(element);\n    }\n    links.set(element, instance);\n    if (observer !== null) {\n        observer.observe(element);\n    }\n}\nfunction unmountLinkInstance(element) {\n    const instance = links.get(element);\n    if (instance !== undefined) {\n        links.delete(element);\n        visibleLinks.delete(instance);\n        const prefetchTask = instance.prefetchTask;\n        if (prefetchTask !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(prefetchTask);\n        }\n    }\n    if (observer !== null) {\n        observer.unobserve(element);\n    }\n}\nfunction handleIntersect(entries) {\n    for (const entry of entries){\n        // Some extremely old browsers or polyfills don't reliably support\n        // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n        // really. But whatever this is fine.)\n        const isVisible = entry.intersectionRatio > 0;\n        onLinkVisibilityChanged(entry.target, isVisible);\n    }\n}\nfunction onLinkVisibilityChanged(element, isVisible) {\n    if (true) {\n        // Prefetching on viewport is disabled in development for performance\n        // reasons, because it requires compiling the target page.\n        // TODO: Investigate re-enabling this.\n        return;\n    }\n    const instance = links.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    instance.isVisible = isVisible;\n    if (isVisible) {\n        visibleLinks.add(instance);\n    } else {\n        visibleLinks.delete(instance);\n    }\n    rescheduleLinkPrefetch(instance);\n}\nfunction onNavigationIntent(element) {\n    const instance = links.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    // Prefetch the link on hover/touchstart.\n    if (instance !== undefined) {\n        instance.wasHoveredOrTouched = true;\n        rescheduleLinkPrefetch(instance);\n    }\n}\nfunction rescheduleLinkPrefetch(instance) {\n    const existingPrefetchTask = instance.prefetchTask;\n    if (!instance.isVisible) {\n        // Cancel any in-progress prefetch task. (If it already finished then this\n        // is a no-op.)\n        if (existingPrefetchTask !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(existingPrefetchTask);\n        }\n        // We don't need to reset the prefetchTask to null upon cancellation; an\n        // old task object can be rescheduled with bumpPrefetchTask. This is a\n        // micro-optimization but also makes the code simpler (don't need to\n        // worry about whether an old task object is stale).\n        return;\n    }\n    if (true) {\n        // The old prefetch implementation does not have different priority levels.\n        // Just schedule a new prefetch task.\n        prefetchWithOldCacheImplementation(instance);\n        return;\n    }\n    // In the Segment Cache implementation, we assign a higher priority level to\n    // links that were at one point hovered or touched. Since the queue is last-\n    // in-first-out, the highest priority Link is whichever one was hovered last.\n    //\n    // We also increase the relative priority of links whenever they re-enter the\n    // viewport, as if they were being scheduled for the first time.\n    const priority = instance.wasHoveredOrTouched ? _segmentcache.PrefetchPriority.Intent : _segmentcache.PrefetchPriority.Default;\n    if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const appRouterState = (0, _actionqueue.getCurrentAppRouterState)();\n        if (appRouterState !== null) {\n            const nextUrl = appRouterState.nextUrl;\n            const treeAtTimeOfPrefetch = appRouterState.tree;\n            const cacheKey = (0, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);\n            instance.prefetchTask = (0, _segmentcache.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, instance.kind === _routerreducertypes.PrefetchKind.FULL, priority);\n            instance.cacheVersion = (0, _segmentcache.getCurrentCacheVersion)();\n        }\n    } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        (0, _segmentcache.bumpPrefetchTask)(existingPrefetchTask, priority);\n    }\n}\nfunction pingVisibleLinks(nextUrl, tree) {\n    // For each currently visible link, cancel the existing prefetch task (if it\n    // exists) and schedule a new one. This is effectively the same as if all the\n    // visible links left and then re-entered the viewport.\n    //\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    const currentCacheVersion = (0, _segmentcache.getCurrentCacheVersion)();\n    for (const instance of visibleLinks){\n        const task = instance.prefetchTask;\n        if (task !== null && instance.cacheVersion === currentCacheVersion && task.key.nextUrl === nextUrl && task.treeAtTimeOfPrefetch === tree) {\n            continue;\n        }\n        // Something changed. Cancel the existing prefetch task and schedule a\n        // new one.\n        if (task !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(task);\n        }\n        const cacheKey = (0, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);\n        const priority = instance.wasHoveredOrTouched ? _segmentcache.PrefetchPriority.Intent : _segmentcache.PrefetchPriority.Default;\n        instance.prefetchTask = (0, _segmentcache.schedulePrefetchTask)(cacheKey, tree, instance.kind === _routerreducertypes.PrefetchKind.FULL, priority);\n        instance.cacheVersion = (0, _segmentcache.getCurrentCacheVersion)();\n    }\n}\nfunction prefetchWithOldCacheImplementation(instance) {\n    // This is the path used when the Segment Cache is not enabled.\n    if (false) {}\n    const doPrefetch = async ()=>{\n        // note that `appRouter.prefetch()` is currently sync,\n        // so we have to wrap this call in an async function to be able to catch() errors below.\n        return instance.router.prefetch(instance.prefetchHref, {\n            kind: instance.kind\n        });\n    };\n    // Prefetch the page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    doPrefetch().catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=links.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGlua3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBc0RnQkEsaUJBQWlCO2VBQWpCQTs7SUEyRUFDLHVCQUF1QjtlQUF2QkE7O0lBeUJBQyxrQkFBa0I7ZUFBbEJBOztJQWtFQUMsZ0JBQWdCO2VBQWhCQTs7SUFwSEFDLG1CQUFtQjtlQUFuQkE7Ozt5Q0F0R3lCO3VDQUNQO2dEQUNMOzBDQUNVO0FBOEJ2QywyRUFBMkU7QUFDM0UsbUVBQW1FO0FBQ25FLE1BQU1DLFFBQ0osT0FBT0MsWUFBWSxhQUFhLElBQUlBLFlBQVksSUFBSUM7QUFFdEQsNkVBQTZFO0FBQzdFLDRFQUE0RTtBQUM1RSwwRUFBMEU7QUFDMUUsaUJBQWlCO0FBQ2pCLE1BQU1DLGVBQWtDLElBQUlDO0FBRTVDLDBFQUEwRTtBQUMxRSxNQUFNQyxXQUNKLE9BQU9DLHlCQUF5QixhQUM1QixJQUFJQSxxQkFBcUJDLGlCQUFpQjtJQUN4Q0MsWUFBWTtBQUNkLEtBQ0E7QUFFQyxTQUFTYixrQkFDZGMsT0FBb0IsRUFDcEJDLElBQVksRUFDWkMsTUFBeUIsRUFDekJDLElBQTJDO0lBRTNDLElBQUlDLGNBQTBCO0lBQzlCLElBQUk7UUFDRkEsY0FBY0MsQ0FBQUEsR0FBQUEsV0FBQUEsaUJBQUFBLEVBQWtCSjtRQUNoQyxJQUFJRyxnQkFBZ0IsTUFBTTtZQUN4QiwwRUFBMEU7WUFDMUUsMEJBQTBCO1lBQzFCO1FBQ0Y7SUFDRixFQUFFLFVBQU07UUFDTixtRUFBbUU7UUFDbkUsNERBQTREO1FBQzVELDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsZ0NBQWdDO1FBQ2hDLE1BQU1FLGdCQUNKLE9BQU9DLGdCQUFnQixhQUFhQSxjQUFjQyxRQUFRQyxLQUFLO1FBQ2pFSCxjQUNHLHNCQUFtQkwsT0FBSztRQUUzQjtJQUNGO0lBRUEsTUFBTVMsV0FBeUI7UUFDN0JDLGNBQWNQLFlBQVlI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QjtRQUNyQjtRQUNBLE1BQU1SLFdBQVdDLENBQUFBLEdBQUFBLGNBQUFBLGNBQUFBLEVBQWVwQyxTQUFTQyxZQUFZLEVBQUUrQjtRQUN2RCxNQUFNTixXQUFXMUIsU0FBU0csbUJBQW1CLEdBQ3pDd0IsY0FBQUEsZ0JBQWdCLENBQUNDLE1BQU0sR0FDdkJELGNBQUFBLGdCQUFnQixDQUFDRSxPQUFPO1FBQzVCN0IsU0FBU0ksWUFBWSxHQUFHaUMsQ0FBQUEsR0FBQUEsY0FBQUEsb0JBQUFBLEVBQ3RCRixVQUNBRCxNQUNBbEMsU0FBU1AsSUFBSSxLQUFLNkMsb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUNuQ2I7UUFFRjFCLFNBQVNLLFlBQVksR0FBR21DLENBQUFBLEdBQUFBLGNBQUFBLHNCQUFzQjtJQUNoRDtBQUNGO0FBRUEsU0FBU2YsbUNBQW1DekIsUUFBc0I7SUFDaEUsK0RBQStEO0lBQy9ELElBQUksS0FBNkIsRUFBRSxFQUVsQztJQUVELE1BQU04QyxhQUFhO1FBQ2pCLHNEQUFzRDtRQUN0RCx3RkFBd0Y7UUFDeEYsT0FBTzlDLFNBQVNSLE1BQU0sQ0FBQ3VELFFBQVEsQ0FBQy9DLFNBQVNDLFlBQVksRUFBRTtZQUNyRFIsTUFBTU8sU0FBU1AsSUFBSTtRQUNyQjtJQUNGO0lBRUEsa0RBQWtEO0lBQ2xELDBEQUEwRDtJQUMxRCxzREFBc0Q7SUFDdEQseURBQXlEO0lBQ3pEcUQsYUFBYUUsS0FBSyxDQUFDLENBQUNDO1FBQ2xCLElBcE5BLElBb053QixFQUFtQjtZQUN6QyxxQ0FBcUM7WUFDckMsTUFBTUE7UUFDUjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXE9uZURyaXZlXFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xcbGlua3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBBcHBSb3V0ZXJJbnN0YW5jZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZ2V0Q3VycmVudEFwcFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvYWN0aW9uLXF1ZXVlJ1xuaW1wb3J0IHsgY3JlYXRlUHJlZmV0Y2hVUkwgfSBmcm9tICcuL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBQcmVmZXRjaEtpbmQgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgZ2V0Q3VycmVudENhY2hlVmVyc2lvbiB9IGZyb20gJy4vc2VnbWVudC1jYWNoZSdcbmltcG9ydCB7IGNyZWF0ZUNhY2hlS2V5IH0gZnJvbSAnLi9zZWdtZW50LWNhY2hlJ1xuaW1wb3J0IHtcbiAgdHlwZSBQcmVmZXRjaFRhc2ssXG4gIFByZWZldGNoUHJpb3JpdHksXG4gIHNjaGVkdWxlUHJlZmV0Y2hUYXNrIGFzIHNjaGVkdWxlU2VnbWVudFByZWZldGNoVGFzayxcbiAgY2FuY2VsUHJlZmV0Y2hUYXNrLFxuICBidW1wUHJlZmV0Y2hUYXNrLFxufSBmcm9tICcuL3NlZ21lbnQtY2FjaGUnXG5cbnR5cGUgTGlua0VsZW1lbnQgPSBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50IHwgSFRNTEZvcm1FbGVtZW50XG5cbnR5cGUgTGlua0luc3RhbmNlID0ge1xuICByb3V0ZXI6IEFwcFJvdXRlckluc3RhbmNlXG4gIGtpbmQ6IFByZWZldGNoS2luZC5BVVRPIHwgUHJlZmV0Y2hLaW5kLkZVTExcbiAgcHJlZmV0Y2hIcmVmOiBzdHJpbmdcblxuICBpc1Zpc2libGU6IGJvb2xlYW5cbiAgd2FzSG92ZXJlZE9yVG91Y2hlZDogYm9vbGVhblxuXG4gIC8vIFRoZSBtb3N0IHJlY2VudGx5IGluaXRpYXRlZCBwcmVmZXRjaCB0YXNrLiBJdCBtYXkgb3IgbWF5IG5vdCBoYXZlXG4gIC8vIGFscmVhZHkgY29tcGxldGVkLiAgVGhlIHNhbWUgcHJlZmV0Y2ggdGFzayBvYmplY3QgY2FuIGJlIHJldXNlZCBhY3Jvc3NcbiAgLy8gbXVsdGlwbGUgcHJlZmV0Y2hlcyBvZiB0aGUgc2FtZSBsaW5rLlxuICBwcmVmZXRjaFRhc2s6IFByZWZldGNoVGFzayB8IG51bGxcblxuICAvLyBUaGUgY2FjaGUgdmVyc2lvbiBhdCB0aGUgdGltZSB0aGUgdGFzayB3YXMgaW5pdGlhdGVkLiBUaGlzIGlzIHVzZWQgdG9cbiAgLy8gZGV0ZXJtaW5lIGlmIHRoZSBjYWNoZSB3YXMgaW52YWxpZGF0ZWQgc2luY2UgdGhlIHRhc2sgd2FzIGluaXRpYXRlZC5cbiAgY2FjaGVWZXJzaW9uOiBudW1iZXJcbn1cblxuLy8gVXNlIGEgV2Vha01hcCB0byBhc3NvY2lhdGUgYSBMaW5rIGluc3RhbmNlIHdpdGggaXRzIERPTSBlbGVtZW50LiBUaGlzIGlzXG4vLyB1c2VkIGJ5IHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciB0byB0cmFjayB0aGUgbGluaydzIHZpc2liaWxpdHkuXG5jb25zdCBsaW5rczogV2Vha01hcDxMaW5rRWxlbWVudCwgTGlua0luc3RhbmNlPiB8IE1hcDxFbGVtZW50LCBMaW5rSW5zdGFuY2U+ID1cbiAgdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcCgpXG5cbi8vIEEgU2V0IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBsaW5rcy4gV2UgcmUtcHJlZmV0Y2ggdmlzaWJsZSBsaW5rcyBhZnRlciBhXG4vLyBjYWNoZSBpbnZhbGlkYXRpb24sIG9yIHdoZW4gdGhlIGN1cnJlbnQgVVJMIGNoYW5nZXMuIEl0J3MgYSBzZXBhcmF0ZSBkYXRhXG4vLyBzdHJ1Y3R1cmUgZnJvbSB0aGUgV2Vha01hcCBhYm92ZSBiZWNhdXNlIG9ubHkgdGhlIHZpc2libGUgbGlua3MgbmVlZCB0b1xuLy8gYmUgZW51bWVyYXRlZC5cbmNvbnN0IHZpc2libGVMaW5rczogU2V0PExpbmtJbnN0YW5jZT4gPSBuZXcgU2V0KClcblxuLy8gQSBzaW5nbGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaW5zdGFuY2Ugc2hhcmVkIGJ5IGFsbCA8TGluaz4gY29tcG9uZW50cy5cbmNvbnN0IG9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlciB8IG51bGwgPVxuICB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbidcbiAgICA/IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVJbnRlcnNlY3QsIHtcbiAgICAgICAgcm9vdE1hcmdpbjogJzIwMHB4JyxcbiAgICAgIH0pXG4gICAgOiBudWxsXG5cbmV4cG9ydCBmdW5jdGlvbiBtb3VudExpbmtJbnN0YW5jZShcbiAgZWxlbWVudDogTGlua0VsZW1lbnQsXG4gIGhyZWY6IHN0cmluZyxcbiAgcm91dGVyOiBBcHBSb3V0ZXJJbnN0YW5jZSxcbiAga2luZDogUHJlZmV0Y2hLaW5kLkFVVE8gfCBQcmVmZXRjaEtpbmQuRlVMTFxuKSB7XG4gIGxldCBwcmVmZXRjaFVybDogVVJMIHwgbnVsbCA9IG51bGxcbiAgdHJ5IHtcbiAgICBwcmVmZXRjaFVybCA9IGNyZWF0ZVByZWZldGNoVVJMKGhyZWYpXG4gICAgaWYgKHByZWZldGNoVXJsID09PSBudWxsKSB7XG4gICAgICAvLyBXZSBvbmx5IHRyYWNrIHRoZSBsaW5rIGlmIGl0J3MgcHJlZmV0Y2hhYmxlLiBGb3IgZXhhbXBsZSwgdGhpcyBleGNsdWRlc1xuICAgICAgLy8gbGlua3MgdG8gZXh0ZXJuYWwgVVJMcy5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gY3JlYXRlUHJlZmV0Y2hVUkwgc29tZXRpbWVzIHRocm93cyBhbiBlcnJvciBpZiBhbiBpbnZhbGlkIFVSTCBpc1xuICAgIC8vIHByb3ZpZGVkLCB0aG91Z2ggSSdtIG5vdCBzdXJlIGlmIGl0J3MgYWN0dWFsbHkgbmVjZXNzYXJ5LlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHJlbW92aW5nIHRoZSB0aHJvdyBmcm9tIHRoZSBpbm5lciBmdW5jdGlvbiwgb3IgY2hhbmdlIGl0XG4gICAgLy8gdG8gcmVwb3J0RXJyb3IuIE9yIG1heWJlIHRoZSBlcnJvciBpc24ndCBldmVuIG5lY2Vzc2FyeSBmb3IgYXV0b21hdGljXG4gICAgLy8gcHJlZmV0Y2hlcywganVzdCBuYXZpZ2F0aW9ucy5cbiAgICBjb25zdCByZXBvcnRFcnJvckZuID1cbiAgICAgIHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IHJlcG9ydEVycm9yIDogY29uc29sZS5lcnJvclxuICAgIHJlcG9ydEVycm9yRm4oXG4gICAgICBgQ2Fubm90IHByZWZldGNoICcke2hyZWZ9JyBiZWNhdXNlIGl0IGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBVUkwuYFxuICAgIClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGluc3RhbmNlOiBMaW5rSW5zdGFuY2UgPSB7XG4gICAgcHJlZmV0Y2hIcmVmOiBwcmVmZXRjaFVybC5ocmVmLFxuICAgIHJvdXRlcixcbiAgICBraW5kLFxuICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgd2FzSG92ZXJlZE9yVG91Y2hlZDogZmFsc2UsXG4gICAgcHJlZmV0Y2hUYXNrOiBudWxsLFxuICAgIGNhY2hlVmVyc2lvbjogLTEsXG4gIH1cbiAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IGxpbmtzLmdldChlbGVtZW50KVxuICBpZiAoZXhpc3RpbmdJbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgZWFjaCA8TGluaz4gY29tcG9uZW50IHNob3VsZCBoYXZlIGl0cyBvd25cbiAgICAvLyBhbmNob3IgdGFnIGluc3RhbmNlLCBidXQgaXQncyBkZWZlbnNpdmUgY29kaW5nIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW5cbiAgICAvLyBjYXNlIHRoZXJlJ3MgYSBsb2dpY2FsIGVycm9yIHNvbWV3aGVyZSBlbHNlLlxuICAgIHVubW91bnRMaW5rSW5zdGFuY2UoZWxlbWVudClcbiAgfVxuICBsaW5rcy5zZXQoZWxlbWVudCwgaW5zdGFuY2UpXG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudExpbmtJbnN0YW5jZShlbGVtZW50OiBMaW5rRWxlbWVudCkge1xuICBjb25zdCBpbnN0YW5jZSA9IGxpbmtzLmdldChlbGVtZW50KVxuICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGxpbmtzLmRlbGV0ZShlbGVtZW50KVxuICAgIHZpc2libGVMaW5rcy5kZWxldGUoaW5zdGFuY2UpXG4gICAgY29uc3QgcHJlZmV0Y2hUYXNrID0gaW5zdGFuY2UucHJlZmV0Y2hUYXNrXG4gICAgaWYgKHByZWZldGNoVGFzayAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsUHJlZmV0Y2hUYXNrKHByZWZldGNoVGFzaylcbiAgICB9XG4gIH1cbiAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0KGVudHJpZXM6IEFycmF5PEludGVyc2VjdGlvbk9ic2VydmVyRW50cnk+KSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIC8vIFNvbWUgZXh0cmVtZWx5IG9sZCBicm93c2VycyBvciBwb2x5ZmlsbHMgZG9uJ3QgcmVsaWFibHkgc3VwcG9ydFxuICAgIC8vIGlzSW50ZXJzZWN0aW5nIHNvIHdlIGNoZWNrIGludGVyc2VjdGlvblJhdGlvIGluc3RlYWQuIChEbyB3ZSBjYXJlPyBOb3RcbiAgICAvLyByZWFsbHkuIEJ1dCB3aGF0ZXZlciB0aGlzIGlzIGZpbmUuKVxuICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMFxuICAgIG9uTGlua1Zpc2liaWxpdHlDaGFuZ2VkKGVudHJ5LnRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudCwgaXNWaXNpYmxlKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkxpbmtWaXNpYmlsaXR5Q2hhbmdlZChcbiAgZWxlbWVudDogTGlua0VsZW1lbnQsXG4gIGlzVmlzaWJsZTogYm9vbGVhblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gUHJlZmV0Y2hpbmcgb24gdmlld3BvcnQgaXMgZGlzYWJsZWQgaW4gZGV2ZWxvcG1lbnQgZm9yIHBlcmZvcm1hbmNlXG4gICAgLy8gcmVhc29ucywgYmVjYXVzZSBpdCByZXF1aXJlcyBjb21waWxpbmcgdGhlIHRhcmdldCBwYWdlLlxuICAgIC8vIFRPRE86IEludmVzdGlnYXRlIHJlLWVuYWJsaW5nIHRoaXMuXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBpbnN0YW5jZSA9IGxpbmtzLmdldChlbGVtZW50KVxuICBpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaW5zdGFuY2UuaXNWaXNpYmxlID0gaXNWaXNpYmxlXG4gIGlmIChpc1Zpc2libGUpIHtcbiAgICB2aXNpYmxlTGlua3MuYWRkKGluc3RhbmNlKVxuICB9IGVsc2Uge1xuICAgIHZpc2libGVMaW5rcy5kZWxldGUoaW5zdGFuY2UpXG4gIH1cbiAgcmVzY2hlZHVsZUxpbmtQcmVmZXRjaChpbnN0YW5jZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uTmF2aWdhdGlvbkludGVudChlbGVtZW50OiBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50KSB7XG4gIGNvbnN0IGluc3RhbmNlID0gbGlua3MuZ2V0KGVsZW1lbnQpXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gUHJlZmV0Y2ggdGhlIGxpbmsgb24gaG92ZXIvdG91Y2hzdGFydC5cbiAgaWYgKGluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpbnN0YW5jZS53YXNIb3ZlcmVkT3JUb3VjaGVkID0gdHJ1ZVxuICAgIHJlc2NoZWR1bGVMaW5rUHJlZmV0Y2goaW5zdGFuY2UpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzY2hlZHVsZUxpbmtQcmVmZXRjaChpbnN0YW5jZTogTGlua0luc3RhbmNlKSB7XG4gIGNvbnN0IGV4aXN0aW5nUHJlZmV0Y2hUYXNrID0gaW5zdGFuY2UucHJlZmV0Y2hUYXNrXG5cbiAgaWYgKCFpbnN0YW5jZS5pc1Zpc2libGUpIHtcbiAgICAvLyBDYW5jZWwgYW55IGluLXByb2dyZXNzIHByZWZldGNoIHRhc2suIChJZiBpdCBhbHJlYWR5IGZpbmlzaGVkIHRoZW4gdGhpc1xuICAgIC8vIGlzIGEgbm8tb3AuKVxuICAgIGlmIChleGlzdGluZ1ByZWZldGNoVGFzayAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsUHJlZmV0Y2hUYXNrKGV4aXN0aW5nUHJlZmV0Y2hUYXNrKVxuICAgIH1cbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlc2V0IHRoZSBwcmVmZXRjaFRhc2sgdG8gbnVsbCB1cG9uIGNhbmNlbGxhdGlvbjsgYW5cbiAgICAvLyBvbGQgdGFzayBvYmplY3QgY2FuIGJlIHJlc2NoZWR1bGVkIHdpdGggYnVtcFByZWZldGNoVGFzay4gVGhpcyBpcyBhXG4gICAgLy8gbWljcm8tb3B0aW1pemF0aW9uIGJ1dCBhbHNvIG1ha2VzIHRoZSBjb2RlIHNpbXBsZXIgKGRvbid0IG5lZWQgdG9cbiAgICAvLyB3b3JyeSBhYm91dCB3aGV0aGVyIGFuIG9sZCB0YXNrIG9iamVjdCBpcyBzdGFsZSkuXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIXByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgIC8vIFRoZSBvbGQgcHJlZmV0Y2ggaW1wbGVtZW50YXRpb24gZG9lcyBub3QgaGF2ZSBkaWZmZXJlbnQgcHJpb3JpdHkgbGV2ZWxzLlxuICAgIC8vIEp1c3Qgc2NoZWR1bGUgYSBuZXcgcHJlZmV0Y2ggdGFzay5cbiAgICBwcmVmZXRjaFdpdGhPbGRDYWNoZUltcGxlbWVudGF0aW9uKGluc3RhbmNlKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gSW4gdGhlIFNlZ21lbnQgQ2FjaGUgaW1wbGVtZW50YXRpb24sIHdlIGFzc2lnbiBhIGhpZ2hlciBwcmlvcml0eSBsZXZlbCB0b1xuICAvLyBsaW5rcyB0aGF0IHdlcmUgYXQgb25lIHBvaW50IGhvdmVyZWQgb3IgdG91Y2hlZC4gU2luY2UgdGhlIHF1ZXVlIGlzIGxhc3QtXG4gIC8vIGluLWZpcnN0LW91dCwgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgTGluayBpcyB3aGljaGV2ZXIgb25lIHdhcyBob3ZlcmVkIGxhc3QuXG4gIC8vXG4gIC8vIFdlIGFsc28gaW5jcmVhc2UgdGhlIHJlbGF0aXZlIHByaW9yaXR5IG9mIGxpbmtzIHdoZW5ldmVyIHRoZXkgcmUtZW50ZXIgdGhlXG4gIC8vIHZpZXdwb3J0LCBhcyBpZiB0aGV5IHdlcmUgYmVpbmcgc2NoZWR1bGVkIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgY29uc3QgcHJpb3JpdHkgPSBpbnN0YW5jZS53YXNIb3ZlcmVkT3JUb3VjaGVkXG4gICAgPyBQcmVmZXRjaFByaW9yaXR5LkludGVudFxuICAgIDogUHJlZmV0Y2hQcmlvcml0eS5EZWZhdWx0XG4gIGlmIChleGlzdGluZ1ByZWZldGNoVGFzayA9PT0gbnVsbCkge1xuICAgIC8vIEluaXRpYXRlIGEgcHJlZmV0Y2ggdGFzay5cbiAgICBjb25zdCBhcHBSb3V0ZXJTdGF0ZSA9IGdldEN1cnJlbnRBcHBSb3V0ZXJTdGF0ZSgpXG4gICAgaWYgKGFwcFJvdXRlclN0YXRlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBuZXh0VXJsID0gYXBwUm91dGVyU3RhdGUubmV4dFVybFxuICAgICAgY29uc3QgdHJlZUF0VGltZU9mUHJlZmV0Y2ggPSBhcHBSb3V0ZXJTdGF0ZS50cmVlXG4gICAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZUNhY2hlS2V5KGluc3RhbmNlLnByZWZldGNoSHJlZiwgbmV4dFVybClcbiAgICAgIGluc3RhbmNlLnByZWZldGNoVGFzayA9IHNjaGVkdWxlU2VnbWVudFByZWZldGNoVGFzayhcbiAgICAgICAgY2FjaGVLZXksXG4gICAgICAgIHRyZWVBdFRpbWVPZlByZWZldGNoLFxuICAgICAgICBpbnN0YW5jZS5raW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCxcbiAgICAgICAgcHJpb3JpdHlcbiAgICAgIClcbiAgICAgIGluc3RhbmNlLmNhY2hlVmVyc2lvbiA9IGdldEN1cnJlbnRDYWNoZVZlcnNpb24oKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gb2xkIHRhc2sgb2JqZWN0IHRoYXQgd2UgY2FuIHJlc2NoZWR1bGUuIFRoaXMgaXNcbiAgICAvLyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBjYW5jZWxpbmcgdGhlIG9sZCB0YXNrIGFuZCBjcmVhdGluZyBhIG5ldyBvbmUuXG4gICAgYnVtcFByZWZldGNoVGFzayhleGlzdGluZ1ByZWZldGNoVGFzaywgcHJpb3JpdHkpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpbmdWaXNpYmxlTGlua3MoXG4gIG5leHRVcmw6IHN0cmluZyB8IG51bGwsXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4pIHtcbiAgLy8gRm9yIGVhY2ggY3VycmVudGx5IHZpc2libGUgbGluaywgY2FuY2VsIHRoZSBleGlzdGluZyBwcmVmZXRjaCB0YXNrIChpZiBpdFxuICAvLyBleGlzdHMpIGFuZCBzY2hlZHVsZSBhIG5ldyBvbmUuIFRoaXMgaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgaWYgYWxsIHRoZVxuICAvLyB2aXNpYmxlIGxpbmtzIGxlZnQgYW5kIHRoZW4gcmUtZW50ZXJlZCB0aGUgdmlld3BvcnQuXG4gIC8vXG4gIC8vIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIE5leHQtVXJsIG9yIHRoZSBiYXNlIHRyZWUgY2hhbmdlcywgc2luY2UgdGhvc2VcbiAgLy8gbWF5IGFmZmVjdCB0aGUgcmVzdWx0IG9mIGEgcHJlZmV0Y2ggdGFzay4gSXQncyBhbHNvIGNhbGxlZCBhZnRlciBhXG4gIC8vIGNhY2hlIGludmFsaWRhdGlvbi5cbiAgY29uc3QgY3VycmVudENhY2hlVmVyc2lvbiA9IGdldEN1cnJlbnRDYWNoZVZlcnNpb24oKVxuICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIHZpc2libGVMaW5rcykge1xuICAgIGNvbnN0IHRhc2sgPSBpbnN0YW5jZS5wcmVmZXRjaFRhc2tcbiAgICBpZiAoXG4gICAgICB0YXNrICE9PSBudWxsICYmXG4gICAgICBpbnN0YW5jZS5jYWNoZVZlcnNpb24gPT09IGN1cnJlbnRDYWNoZVZlcnNpb24gJiZcbiAgICAgIHRhc2sua2V5Lm5leHRVcmwgPT09IG5leHRVcmwgJiZcbiAgICAgIHRhc2sudHJlZUF0VGltZU9mUHJlZmV0Y2ggPT09IHRyZWVcbiAgICApIHtcbiAgICAgIC8vIFRoZSBjYWNoZSBoYXMgbm90IGJlZW4gaW52YWxpZGF0ZWQsIGFuZCBub25lIG9mIHRoZSBpbnB1dHMgaGF2ZVxuICAgICAgLy8gY2hhbmdlZC4gQmFpbCBvdXQuXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICAvLyBTb21ldGhpbmcgY2hhbmdlZC4gQ2FuY2VsIHRoZSBleGlzdGluZyBwcmVmZXRjaCB0YXNrIGFuZCBzY2hlZHVsZSBhXG4gICAgLy8gbmV3IG9uZS5cbiAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsUHJlZmV0Y2hUYXNrKHRhc2spXG4gICAgfVxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlQ2FjaGVLZXkoaW5zdGFuY2UucHJlZmV0Y2hIcmVmLCBuZXh0VXJsKVxuICAgIGNvbnN0IHByaW9yaXR5ID0gaW5zdGFuY2Uud2FzSG92ZXJlZE9yVG91Y2hlZFxuICAgICAgPyBQcmVmZXRjaFByaW9yaXR5LkludGVudFxuICAgICAgOiBQcmVmZXRjaFByaW9yaXR5LkRlZmF1bHRcbiAgICBpbnN0YW5jZS5wcmVmZXRjaFRhc2sgPSBzY2hlZHVsZVNlZ21lbnRQcmVmZXRjaFRhc2soXG4gICAgICBjYWNoZUtleSxcbiAgICAgIHRyZWUsXG4gICAgICBpbnN0YW5jZS5raW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCxcbiAgICAgIHByaW9yaXR5XG4gICAgKVxuICAgIGluc3RhbmNlLmNhY2hlVmVyc2lvbiA9IGdldEN1cnJlbnRDYWNoZVZlcnNpb24oKVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZWZldGNoV2l0aE9sZENhY2hlSW1wbGVtZW50YXRpb24oaW5zdGFuY2U6IExpbmtJbnN0YW5jZSkge1xuICAvLyBUaGlzIGlzIHRoZSBwYXRoIHVzZWQgd2hlbiB0aGUgU2VnbWVudCBDYWNoZSBpcyBub3QgZW5hYmxlZC5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBkb1ByZWZldGNoID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIG5vdGUgdGhhdCBgYXBwUm91dGVyLnByZWZldGNoKClgIGlzIGN1cnJlbnRseSBzeW5jLFxuICAgIC8vIHNvIHdlIGhhdmUgdG8gd3JhcCB0aGlzIGNhbGwgaW4gYW4gYXN5bmMgZnVuY3Rpb24gdG8gYmUgYWJsZSB0byBjYXRjaCgpIGVycm9ycyBiZWxvdy5cbiAgICByZXR1cm4gaW5zdGFuY2Uucm91dGVyLnByZWZldGNoKGluc3RhbmNlLnByZWZldGNoSHJlZiwge1xuICAgICAga2luZDogaW5zdGFuY2Uua2luZCxcbiAgICB9KVxuICB9XG5cbiAgLy8gUHJlZmV0Y2ggdGhlIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gIGRvUHJlZmV0Y2goKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJtb3VudExpbmtJbnN0YW5jZSIsIm9uTGlua1Zpc2liaWxpdHlDaGFuZ2VkIiwib25OYXZpZ2F0aW9uSW50ZW50IiwicGluZ1Zpc2libGVMaW5rcyIsInVubW91bnRMaW5rSW5zdGFuY2UiLCJsaW5rcyIsIldlYWtNYXAiLCJNYXAiLCJ2aXNpYmxlTGlua3MiLCJTZXQiLCJvYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiaGFuZGxlSW50ZXJzZWN0Iiwicm9vdE1hcmdpbiIsImVsZW1lbnQiLCJocmVmIiwicm91dGVyIiwia2luZCIsInByZWZldGNoVXJsIiwiY3JlYXRlUHJlZmV0Y2hVUkwiLCJyZXBvcnRFcnJvckZuIiwicmVwb3J0RXJyb3IiLCJjb25zb2xlIiwiZXJyb3IiLCJpbnN0YW5jZSIsInByZWZldGNoSHJlZiIsImlzVmlzaWJsZSIsIndhc0hvdmVyZWRPclRvdWNoZWQiLCJwcmVmZXRjaFRhc2siLCJjYWNoZVZlcnNpb24iLCJleGlzdGluZ0luc3RhbmNlIiwiZ2V0IiwidW5kZWZpbmVkIiwic2V0Iiwib2JzZXJ2ZSIsImRlbGV0ZSIsImNhbmNlbFByZWZldGNoVGFzayIsInVub2JzZXJ2ZSIsImVudHJpZXMiLCJlbnRyeSIsImludGVyc2VjdGlvblJhdGlvIiwidGFyZ2V0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiYWRkIiwicmVzY2hlZHVsZUxpbmtQcmVmZXRjaCIsImV4aXN0aW5nUHJlZmV0Y2hUYXNrIiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwicHJlZmV0Y2hXaXRoT2xkQ2FjaGVJbXBsZW1lbnRhdGlvbiIsInByaW9yaXR5IiwiUHJlZmV0Y2hQcmlvcml0eSIsIkludGVudCIsIkRlZmF1bHQiLCJhcHBSb3V0ZXJTdGF0ZSIsImdldEN1cnJlbnRBcHBSb3V0ZXJTdGF0ZSIsIm5leHRVcmwiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsInRyZWUiLCJjYWNoZUtleSIsImNyZWF0ZUNhY2hlS2V5Iiwic2NoZWR1bGVTZWdtZW50UHJlZmV0Y2hUYXNrIiwiUHJlZmV0Y2hLaW5kIiwiRlVMTCIsImdldEN1cnJlbnRDYWNoZVZlcnNpb24iLCJidW1wUHJlZmV0Y2hUYXNrIiwiY3VycmVudENhY2hlVmVyc2lvbiIsInRhc2siLCJrZXkiLCJ3aW5kb3ciLCJkb1ByZWZldGNoIiwicHJlZmV0Y2giLCJjYXRjaCIsImVyciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/links.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay.js ***!
  \*******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AppDevOverlay\", ({\n    enumerable: true,\n    get: function() {\n        return AppDevOverlay;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _appdevoverlayerrorboundary = __webpack_require__(/*! ./app-dev-overlay-error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay-error-boundary.js\");\nconst _fontstyles = __webpack_require__(/*! ../font/font-styles */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/font/font-styles.js\");\nconst _devoverlay = __webpack_require__(/*! ../ui/dev-overlay */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/ui/dev-overlay.js\");\nconst _useerrorhandler = __webpack_require__(/*! ../../errors/use-error-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/use-error-handler.js\");\nconst _isnextroutererror = __webpack_require__(/*! ../../is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nfunction readSsrError() {\n    if (typeof document === 'undefined') {\n        return null;\n    }\n    const ssrErrorTemplateTag = document.querySelector('template[data-next-error-message]');\n    if (ssrErrorTemplateTag) {\n        const message = ssrErrorTemplateTag.getAttribute('data-next-error-message');\n        const stack = ssrErrorTemplateTag.getAttribute('data-next-error-stack');\n        const digest = ssrErrorTemplateTag.getAttribute('data-next-error-digest');\n        const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n        if (digest) {\n            ;\n            error.digest = digest;\n        }\n        // Skip Next.js SSR'd internal errors that which will be handled by the error boundaries.\n        if ((0, _isnextroutererror.isNextRouterError)(error)) {\n            return null;\n        }\n        error.stack = stack || '';\n        return error;\n    }\n    return null;\n}\n// Needs to be in the same error boundary as the shell.\n// If it commits, we know we recovered from an SSR error.\n// If it doesn't commit, we errored again and React will take care of error reporting.\nfunction ReplaySsrOnlyErrors() {\n    if (true) {\n        // Need to read during render. The attributes will be gone after commit.\n        const ssrError = readSsrError();\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            if (ssrError !== null) {\n                // TODO(veil): Produces wrong Owner Stack\n                // TODO(veil): Mark as recoverable error\n                // TODO(veil): console.error\n                (0, _useerrorhandler.handleClientError)(ssrError, []);\n            }\n        }, [\n            ssrError\n        ]);\n    }\n    return null;\n}\n_c = ReplaySsrOnlyErrors;\nfunction AppDevOverlay(param) {\n    let { state, globalError, children } = param;\n    const [isErrorOverlayOpen, setIsErrorOverlayOpen] = (0, _react.useState)(false);\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)(_appdevoverlayerrorboundary.AppDevOverlayErrorBoundary, {\n                globalError: globalError,\n                onError: setIsErrorOverlayOpen,\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(ReplaySsrOnlyErrors, {}),\n                    children\n                ]\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_fontstyles.FontStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_devoverlay.DevOverlay, {\n                state: state,\n                isErrorOverlayOpen: isErrorOverlayOpen,\n                setIsErrorOverlayOpen: setIsErrorOverlayOpen\n            })\n        ]\n    });\n}\n_c1 = AppDevOverlay;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-dev-overlay.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"ReplaySsrOnlyErrors\");\n$RefreshReg$(_c1, \"AppDevOverlay\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvYXBwL2FwcC1kZXYtb3ZlcmxheS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQTREZ0JBOzs7ZUFBQUE7Ozs7bUNBekRvQjt3REFDTzt3Q0FDaEI7d0NBQ0E7NkNBQ087K0NBQ0E7QUFFbEMsU0FBU0M7SUFDUCxJQUFJLE9BQU9DLGFBQWEsYUFBYTtRQUNuQyxPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxzQkFBc0JELFNBQVNFLGFBQWEsQ0FDaEQ7SUFFRixJQUFJRCxxQkFBcUI7UUFDdkIsTUFBTUUsVUFBa0JGLG9CQUFvQkcsWUFBWSxDQUN0RDtRQUVGLE1BQU1DLFFBQVFKLG9CQUFvQkcsWUFBWSxDQUFDO1FBQy9DLE1BQU1FLFNBQVNMLG9CQUFvQkcsWUFBWSxDQUFDO1FBQ2hELE1BQU1HLFFBQVEscUJBQWtCLENBQWxCLElBQUlDLE1BQU1MLFVBQVY7bUJBQUE7d0JBQUE7MEJBQUE7UUFBaUI7UUFDL0IsSUFBSUcsUUFBUTs7WUFDUkMsTUFBY0QsTUFBTSxHQUFHQTtRQUMzQjtRQUNBLHlGQUF5RjtRQUN6RixJQUFJRyxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCRixRQUFRO1lBQzVCLE9BQU87UUFDVDtRQUNBQSxNQUFNRixLQUFLLEdBQUdBLFNBQVM7UUFDdkIsT0FBT0U7SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVBLHVEQUF1RDtBQUN2RCx5REFBeUQ7QUFDekQsc0ZBQXNGO0FBQ3RGO0lBQ0UsSUFBSUksSUFBb0IsRUFBbUI7UUFDekMsd0VBQXdFO1FBQ3hFLE1BQU1HLFdBQVdmO1FBQ2pCLHNEQUFzRDtRQUN0RGdCLENBQUFBLEdBQUFBLE9BQUFBLFNBQUFBLEVBQVU7WUFDUixJQUFJRCxhQUFhLE1BQU07Z0JBQ3JCLHlDQUF5QztnQkFDekMsd0NBQXdDO2dCQUN4Qyw0QkFBNEI7Z0JBQzVCRSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQWtCRixVQUFVLEVBQUU7WUFDaEM7UUFDRixHQUFHO1lBQUNBO1NBQVM7SUFDZjtJQUVBLE9BQU87QUFDVDtLQWhCU0o7QUFrQkYsdUJBQXVCLEtBUTdCO0lBUjZCLE1BQzVCTyxLQUFLLEVBQ0xDLFdBQVcsRUFDWEMsUUFBUSxFQUtULEdBUjZCO0lBUzVCLE1BQU0sQ0FBQ0Msb0JBQW9CQyxzQkFBc0IsR0FBR0MsQ0FBQUEsR0FBQUEsT0FBQUEsUUFBQUEsRUFBUztJQUU3RCxxQkFDRTs7MEJBQ0Usc0JBQUNDLDRCQUFBQSwwQkFBMEI7Z0JBQ3pCTCxhQUFhQTtnQkFDYk0sU0FBU0g7O2tDQUVULHFCQUFDWCxxQkFBQUEsQ0FBQUE7b0JBQ0FTOzs7MEJBSUgscUJBQUNNLFlBQUFBLFVBQVU7MEJBQ1gscUJBQUNDLFlBQUFBLFVBQVU7Z0JBQ1RULE9BQU9BO2dCQUNQRyxvQkFBb0JBO2dCQUNwQkMsdUJBQXVCQTs7OztBQUkvQjtNQTlCZ0J2QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccmVhY3QtZGV2LW92ZXJsYXlcXGFwcFxcYXBwLWRldi1vdmVybGF5LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE92ZXJsYXlTdGF0ZSB9IGZyb20gJy4uL3NoYXJlZCdcbmltcG9ydCB0eXBlIHsgR2xvYmFsRXJyb3JDb21wb25lbnQgfSBmcm9tICcuLi8uLi9lcnJvci1ib3VuZGFyeSdcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkgfSBmcm9tICcuL2FwcC1kZXYtb3ZlcmxheS1lcnJvci1ib3VuZGFyeSdcbmltcG9ydCB7IEZvbnRTdHlsZXMgfSBmcm9tICcuLi9mb250L2ZvbnQtc3R5bGVzJ1xuaW1wb3J0IHsgRGV2T3ZlcmxheSB9IGZyb20gJy4uL3VpL2Rldi1vdmVybGF5J1xuaW1wb3J0IHsgaGFuZGxlQ2xpZW50RXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMvdXNlLWVycm9yLWhhbmRsZXInXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4uLy4uL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuXG5mdW5jdGlvbiByZWFkU3NyRXJyb3IoKTogRXJyb3IgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3Qgc3NyRXJyb3JUZW1wbGF0ZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgJ3RlbXBsYXRlW2RhdGEtbmV4dC1lcnJvci1tZXNzYWdlXSdcbiAgKVxuICBpZiAoc3NyRXJyb3JUZW1wbGF0ZVRhZykge1xuICAgIGNvbnN0IG1lc3NhZ2U6IHN0cmluZyA9IHNzckVycm9yVGVtcGxhdGVUYWcuZ2V0QXR0cmlidXRlKFxuICAgICAgJ2RhdGEtbmV4dC1lcnJvci1tZXNzYWdlJ1xuICAgICkhXG4gICAgY29uc3Qgc3RhY2sgPSBzc3JFcnJvclRlbXBsYXRlVGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWVycm9yLXN0YWNrJylcbiAgICBjb25zdCBkaWdlc3QgPSBzc3JFcnJvclRlbXBsYXRlVGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWVycm9yLWRpZ2VzdCcpXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICBpZiAoZGlnZXN0KSB7XG4gICAgICA7KGVycm9yIGFzIGFueSkuZGlnZXN0ID0gZGlnZXN0XG4gICAgfVxuICAgIC8vIFNraXAgTmV4dC5qcyBTU1InZCBpbnRlcm5hbCBlcnJvcnMgdGhhdCB3aGljaCB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgaWYgKGlzTmV4dFJvdXRlckVycm9yKGVycm9yKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgZXJyb3Iuc3RhY2sgPSBzdGFjayB8fCAnJ1xuICAgIHJldHVybiBlcnJvclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuLy8gTmVlZHMgdG8gYmUgaW4gdGhlIHNhbWUgZXJyb3IgYm91bmRhcnkgYXMgdGhlIHNoZWxsLlxuLy8gSWYgaXQgY29tbWl0cywgd2Uga25vdyB3ZSByZWNvdmVyZWQgZnJvbSBhbiBTU1IgZXJyb3IuXG4vLyBJZiBpdCBkb2Vzbid0IGNvbW1pdCwgd2UgZXJyb3JlZCBhZ2FpbiBhbmQgUmVhY3Qgd2lsbCB0YWtlIGNhcmUgb2YgZXJyb3IgcmVwb3J0aW5nLlxuZnVuY3Rpb24gUmVwbGF5U3NyT25seUVycm9ycygpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBOZWVkIHRvIHJlYWQgZHVyaW5nIHJlbmRlci4gVGhlIGF0dHJpYnV0ZXMgd2lsbCBiZSBnb25lIGFmdGVyIGNvbW1pdC5cbiAgICBjb25zdCBzc3JFcnJvciA9IHJlYWRTc3JFcnJvcigpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChzc3JFcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPKHZlaWwpOiBQcm9kdWNlcyB3cm9uZyBPd25lciBTdGFja1xuICAgICAgICAvLyBUT0RPKHZlaWwpOiBNYXJrIGFzIHJlY292ZXJhYmxlIGVycm9yXG4gICAgICAgIC8vIFRPRE8odmVpbCk6IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgaGFuZGxlQ2xpZW50RXJyb3Ioc3NyRXJyb3IsIFtdKVxuICAgICAgfVxuICAgIH0sIFtzc3JFcnJvcl0pXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gQXBwRGV2T3ZlcmxheSh7XG4gIHN0YXRlLFxuICBnbG9iYWxFcnJvcixcbiAgY2hpbGRyZW4sXG59OiB7XG4gIHN0YXRlOiBPdmVybGF5U3RhdGVcbiAgZ2xvYmFsRXJyb3I6IFtHbG9iYWxFcnJvckNvbXBvbmVudCwgUmVhY3QuUmVhY3ROb2RlXVxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG59KSB7XG4gIGNvbnN0IFtpc0Vycm9yT3ZlcmxheU9wZW4sIHNldElzRXJyb3JPdmVybGF5T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8QXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnlcbiAgICAgICAgZ2xvYmFsRXJyb3I9e2dsb2JhbEVycm9yfVxuICAgICAgICBvbkVycm9yPXtzZXRJc0Vycm9yT3ZlcmxheU9wZW59XG4gICAgICA+XG4gICAgICAgIDxSZXBsYXlTc3JPbmx5RXJyb3JzIC8+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnk+XG5cbiAgICAgIHsvKiBGb250cyBjYW4gb25seSBiZSBsb2FkZWQgb3V0c2lkZSB0aGUgU2hhZG93IERPTS4gKi99XG4gICAgICA8Rm9udFN0eWxlcyAvPlxuICAgICAgPERldk92ZXJsYXlcbiAgICAgICAgc3RhdGU9e3N0YXRlfVxuICAgICAgICBpc0Vycm9yT3ZlcmxheU9wZW49e2lzRXJyb3JPdmVybGF5T3Blbn1cbiAgICAgICAgc2V0SXNFcnJvck92ZXJsYXlPcGVuPXtzZXRJc0Vycm9yT3ZlcmxheU9wZW59XG4gICAgICAvPlxuICAgIDwvPlxuICApXG59XG4iXSwibmFtZXMiOlsiQXBwRGV2T3ZlcmxheSIsInJlYWRTc3JFcnJvciIsImRvY3VtZW50Iiwic3NyRXJyb3JUZW1wbGF0ZVRhZyIsInF1ZXJ5U2VsZWN0b3IiLCJtZXNzYWdlIiwiZ2V0QXR0cmlidXRlIiwic3RhY2siLCJkaWdlc3QiLCJlcnJvciIsIkVycm9yIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJSZXBsYXlTc3JPbmx5RXJyb3JzIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwic3NyRXJyb3IiLCJ1c2VFZmZlY3QiLCJoYW5kbGVDbGllbnRFcnJvciIsInN0YXRlIiwiZ2xvYmFsRXJyb3IiLCJjaGlsZHJlbiIsImlzRXJyb3JPdmVybGF5T3BlbiIsInNldElzRXJyb3JPdmVybGF5T3BlbiIsInVzZVN0YXRlIiwiQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkiLCJvbkVycm9yIiwiRm9udFN0eWxlcyIsIkRldk92ZXJsYXkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/utils/dev-indicator/use-sync-dev-render-indicator.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/utils/dev-indicator/use-sync-dev-render-indicator.js ***!
  \*************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useSyncDevRenderIndicator\", ({\n    enumerable: true,\n    get: function() {\n        return useSyncDevRenderIndicator;\n    }\n}));\nconst NOOP = (fn)=>fn();\n_c = NOOP;\nconst useSyncDevRenderIndicator = ()=>{\n    let syncDevRenderIndicator = NOOP;\n    if (true) {\n        const { useSyncDevRenderIndicatorInternal } = __webpack_require__(/*! ./use-sync-dev-render-indicator-internal */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/utils/dev-indicator/use-sync-dev-render-indicator-internal.js\");\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        syncDevRenderIndicator = useSyncDevRenderIndicatorInternal();\n    }\n    return syncDevRenderIndicator;\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-sync-dev-render-indicator.js.map\nvar _c;\n$RefreshReg$(_c, \"NOOP\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvdXRpbHMvZGV2LWluZGljYXRvci91c2Utc3luYy1kZXYtcmVuZGVyLWluZGljYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7OzZEQU9hQTs7O2VBQUFBOzs7QUFQYixNQUFNQyxPQUFPLENBQUNDLEtBQW1CQTs7QUFPMUIsTUFBTUYsNEJBQTRCO0lBQ3ZDLElBQUlHLHlCQUF5QkY7SUFFN0IsSUFBSUcsSUFBb0IsRUFBb0I7UUFDMUMsTUFBTSxFQUFFRyxpQ0FBaUMsRUFBRSxHQUN6Q0MsbUJBQU9BLENBQUMsZ01BQTBDO1FBRXBELHNEQUFzRDtRQUN0REwseUJBQXlCSTtJQUMzQjtJQUVBLE9BQU9KO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccmVhY3QtZGV2LW92ZXJsYXlcXHV0aWxzXFxkZXYtaW5kaWNhdG9yXFx1c2Utc3luYy1kZXYtcmVuZGVyLWluZGljYXRvci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTk9PUCA9IChmbjogKCkgPT4gdm9pZCkgPT4gZm4oKVxuXG4vKipcbiAqIFJldHVybnMgYSB0cmFuc2l0aW9uIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gd3JhcCByb3V0ZXIgYWN0aW9ucy5cbiAqIFRoaXMgYWxsb3dzIHVzIHRvIHRhcCBpbnRvIHRoZSB0cmFuc2l0aW9uIHN0YXRlIG9mIHRoZSByb3V0ZXIgYXMgYW5cbiAqIGFwcHJveGltYXRpb24gb2YgUmVhY3QgcmVuZGVyIHRpbWUuXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VTeW5jRGV2UmVuZGVySW5kaWNhdG9yID0gKCkgPT4ge1xuICBsZXQgc3luY0RldlJlbmRlckluZGljYXRvciA9IE5PT1BcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBjb25zdCB7IHVzZVN5bmNEZXZSZW5kZXJJbmRpY2F0b3JJbnRlcm5hbCB9ID1cbiAgICAgIHJlcXVpcmUoJy4vdXNlLXN5bmMtZGV2LXJlbmRlci1pbmRpY2F0b3ItaW50ZXJuYWwnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3VzZS1zeW5jLWRldi1yZW5kZXItaW5kaWNhdG9yLWludGVybmFsJylcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHN5bmNEZXZSZW5kZXJJbmRpY2F0b3IgPSB1c2VTeW5jRGV2UmVuZGVySW5kaWNhdG9ySW50ZXJuYWwoKVxuICB9XG5cbiAgcmV0dXJuIHN5bmNEZXZSZW5kZXJJbmRpY2F0b3Jcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTeW5jRGV2UmVuZGVySW5kaWNhdG9yIiwiTk9PUCIsImZuIiwic3luY0RldlJlbmRlckluZGljYXRvciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInVzZVN5bmNEZXZSZW5kZXJJbmRpY2F0b3JJbnRlcm5hbCIsInJlcXVpcmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/utils/dev-indicator/use-sync-dev-render-indicator.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createInitialRouterState\", ({\n    enumerable: true,\n    get: function() {\n        return createInitialRouterState;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _computechangedpath = __webpack_require__(/*! ./compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ./prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ./refetch-inactive-parallel-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nfunction createInitialRouterState(param) {\n    let { initialFlightData, initialCanonicalUrlParts, initialParallelRoutes, location, couldBeIntercepted, postponed, prerendered } = param;\n    // When initialized on the server, the canonical URL is provided as an array of parts.\n    // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n    // as a URL that should be crawled.\n    const initialCanonicalUrl = initialCanonicalUrlParts.join('/');\n    const normalizedFlightData = (0, _flightdatahelpers.getFlightDataPartsFromPath)(initialFlightData[0]);\n    const { tree: initialTree, seedData: initialSeedData, head: initialHead } = normalizedFlightData;\n    // For the SSR render, seed data should always be available (we only send back a `null` response\n    // in the case of a `loading` segment, pre-PPR.)\n    const rsc = initialSeedData == null ? void 0 : initialSeedData[1];\n    var _initialSeedData_;\n    const loading = (_initialSeedData_ = initialSeedData == null ? void 0 : initialSeedData[3]) != null ? _initialSeedData_ : null;\n    const cache = {\n        lazyData: null,\n        rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: initialParallelRoutes,\n        loading\n    };\n    const canonicalUrl = // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location ? (0, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl;\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(initialTree, canonicalUrl);\n    const prefetchCache = new Map();\n    // When the cache hasn't been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, initialTree, initialSeedData, initialHead, undefined);\n    }\n    var _ref;\n    const initialState = {\n        tree: initialTree,\n        cache,\n        prefetchCache,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // First render needs to preserve the previous window.history.state\n            // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: {\n            apply: false,\n            onlyHashChange: false,\n            hashFragment: null,\n            segmentPaths: []\n        },\n        canonicalUrl,\n        nextUrl: (_ref = (0, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null\n    };\n    if (false) {}\n    return initialState;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-initial-router-state.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLWluaXRpYWwtcm91dGVyLXN0YXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7NERBcUJnQkE7OztlQUFBQTs7OytDQWxCa0I7MkRBQ1k7Z0RBQ0c7Z0RBQ0Y7Z0RBQ087NkRBQ0c7K0NBQ2Q7QUFZcEMsU0FBU0EseUJBQXlCLEtBUVY7SUFSVSxNQUN2Q0MsaUJBQWlCLEVBQ2pCQyx3QkFBd0IsRUFDeEJDLHFCQUFxQixFQUNyQkMsUUFBUSxFQUNSQyxrQkFBa0IsRUFDbEJDLFNBQVMsRUFDVEMsV0FBVyxFQUNrQixHQVJVO0lBU3ZDLHNGQUFzRjtJQUN0RixrR0FBa0c7SUFDbEcsbUNBQW1DO0lBQ25DLE1BQU1DLHNCQUFzQk4seUJBQXlCTyxJQUFJLENBQUM7SUFDMUQsTUFBTUMsdUJBQXVCQyxDQUFBQSxHQUFBQSxtQkFBQUEsMEJBQUFBLEVBQTJCVixpQkFBaUIsQ0FBQyxFQUFFO0lBQzVFLE1BQU0sRUFDSlcsTUFBTUMsV0FBVyxFQUNqQkMsVUFBVUMsZUFBZSxFQUN6QkMsTUFBTUMsV0FBVyxFQUNsQixHQUFHUDtJQUNKLGdHQUFnRztJQUNoRyxnREFBZ0Q7SUFDaEQsTUFBTVEsTUFBTUgsbUJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLGVBQWlCLENBQUMsRUFBRTtRQUNoQkE7SUFBaEIsTUFBTUksVUFBVUoscUJBQUFBLG1CQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxlQUFpQixDQUFDLEVBQUUsWUFBcEJBLG9CQUF3QjtJQUV4QyxNQUFNSyxRQUFtQjtRQUN2QkMsVUFBVTtRQUNWSDtRQUNBSSxhQUFhO1FBQ2JOLE1BQU07UUFDTk8sY0FBYztRQUNkLG9KQUFvSjtRQUNwSkMsZ0JBQWdCckI7UUFDaEJnQjtJQUNGO0lBRUEsTUFBTU0sZUFFSixrSkFBa0o7SUFDbEpyQixXQUVJc0IsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQnRCLFlBQ2xCSTtJQUVObUIsQ0FBQUEsR0FBQUEsaUNBQUFBLHdDQUFBQSxFQUF5Q2QsYUFBYVk7SUFFdEQsTUFBTUcsZ0JBQWdCLElBQUlDO0lBRTFCLHlFQUF5RTtJQUN6RSxJQUFJMUIsMEJBQTBCLFFBQVFBLHNCQUFzQjJCLElBQUksS0FBSyxHQUFHO1FBQ3RFQyxDQUFBQSxHQUFBQSwrQkFBQUEsNkJBQUFBLEVBQ0VYLE9BQ0FZLFdBQ0FuQixhQUNBRSxpQkFDQUUsYUFDQWU7SUFFSjtRQXFCSTtJQW5CSixNQUFNRSxlQUFlO1FBQ25CdEIsTUFBTUM7UUFDTk87UUFDQVE7UUFDQU8sU0FBUztZQUNQQyxhQUFhO1lBQ2JDLGVBQWU7WUFDZixtRUFBbUU7WUFDbkUsZ0ZBQWdGO1lBQ2hGQyw0QkFBNEI7UUFDOUI7UUFDQUMsbUJBQW1CO1lBQ2pCQyxPQUFPO1lBQ1BDLGdCQUFnQjtZQUNoQkMsY0FBYztZQUNkQyxjQUFjLEVBQUU7UUFDbEI7UUFDQWxCO1FBQ0FtQixTQUVFLENBQUNYLE9BQUFBLENBQUFBLEdBQUFBLG9CQUFBQSxnQ0FBQUEsRUFBaUNwQixpQkFBZ0JULFlBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFNBQVV5QyxRQUFBQSxNQUFRLE9BQW5FWixPQUNEO0lBQ0o7SUFFQSxJQUFJYSxLQUFrRDFDLEVBQUUsRUFpQ3ZEO0lBRUQsT0FBTzhCO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxcY3JlYXRlLWluaXRpYWwtcm91dGVyLXN0YXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEZsaWdodERhdGFQYXRoIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5cbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIH0gZnJvbSAnLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZCdcbmltcG9ydCB7IGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB7IGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSB9IGZyb20gJy4vcHJlZmV0Y2gtY2FjaGUtdXRpbHMnXG5pbXBvcnQgeyBQcmVmZXRjaEtpbmQsIHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5IH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMgfSBmcm9tICcuL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHMnXG5pbXBvcnQgeyBnZXRGbGlnaHREYXRhUGFydHNGcm9tUGF0aCB9IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdGlhbFJvdXRlclN0YXRlUGFyYW1ldGVycyB7XG4gIGluaXRpYWxDYW5vbmljYWxVcmxQYXJ0czogc3RyaW5nW11cbiAgaW5pdGlhbFBhcmFsbGVsUm91dGVzOiBDYWNoZU5vZGVbJ3BhcmFsbGVsUm91dGVzJ11cbiAgaW5pdGlhbEZsaWdodERhdGE6IEZsaWdodERhdGFQYXRoW11cbiAgbG9jYXRpb246IExvY2F0aW9uIHwgbnVsbFxuICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGJvb2xlYW5cbiAgcG9zdHBvbmVkOiBib29sZWFuXG4gIHByZXJlbmRlcmVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUoe1xuICBpbml0aWFsRmxpZ2h0RGF0YSxcbiAgaW5pdGlhbENhbm9uaWNhbFVybFBhcnRzLFxuICBpbml0aWFsUGFyYWxsZWxSb3V0ZXMsXG4gIGxvY2F0aW9uLFxuICBjb3VsZEJlSW50ZXJjZXB0ZWQsXG4gIHBvc3Rwb25lZCxcbiAgcHJlcmVuZGVyZWQsXG59OiBJbml0aWFsUm91dGVyU3RhdGVQYXJhbWV0ZXJzKSB7XG4gIC8vIFdoZW4gaW5pdGlhbGl6ZWQgb24gdGhlIHNlcnZlciwgdGhlIGNhbm9uaWNhbCBVUkwgaXMgcHJvdmlkZWQgYXMgYW4gYXJyYXkgb2YgcGFydHMuXG4gIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgd2hlbiB0aGUgUlNDIHBheWxvYWQgc3RyZWFtZWQgdG8gdGhlIGNsaWVudCwgY3Jhd2xlcnMgZG9uJ3QgaW50ZXJwcmV0IGl0XG4gIC8vIGFzIGEgVVJMIHRoYXQgc2hvdWxkIGJlIGNyYXdsZWQuXG4gIGNvbnN0IGluaXRpYWxDYW5vbmljYWxVcmwgPSBpbml0aWFsQ2Fub25pY2FsVXJsUGFydHMuam9pbignLycpXG4gIGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhID0gZ2V0RmxpZ2h0RGF0YVBhcnRzRnJvbVBhdGgoaW5pdGlhbEZsaWdodERhdGFbMF0pXG4gIGNvbnN0IHtcbiAgICB0cmVlOiBpbml0aWFsVHJlZSxcbiAgICBzZWVkRGF0YTogaW5pdGlhbFNlZWREYXRhLFxuICAgIGhlYWQ6IGluaXRpYWxIZWFkLFxuICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcbiAgLy8gRm9yIHRoZSBTU1IgcmVuZGVyLCBzZWVkIGRhdGEgc2hvdWxkIGFsd2F5cyBiZSBhdmFpbGFibGUgKHdlIG9ubHkgc2VuZCBiYWNrIGEgYG51bGxgIHJlc3BvbnNlXG4gIC8vIGluIHRoZSBjYXNlIG9mIGEgYGxvYWRpbmdgIHNlZ21lbnQsIHByZS1QUFIuKVxuICBjb25zdCByc2MgPSBpbml0aWFsU2VlZERhdGE/LlsxXVxuICBjb25zdCBsb2FkaW5nID0gaW5pdGlhbFNlZWREYXRhPy5bM10gPz8gbnVsbFxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjLFxuICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgIGhlYWQ6IG51bGwsXG4gICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgIC8vIFRoZSBjYWNoZSBnZXRzIHNlZWRlZCBkdXJpbmcgdGhlIGZpcnN0IHJlbmRlci4gYGluaXRpYWxQYXJhbGxlbFJvdXRlc2AgZW5zdXJlcyB0aGUgY2FjaGUgZnJvbSB0aGUgZmlyc3QgcmVuZGVyIGlzIHRoZXJlIGR1cmluZyB0aGUgc2Vjb25kIHJlbmRlci5cbiAgICBwYXJhbGxlbFJvdXRlczogaW5pdGlhbFBhcmFsbGVsUm91dGVzLFxuICAgIGxvYWRpbmcsXG4gIH1cblxuICBjb25zdCBjYW5vbmljYWxVcmwgPVxuICAgIC8vIGxvY2F0aW9uLmhyZWYgaXMgcmVhZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgY2Fub25pY2FsVXJsIGluIHRoZSBicm93c2VyXG4gICAgLy8gVGhpcyBpcyBzYWZlIHRvIGRvIGFzIGNhbm9uaWNhbFVybCBjYW4ndCBiZSByZW5kZXJlZCwgaXQncyBvbmx5IHVzZWQgdG8gY29udHJvbCB0aGUgaGlzdG9yeSB1cGRhdGVzIGluIHRoZSB1c2VFZmZlY3QgZnVydGhlciBkb3duIGluIHRoaXMgZmlsZS5cbiAgICBsb2NhdGlvblxuICAgICAgPyAvLyB3aW5kb3cubG9jYXRpb24gZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIFVSTCBidXQgaGFzIGFsbCB0aGUgZmllbGRzIGNyZWF0ZUhyZWZGcm9tVXJsIG5lZWRzLlxuICAgICAgICBjcmVhdGVIcmVmRnJvbVVybChsb2NhdGlvbilcbiAgICAgIDogaW5pdGlhbENhbm9uaWNhbFVybFxuXG4gIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMoaW5pdGlhbFRyZWUsIGNhbm9uaWNhbFVybClcblxuICBjb25zdCBwcmVmZXRjaENhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFByZWZldGNoQ2FjaGVFbnRyeT4oKVxuXG4gIC8vIFdoZW4gdGhlIGNhY2hlIGhhc24ndCBiZWVuIHNlZWRlZCB5ZXQgd2UgZmlsbCB0aGUgY2FjaGUgd2l0aCB0aGUgaGVhZC5cbiAgaWYgKGluaXRpYWxQYXJhbGxlbFJvdXRlcyA9PT0gbnVsbCB8fCBpbml0aWFsUGFyYWxsZWxSb3V0ZXMuc2l6ZSA9PT0gMCkge1xuICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgY2FjaGUsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBpbml0aWFsVHJlZSxcbiAgICAgIGluaXRpYWxTZWVkRGF0YSxcbiAgICAgIGluaXRpYWxIZWFkLFxuICAgICAgdW5kZWZpbmVkXG4gICAgKVxuICB9XG5cbiAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIHRyZWU6IGluaXRpYWxUcmVlLFxuICAgIGNhY2hlLFxuICAgIHByZWZldGNoQ2FjaGUsXG4gICAgcHVzaFJlZjoge1xuICAgICAgcGVuZGluZ1B1c2g6IGZhbHNlLFxuICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAvLyBGaXJzdCByZW5kZXIgbmVlZHMgdG8gcHJlc2VydmUgdGhlIHByZXZpb3VzIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgICAvLyB0byBhdm9pZCBpdCBiZWluZyBvdmVyd3JpdHRlbiBvbiBuYXZpZ2F0aW9uIGJhY2svZm9yd2FyZCB3aXRoIE1QQSBOYXZpZ2F0aW9uLlxuICAgICAgcHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGU6IHRydWUsXG4gICAgfSxcbiAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgYXBwbHk6IGZhbHNlLFxuICAgICAgb25seUhhc2hDaGFuZ2U6IGZhbHNlLFxuICAgICAgaGFzaEZyYWdtZW50OiBudWxsLFxuICAgICAgc2VnbWVudFBhdGhzOiBbXSxcbiAgICB9LFxuICAgIGNhbm9uaWNhbFVybCxcbiAgICBuZXh0VXJsOlxuICAgICAgLy8gdGhlIHx8IG9wZXJhdG9yIGlzIGludGVudGlvbmFsLCB0aGUgcGF0aG5hbWUgY2FuIGJlIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgKGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlKGluaXRpYWxUcmVlKSB8fCBsb2NhdGlvbj8ucGF0aG5hbWUpID8/XG4gICAgICBudWxsLFxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmIGxvY2F0aW9uKSB7XG4gICAgLy8gU2VlZCB0aGUgcHJlZmV0Y2ggY2FjaGUgd2l0aCB0aGlzIHBhZ2UncyBkYXRhLlxuICAgIC8vIFRoaXMgaXMgdG8gcHJldmVudCBuZWVkbGVzc2x5IHJlLXByZWZldGNoaW5nIGEgcGFnZSB0aGF0IGlzIGFscmVhZHkgcmV1c2FibGUsXG4gICAgLy8gYW5kIHdpbGwgYXZvaWQgdHJpZ2dlcmluZyBhIGxvYWRpbmcgc3RhdGUvZGF0YSBmZXRjaCBzdGFsbCB3aGVuIG5hdmlnYXRpbmcgYmFjayB0byB0aGUgcGFnZS5cbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgZG8gdGhpcyBpbiBkZXZlbG9wbWVudCBiZWNhdXNlIGxpbmtzIGFyZW4ndCBwcmVmZXRjaGVkIGluIGRldmVsb3BtZW50XG4gICAgLy8gc28gaGF2aW5nIGEgbWlzbWF0Y2ggYmV0d2VlbiBwcmVmZXRjaC9ubyBwcmVmZXRjaCBwcm92aWRlcyBpbmNvbnNpc3RlbnQgYmVoYXZpb3IgYmFzZWQgb24gd2hpY2ggcGFnZVxuICAgIC8vIHdhcyBsb2FkZWQgZmlyc3QuXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcbiAgICAgIGAke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofWAsXG4gICAgICBsb2NhdGlvbi5vcmlnaW5cbiAgICApXG5cbiAgICBjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgICAgdXJsLFxuICAgICAgZGF0YToge1xuICAgICAgICBmbGlnaHREYXRhOiBbbm9ybWFsaXplZEZsaWdodERhdGFdLFxuICAgICAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgY291bGRCZUludGVyY2VwdGVkOiAhIWNvdWxkQmVJbnRlcmNlcHRlZCxcbiAgICAgICAgcHJlcmVuZGVyZWQsXG4gICAgICAgIHBvc3Rwb25lZCxcbiAgICAgICAgLy8gVE9ETzogVGhlIGluaXRpYWwgUlNDIHBheWxvYWQgaW5jbHVkZXMgYm90aCBzdGF0aWMgYW5kIGR5bmFtaWMgZGF0YVxuICAgICAgICAvLyBpbiB0aGUgc2FtZSByZXNwb25zZSwgZXZlbiBpZiBQUFIgaXMgZW5hYmxlZC4gU28gaWYgdGhlcmUncyBhbnlcbiAgICAgICAgLy8gZHluYW1pYyBkYXRhIGF0IGFsbCwgd2UgY2FuJ3Qgc2V0IGEgc3RhbGUgdGltZS4gSW4gdGhlIGZ1dHVyZSB3ZSBtYXlcbiAgICAgICAgLy8gYWRkIGEgd2F5IHRvIHNwbGl0IGEgc2luZ2xlIEZsaWdodCBzdHJlYW0gaW50byBzdGF0aWMgYW5kIGR5bmFtaWNcbiAgICAgICAgLy8gcGFydHMuIEJ1dCBpbiB0aGUgbWVhbnRpbWUgd2Ugc2hvdWxkIGF0IGxlYXN0IG1ha2UgdGhpcyB3b3JrIGZvclxuICAgICAgICAvLyBmdWxseSBzdGF0aWMgcGFnZXMuXG4gICAgICAgIHN0YWxlVGltZTogLTEsXG4gICAgICB9LFxuICAgICAgdHJlZTogaW5pdGlhbFN0YXRlLnRyZWUsXG4gICAgICBwcmVmZXRjaENhY2hlOiBpbml0aWFsU3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgIG5leHRVcmw6IGluaXRpYWxTdGF0ZS5uZXh0VXJsLFxuICAgICAga2luZDogcHJlcmVuZGVyZWQgPyBQcmVmZXRjaEtpbmQuRlVMTCA6IFByZWZldGNoS2luZC5BVVRPLFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gaW5pdGlhbFN0YXRlXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIiwiaW5pdGlhbEZsaWdodERhdGEiLCJpbml0aWFsQ2Fub25pY2FsVXJsUGFydHMiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJsb2NhdGlvbiIsImNvdWxkQmVJbnRlcmNlcHRlZCIsInBvc3Rwb25lZCIsInByZXJlbmRlcmVkIiwiaW5pdGlhbENhbm9uaWNhbFVybCIsImpvaW4iLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsImdldEZsaWdodERhdGFQYXJ0c0Zyb21QYXRoIiwidHJlZSIsImluaXRpYWxUcmVlIiwic2VlZERhdGEiLCJpbml0aWFsU2VlZERhdGEiLCJoZWFkIiwiaW5pdGlhbEhlYWQiLCJyc2MiLCJsb2FkaW5nIiwiY2FjaGUiLCJsYXp5RGF0YSIsInByZWZldGNoUnNjIiwicHJlZmV0Y2hIZWFkIiwicGFyYWxsZWxSb3V0ZXMiLCJjYW5vbmljYWxVcmwiLCJjcmVhdGVIcmVmRnJvbVVybCIsImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwic2l6ZSIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwidW5kZWZpbmVkIiwiZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5Iiwib25seUhhc2hDaGFuZ2UiLCJoYXNoRnJhZ21lbnQiLCJzZWdtZW50UGF0aHMiLCJuZXh0VXJsIiwicGF0aG5hbWUiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJ1cmwiLCJVUkwiLCJzZWFyY2giLCJvcmlnaW4iLCJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJkYXRhIiwiZmxpZ2h0RGF0YSIsInN0YWxlVGltZSIsImtpbmQiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiQVVUTyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst _appcallserver = __webpack_require__(/*! ../../app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _appbuildid = __webpack_require__(/*! ../../app-build-id */ \"(app-pages-browser)/./node_modules/next/dist/client/app-build-id.js\");\nconst _setcachebustingsearchparam = __webpack_require__(/*! ./set-cache-busting-search-param */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js\");\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromReadableStream } from 'react-server-dom-webpack/client'\nconst { createFromReadableStream } =  false ? 0 : __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url, location.origin);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (false) {}\n    return urlWithoutFlightParameters;\n}\nfunction doMpaNavigation(url) {\n    return {\n        flightData: urlToUrlWithoutFlightMarker(url).toString(),\n        canonicalUrl: undefined,\n        couldBeIntercepted: false,\n        prerendered: false,\n        postponed: false,\n        staleTime: -1\n    };\n}\nlet abortController = new AbortController();\nif (true) {\n    // Abort any in-flight requests when the page is unloaded, e.g. due to\n    // reloading the page or performing hard navigations. This allows us to ignore\n    // what would otherwise be a thrown TypeError when the browser cancels the\n    // requests.\n    window.addEventListener('pagehide', ()=>{\n        abortController.abort();\n    });\n    // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n    // and the JavaScript execution context is restored by the browser.\n    window.addEventListener('pageshow', ()=>{\n        abortController = new AbortController();\n    });\n}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl, prefetchKind } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(JSON.stringify(flightRouterState))\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n    }\n    if ( true && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        var _res_headers_get;\n        // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n        // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n        // Otherwise, all other prefetches are sent with a \"low\" priority.\n        // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n        const fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';\n        if (false) {}\n        const res = await createFetch(url, headers, fetchPriority, abortController.signal);\n        const responseUrl = urlToUrlWithoutFlightMarker(res.url);\n        const canonicalUrl = res.redirected ? responseUrl : undefined;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!((_res_headers_get = res.headers.get('vary')) == null ? void 0 : _res_headers_get.includes(_approuterheaders.NEXT_URL));\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeader = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeader !== null ? parseInt(staleTimeHeader, 10) : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (false) {}\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        if (true) {\n            await (__webpack_require__(/*! ../react-dev-overlay/app/hot-reloader-client */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js\").waitForWebpackRuntimeHotUpdate)();\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n        const response = await createFromNextReadableStream(flightStream);\n        if ((0, _appbuildid.getAppBuildId)() !== response.b) {\n            return doMpaNavigation(res.url);\n        }\n        return {\n            flightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n            canonicalUrl: canonicalUrl,\n            couldBeIntercepted: interception,\n            prerendered: response.S,\n            postponed,\n            staleTime\n        };\n    } catch (err) {\n        if (!abortController.signal.aborted) {\n            console.error(\"Failed to fetch RSC payload for \" + url + \". Falling back to browser navigation.\", err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return {\n            flightData: url.toString(),\n            canonicalUrl: undefined,\n            couldBeIntercepted: false,\n            prerendered: false,\n            postponed: false,\n            staleTime: -1\n        };\n    }\n}\nfunction createFetch(url, headers, fetchPriority, signal) {\n    const fetchUrl = new URL(url);\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n    if (false) {}\n    if (false) {}\n    return fetch(fetchUrl, {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    });\n}\nfunction createFromNextReadableStream(flightStream) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQXVRZ0JBLFdBQVc7ZUFBWEE7O0lBOEJBQyw0QkFBNEI7ZUFBNUJBOztJQS9LTUMsbUJBQW1CO2VBQW5CQTs7SUFsRE5DLDJCQUEyQjtlQUEzQkE7Ozs4Q0F2Q1Q7MkNBQ29CO2lEQUNNO2dEQUNKOytDQUl0Qjt3Q0FDdUI7d0RBQ2E7QUFwQzNDLGFBQWE7QUFDYiw2REFBNkQ7QUFDN0QsNkVBQTZFO0FBQzdFLE1BQU0sRUFBRUMsd0JBQXdCLEVBQUUsR0FDaEMsTUFBMEIsR0FFdEJJLENBQStDLEdBRS9DQSxtQkFBT0EsQ0FBQyxpSUFBaUM7QUEwRHhDLFNBQVNMLDRCQUE0Qk0sR0FBVztJQUNyRCxNQUFNQyw2QkFBNkIsSUFBSUMsSUFBSUYsS0FBS0csU0FBU0MsTUFBTTtJQUMvREgsMkJBQTJCSSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0Msa0JBQUFBLG9CQUFvQjtJQUNuRSxJQUFJWCxLQUFvQixFQUFtQixFQVUxQztJQUNELE9BQU9LO0FBQ1Q7QUFFQSxTQUFTYSxnQkFBZ0JkLEdBQVc7SUFDbEMsT0FBTztRQUNMZSxZQUFZckIsNEJBQTRCTSxLQUFLZ0IsUUFBUTtRQUNyREMsY0FBY0M7UUFDZEMsb0JBQW9CO1FBQ3BCQyxhQUFhO1FBQ2JDLFdBQVc7UUFDWEMsV0FBVyxDQUFDO0lBQ2Q7QUFDRjtBQUVBLElBQUlDLGtCQUFrQixJQUFJQztBQUUxQixJQUFJLElBQTZCLEVBQUU7SUFDakMsc0VBQXNFO0lBQ3RFLDhFQUE4RTtJQUM5RSwwRUFBMEU7SUFDMUUsWUFBWTtJQUNaQyxPQUFPQyxnQkFBZ0IsQ0FBQyxZQUFZO1FBQ2xDSCxnQkFBZ0JJLEtBQUs7SUFDdkI7SUFFQSw4RUFBOEU7SUFDOUUsbUVBQW1FO0lBQ25FRixPQUFP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QUNGO0FBRUEsU0FBU25CLDhCQUNQb0Isb0JBQWdEO0lBRWhELDBFQUEwRTtJQUMxRSw0RUFBNEU7SUFDNUUsdUVBQXVFO0lBQ3ZFLDBFQUEwRTtJQUMxRSw4REFBOEQ7SUFDOUQsMkNBQTJDO0lBQzNDLEVBQUU7SUFDRiwyRUFBMkU7SUFDM0UsMEVBQTBFO0lBQzFFLDhFQUE4RTtJQUM5RSwrQkFBK0I7SUFDL0IsTUFBTUMsU0FBU0QscUJBQXFCRSxTQUFTO0lBQzdDLE9BQU8sSUFBSUMsZUFBZTtRQUN4QixNQUFNQyxNQUFLQyxVQUFVO1lBQ25CLE1BQU8sS0FBTTtnQkFDWCxNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTU4sT0FBT08sSUFBSTtnQkFDekMsSUFBSSxDQUFDRixNQUFNO29CQUNULG1FQUFtRTtvQkFDbkUsbUJBQW1CO29CQUNuQkQsV0FBV0ksT0FBTyxDQUFDRjtvQkFDbkI7Z0JBQ0Y7Z0JBQ0EscUVBQXFFO2dCQUNyRSxxQkFBcUI7Z0JBQ3JCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxcZmV0Y2gtc2VydmVyLXJlc3BvbnNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG4vLyBAdHMtaWdub3JlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4vLyBpbXBvcnQgeyBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0gfSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuY29uc3QgeyBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0gfSA9IChcbiAgISFwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUVcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbiAgICAgIHJlcXVpcmUoJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQuZWRnZScpXG4gICAgOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4gICAgICByZXF1aXJlKCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50JylcbikgYXMgdHlwZW9mIGltcG9ydCgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCcpXG5cbmltcG9ydCB0eXBlIHtcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG4gIE5hdmlnYXRpb25GbGlnaHRSZXNwb25zZSxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5cbmltcG9ydCB0eXBlIHsgTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIgfSBmcm9tICcuLi9hcHAtcm91dGVyLWhlYWRlcnMnXG5pbXBvcnQge1xuICBORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSLFxuICBORVhUX1JTQ19VTklPTl9RVUVSWSxcbiAgTkVYVF9VUkwsXG4gIFJTQ19IRUFERVIsXG4gIFJTQ19DT05URU5UX1RZUEVfSEVBREVSLFxuICBORVhUX0hNUl9SRUZSRVNIX0hFQURFUixcbiAgTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUixcbn0gZnJvbSAnLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHsgY2FsbFNlcnZlciB9IGZyb20gJy4uLy4uL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB7IGZpbmRTb3VyY2VNYXBVUkwgfSBmcm9tICcuLi8uLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybCdcbmltcG9ydCB7IFByZWZldGNoS2luZCB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQge1xuICBub3JtYWxpemVGbGlnaHREYXRhLFxuICB0eXBlIE5vcm1hbGl6ZWRGbGlnaHREYXRhLFxufSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgZ2V0QXBwQnVpbGRJZCB9IGZyb20gJy4uLy4uL2FwcC1idWlsZC1pZCdcbmltcG9ydCB7IHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIH0gZnJvbSAnLi9zZXQtY2FjaGUtYnVzdGluZy1zZWFyY2gtcGFyYW0nXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hTZXJ2ZXJSZXNwb25zZU9wdGlvbnMge1xuICByZWFkb25seSBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgcmVhZG9ubHkgbmV4dFVybDogc3RyaW5nIHwgbnVsbFxuICByZWFkb25seSBwcmVmZXRjaEtpbmQ/OiBQcmVmZXRjaEtpbmRcbiAgcmVhZG9ubHkgaXNIbXJSZWZyZXNoPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0ID0ge1xuICBmbGlnaHREYXRhOiBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdIHwgc3RyaW5nXG4gIGNhbm9uaWNhbFVybDogVVJMIHwgdW5kZWZpbmVkXG4gIGNvdWxkQmVJbnRlcmNlcHRlZDogYm9vbGVhblxuICBwcmVyZW5kZXJlZDogYm9vbGVhblxuICBwb3N0cG9uZWQ6IGJvb2xlYW5cbiAgc3RhbGVUaW1lOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgUmVxdWVzdEhlYWRlcnMgPSB7XG4gIFtSU0NfSEVBREVSXT86ICcxJ1xuICBbTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVJdPzogc3RyaW5nXG4gIFtORVhUX1VSTF0/OiBzdHJpbmdcbiAgW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0/OiAnMSdcbiAgW05FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSXT86IHN0cmluZ1xuICAneC1kZXBsb3ltZW50LWlkJz86IHN0cmluZ1xuICBbTkVYVF9ITVJfUkVGUkVTSF9IRUFERVJdPzogJzEnXG4gIC8vIEEgaGVhZGVyIHRoYXQgaXMgb25seSBhZGRlZCBpbiB0ZXN0IG1vZGUgdG8gYXNzZXJ0IG9uIGZldGNoIHByaW9yaXR5XG4gICdOZXh0LVRlc3QtRmV0Y2gtUHJpb3JpdHknPzogUmVxdWVzdEluaXRbJ3ByaW9yaXR5J11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcih1cmw6IHN0cmluZyk6IFVSTCB7XG4gIGNvbnN0IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbilcbiAgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMuc2VhcmNoUGFyYW1zLmRlbGV0ZShORVhUX1JTQ19VTklPTl9RVUVSWSlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcgJiZcbiAgICAgIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzLnBhdGhuYW1lLmVuZHNXaXRoKCcudHh0JylcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzXG4gICAgICBjb25zdCBsZW5ndGggPSBwYXRobmFtZS5lbmRzV2l0aCgnL2luZGV4LnR4dCcpID8gMTAgOiA0XG4gICAgICAvLyBTbGljZSBvZmYgYC9pbmRleC50eHRgIG9yIGAudHh0YCBmcm9tIHRoZSBlbmQgb2YgdGhlIHBhdGhuYW1lXG4gICAgICB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycy5wYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDAsIC1sZW5ndGgpXG4gICAgfVxuICB9XG4gIHJldHVybiB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVyc1xufVxuXG5mdW5jdGlvbiBkb01wYU5hdmlnYXRpb24odXJsOiBzdHJpbmcpOiBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0IHtcbiAgcmV0dXJuIHtcbiAgICBmbGlnaHREYXRhOiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIodXJsKS50b1N0cmluZygpLFxuICAgIGNhbm9uaWNhbFVybDogdW5kZWZpbmVkLFxuICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogZmFsc2UsXG4gICAgcHJlcmVuZGVyZWQ6IGZhbHNlLFxuICAgIHBvc3Rwb25lZDogZmFsc2UsXG4gICAgc3RhbGVUaW1lOiAtMSxcbiAgfVxufVxuXG5sZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBBYm9ydCBhbnkgaW4tZmxpZ2h0IHJlcXVlc3RzIHdoZW4gdGhlIHBhZ2UgaXMgdW5sb2FkZWQsIGUuZy4gZHVlIHRvXG4gIC8vIHJlbG9hZGluZyB0aGUgcGFnZSBvciBwZXJmb3JtaW5nIGhhcmQgbmF2aWdhdGlvbnMuIFRoaXMgYWxsb3dzIHVzIHRvIGlnbm9yZVxuICAvLyB3aGF0IHdvdWxkIG90aGVyd2lzZSBiZSBhIHRocm93biBUeXBlRXJyb3Igd2hlbiB0aGUgYnJvd3NlciBjYW5jZWxzIHRoZVxuICAvLyByZXF1ZXN0cy5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgKCkgPT4ge1xuICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gIH0pXG5cbiAgLy8gVXNlIGEgZnJlc2ggQWJvcnRDb250cm9sbGVyIGluc3RhbmNlIG9uIHBhZ2VzaG93LCBlLmcuIHdoZW4gbmF2aWdhdGluZyBiYWNrXG4gIC8vIGFuZCB0aGUgSmF2YVNjcmlwdCBleGVjdXRpb24gY29udGV4dCBpcyByZXN0b3JlZCBieSB0aGUgYnJvd3Nlci5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VzaG93JywgKCkgPT4ge1xuICAgIGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICB9KVxufVxuXG4vKipcbiAqIEZldGNoIHRoZSBmbGlnaHQgZGF0YSBmb3IgdGhlIHByb3ZpZGVkIHVybC4gVGFrZXMgaW4gdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gKiB0byBkZWNpZGUgd2hhdCB0byByZW5kZXIgc2VydmVyLXNpZGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFNlcnZlclJlc3BvbnNlKFxuICB1cmw6IFVSTCxcbiAgb3B0aW9uczogRmV0Y2hTZXJ2ZXJSZXNwb25zZU9wdGlvbnNcbik6IFByb21pc2U8RmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdD4ge1xuICBjb25zdCB7IGZsaWdodFJvdXRlclN0YXRlLCBuZXh0VXJsLCBwcmVmZXRjaEtpbmQgfSA9IG9wdGlvbnNcblxuICBjb25zdCBoZWFkZXJzOiBSZXF1ZXN0SGVhZGVycyA9IHtcbiAgICAvLyBFbmFibGUgZmxpZ2h0IHJlc3BvbnNlXG4gICAgW1JTQ19IRUFERVJdOiAnMScsXG4gICAgLy8gUHJvdmlkZSB0aGUgY3VycmVudCByb3V0ZXIgc3RhdGVcbiAgICBbTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVJdOiBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICBKU09OLnN0cmluZ2lmeShmbGlnaHRSb3V0ZXJTdGF0ZSlcbiAgICApLFxuICB9XG5cbiAgLyoqXG4gICAqIFRocmVlIGNhc2VzOlxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGB1bmRlZmluZWRgLCBpdCBtZWFucyBpdCdzIGEgbm9ybWFsIG5hdmlnYXRpb24sIHNvIHdlIHdhbnQgdG8gcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseVxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGBmdWxsYCAtIHdlIHdhbnQgdG8gcHJlZmV0Y2ggdGhlIHdob2xlIHBhZ2Ugc28gc2FtZSBhcyBhYm92ZVxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGBhdXRvYCAtIGlmIHRoZSBwYWdlIGlzIGR5bmFtaWMsIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgcGFydGlhbGx5LCBpZiBzdGF0aWMgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseVxuICAgKi9cbiAgaWYgKHByZWZldGNoS2luZCA9PT0gUHJlZmV0Y2hLaW5kLkFVVE8pIHtcbiAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0gPSAnMSdcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBvcHRpb25zLmlzSG1yUmVmcmVzaCkge1xuICAgIGhlYWRlcnNbTkVYVF9ITVJfUkVGUkVTSF9IRUFERVJdID0gJzEnXG4gIH1cblxuICBpZiAobmV4dFVybCkge1xuICAgIGhlYWRlcnNbTkVYVF9VUkxdID0gbmV4dFVybFxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBXaGVuIGNyZWF0aW5nIGEgXCJ0ZW1wb3JhcnlcIiBwcmVmZXRjaCAodGhlIFwib24tZGVtYW5kXCIgcHJlZmV0Y2ggdGhhdCBnZXRzIGNyZWF0ZWQgb24gbmF2aWdhdGlvbiwgaWYgb25lIGRvZXNuJ3QgZXhpc3QpXG4gICAgLy8gd2Ugc2VuZCB0aGUgcmVxdWVzdCB3aXRoIGEgXCJoaWdoXCIgcHJpb3JpdHkgYXMgaXQncyBpbiByZXNwb25zZSB0byBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCBjb3VsZCBiZSBibG9ja2luZyBhIHRyYW5zaXRpb24uXG4gICAgLy8gT3RoZXJ3aXNlLCBhbGwgb3RoZXIgcHJlZmV0Y2hlcyBhcmUgc2VudCB3aXRoIGEgXCJsb3dcIiBwcmlvcml0eS5cbiAgICAvLyBXZSB1c2UgXCJhdXRvXCIgZm9yIGluIGFsbCBvdGhlciBjYXNlcyB0byBtYXRjaCB0aGUgZXhpc3RpbmcgZGVmYXVsdCwgYXMgdGhpcyBmdW5jdGlvbiBpcyBzaGFyZWQgb3V0c2lkZSBvZiBwcmVmZXRjaGluZy5cbiAgICBjb25zdCBmZXRjaFByaW9yaXR5ID0gcHJlZmV0Y2hLaW5kXG4gICAgICA/IHByZWZldGNoS2luZCA9PT0gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWVxuICAgICAgICA/ICdoaWdoJ1xuICAgICAgICA6ICdsb3cnXG4gICAgICA6ICdhdXRvJ1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgLy8gSW4gXCJvdXRwdXQ6IGV4cG9ydFwiIG1vZGUsIHdlIGNhbid0IHJlbHkgb24gaGVhZGVycyB0byBkaXN0aW5ndWlzaFxuICAgICAgICAvLyBiZXR3ZWVuIEhUTUwgYW5kIFJTQyByZXF1ZXN0cy4gSW5zdGVhZCwgd2UgYXBwZW5kIGFuIGV4dHJhIHByZWZpeFxuICAgICAgICAvLyB0byB0aGUgcmVxdWVzdC5cbiAgICAgICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgIHVybC5wYXRobmFtZSArPSAnaW5kZXgudHh0J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybC5wYXRobmFtZSArPSAnLnR4dCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNyZWF0ZUZldGNoKFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGZldGNoUHJpb3JpdHksXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKVxuXG4gICAgY29uc3QgcmVzcG9uc2VVcmwgPSB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIocmVzLnVybClcbiAgICBjb25zdCBjYW5vbmljYWxVcmwgPSByZXMucmVkaXJlY3RlZCA/IHJlc3BvbnNlVXJsIDogdW5kZWZpbmVkXG5cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJydcbiAgICBjb25zdCBpbnRlcmNlcHRpb24gPSAhIXJlcy5oZWFkZXJzLmdldCgndmFyeScpPy5pbmNsdWRlcyhORVhUX1VSTClcbiAgICBjb25zdCBwb3N0cG9uZWQgPSAhIXJlcy5oZWFkZXJzLmdldChORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIpXG4gICAgY29uc3Qgc3RhbGVUaW1lSGVhZGVyID0gcmVzLmhlYWRlcnMuZ2V0KE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSKVxuICAgIGNvbnN0IHN0YWxlVGltZSA9XG4gICAgICBzdGFsZVRpbWVIZWFkZXIgIT09IG51bGwgPyBwYXJzZUludChzdGFsZVRpbWVIZWFkZXIsIDEwKSA6IC0xXG4gICAgbGV0IGlzRmxpZ2h0UmVzcG9uc2UgPSBjb250ZW50VHlwZS5zdGFydHNXaXRoKFJTQ19DT05URU5UX1RZUEVfSEVBREVSKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgaWYgKCFpc0ZsaWdodFJlc3BvbnNlKSB7XG4gICAgICAgICAgaXNGbGlnaHRSZXNwb25zZSA9IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ3RleHQvcGxhaW4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgZmV0Y2ggcmV0dXJucyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gZmxpZ2h0IHJlc3BvbnNlIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAvLyBJZiB0aGUgZmV0Y2ggd2FzIG5vdCAyMDAsIHdlIGFsc28gaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSB8fCAhcmVzLm9rIHx8ICFyZXMuYm9keSkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3JpZ2luYWwgVVJMIGNhbWUgd2l0aCBhIGhhc2gsIHByZXNlcnZlIGl0IGJlZm9yZSByZWRpcmVjdGluZyB0byB0aGUgbmV3IFVSTFxuICAgICAgaWYgKHVybC5oYXNoKSB7XG4gICAgICAgIHJlc3BvbnNlVXJsLmhhc2ggPSB1cmwuaGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKHJlc3BvbnNlVXJsLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgLy8gV2UgbWF5IG5hdmlnYXRlIHRvIGEgcGFnZSB0aGF0IHJlcXVpcmVzIGEgZGlmZmVyZW50IFdlYnBhY2sgcnVudGltZS5cbiAgICAvLyBJbiBwcm9kLCBldmVyeSBwYWdlIHdpbGwgaGF2ZSB0aGUgc2FtZSBXZWJwYWNrIHJ1bnRpbWUuXG4gICAgLy8gSW4gZGV2LCB0aGUgV2VicGFjayBydW50aW1lIGlzIG1pbmltYWwgZm9yIGVhY2ggcGFnZS5cbiAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgV2VicGFjayBydW50aW1lIGlzIHVwZGF0ZWQgYmVmb3JlIGV4ZWN1dGluZyBjbGllbnQtc2lkZSBKUyBvZiB0aGUgbmV3IHBhZ2UuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgYXdhaXQgcmVxdWlyZSgnLi4vcmVhY3QtZGV2LW92ZXJsYXkvYXBwL2hvdC1yZWxvYWRlci1jbGllbnQnKS53YWl0Rm9yV2VicGFja1J1bnRpbWVIb3RVcGRhdGUoKVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgYGZldGNoYCByZWFkYWJsZSBzdHJlYW0gdGhhdCBjYW4gYmUgdW53cmFwcGVkIGJ5IGBSZWFjdC51c2VgLlxuICAgIGNvbnN0IGZsaWdodFN0cmVhbSA9IHBvc3Rwb25lZFxuICAgICAgPyBjcmVhdGVVbmNsb3NpbmdQcmVmZXRjaFN0cmVhbShyZXMuYm9keSlcbiAgICAgIDogcmVzLmJvZHlcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChjcmVhdGVGcm9tTmV4dFJlYWRhYmxlU3RyZWFtKFxuICAgICAgZmxpZ2h0U3RyZWFtXG4gICAgKSBhcyBQcm9taXNlPE5hdmlnYXRpb25GbGlnaHRSZXNwb25zZT4pXG5cbiAgICBpZiAoZ2V0QXBwQnVpbGRJZCgpICE9PSByZXNwb25zZS5iKSB7XG4gICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKHJlcy51cmwpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZsaWdodERhdGE6IG5vcm1hbGl6ZUZsaWdodERhdGEocmVzcG9uc2UuZiksXG4gICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybCxcbiAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogaW50ZXJjZXB0aW9uLFxuICAgICAgcHJlcmVuZGVyZWQ6IHJlc3BvbnNlLlMsXG4gICAgICBwb3N0cG9uZWQsXG4gICAgICBzdGFsZVRpbWUsXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIWFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBmZXRjaCBSU0MgcGF5bG9hZCBmb3IgJHt1cmx9LiBGYWxsaW5nIGJhY2sgdG8gYnJvd3NlciBuYXZpZ2F0aW9uLmAsXG4gICAgICAgIGVyclxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIElmIGZldGNoIGZhaWxzIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAvLyBUT0RPLUFQUDogQWRkIGEgdGVzdCBmb3IgdGhlIGNhc2Ugd2hlcmUgYSBDT1JTIHJlcXVlc3QgZmFpbHMsIGUuZy4gZXh0ZXJuYWwgdXJsIHJlZGlyZWN0IGNvbWluZyBmcm9tIHRoZSByZXNwb25zZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy80MzYwNSNpc3N1ZWNvbW1lbnQtMTQ1MTYxNzUyMSBmb3IgYSByZXByb2R1Y3Rpb24uXG4gICAgcmV0dXJuIHtcbiAgICAgIGZsaWdodERhdGE6IHVybC50b1N0cmluZygpLFxuICAgICAgY2Fub25pY2FsVXJsOiB1bmRlZmluZWQsXG4gICAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGZhbHNlLFxuICAgICAgcHJlcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgcG9zdHBvbmVkOiBmYWxzZSxcbiAgICAgIHN0YWxlVGltZTogLTEsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGZXRjaChcbiAgdXJsOiBVUkwsXG4gIGhlYWRlcnM6IFJlcXVlc3RIZWFkZXJzLFxuICBmZXRjaFByaW9yaXR5OiAnYXV0bycgfCAnaGlnaCcgfCAnbG93JyB8IG51bGwsXG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG4pIHtcbiAgY29uc3QgZmV0Y2hVcmwgPSBuZXcgVVJMKHVybClcblxuICAvLyBUT0RPOiBJbiBvdXRwdXQ6IFwiZXhwb3J0XCIgbW9kZSwgdGhlIGhlYWRlcnMgZG8gbm90aGluZy4gT21pdCB0aGVtIChhbmQgdGhlXG4gIC8vIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtKSBmcm9tIHRoZSByZXF1ZXN0IHNvIHRoZXkncmVcbiAgLy8gbWF4aW1hbGx5IGNhY2hlYWJsZS5cbiAgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0oZmV0Y2hVcmwsIGhlYWRlcnMpXG5cbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUgJiYgZmV0Y2hQcmlvcml0eSAhPT0gbnVsbCkge1xuICAgIGhlYWRlcnNbJ05leHQtVGVzdC1GZXRjaC1Qcmlvcml0eSddID0gZmV0Y2hQcmlvcml0eVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRCkge1xuICAgIGhlYWRlcnNbJ3gtZGVwbG95bWVudC1pZCddID0gcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEXG4gIH1cblxuICByZXR1cm4gZmV0Y2goZmV0Y2hVcmwsIHtcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBvbGRlciBicm93c2Vycy4gYHNhbWUtb3JpZ2luYCBpcyB0aGUgZGVmYXVsdCBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgaGVhZGVycyxcbiAgICBwcmlvcml0eTogZmV0Y2hQcmlvcml0eSB8fCB1bmRlZmluZWQsXG4gICAgc2lnbmFsLFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbU5leHRSZWFkYWJsZVN0cmVhbShcbiAgZmxpZ2h0U3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuKTogUHJvbWlzZTx1bmtub3duPiB7XG4gIHJldHVybiBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0oZmxpZ2h0U3RyZWFtLCB7XG4gICAgY2FsbFNlcnZlcixcbiAgICBmaW5kU291cmNlTWFwVVJMLFxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmNsb3NpbmdQcmVmZXRjaFN0cmVhbShcbiAgb3JpZ2luYWxGbGlnaHRTdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4pOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PiB7XG4gIC8vIFdoZW4gUFBSIGlzIGVuYWJsZWQsIHByZWZldGNoIHN0cmVhbXMgbWF5IGNvbnRhaW4gcmVmZXJlbmNlcyB0aGF0IG5ldmVyXG4gIC8vIHJlc29sdmUsIGJlY2F1c2UgdGhhdCdzIGhvdyB3ZSBlbmNvZGUgZHluYW1pYyBkYXRhIGFjY2Vzcy4gSW4gdGhlIGRlY29kZWRcbiAgLy8gb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBGbGlnaHQgY2xpZW50LCB0aGVzZSBhcmUgcmVpZmllZCBpbnRvIGhhbmdpbmdcbiAgLy8gcHJvbWlzZXMgdGhhdCBzdXNwZW5kIGR1cmluZyByZW5kZXIsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHdoYXQgd2Ugd2FudC5cbiAgLy8gVGhlIFVJIHJlc29sdmVzIHdoZW4gaXQgc3dpdGNoZXMgdG8gdGhlIGR5bmFtaWMgZGF0YSBzdHJlYW1cbiAgLy8gKHZpYSB1c2VEZWZlcnJlZFZhbHVlKGR5bmFtaWMsIHN0YXRpYykpLlxuICAvL1xuICAvLyBIb3dldmVyLCB0aGUgRmxpZ2h0IGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBlcnJvcnMgaWYgdGhlIHNlcnZlciBjbG9zZXNcbiAgLy8gdGhlIHJlc3BvbnNlIGJlZm9yZSBhbGwgdGhlIHJlZmVyZW5jZXMgYXJlIHJlc29sdmVkLiBBcyBhIGNoZWF0IHRvIHdvcmtcbiAgLy8gYXJvdW5kIHRoaXMsIHdlIHdyYXAgdGhlIG9yaWdpbmFsIHN0cmVhbSBpbiBhIG5ldyBzdHJlYW0gdGhhdCBuZXZlciBjbG9zZXMsXG4gIC8vIGFuZCB0aGVyZWZvcmUgZG9lc24ndCBlcnJvci5cbiAgY29uc3QgcmVhZGVyID0gb3JpZ2luYWxGbGlnaHRTdHJlYW0uZ2V0UmVhZGVyKClcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpXG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIC8vIFBhc3MgdG8gdGhlIHRhcmdldCBzdHJlYW0gYW5kIGtlZXAgY29uc3VtaW5nIHRoZSBGbGlnaHQgcmVzcG9uc2VcbiAgICAgICAgICAvLyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHNlcnZlciBzdHJlYW0gaGFzIGNsb3NlZC4gRXhpdCwgYnV0IGludGVudGlvbmFsbHkgZG8gbm90IGNsb3NlXG4gICAgICAgIC8vIHRoZSB0YXJnZXQgc3RyZWFtLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUZldGNoIiwiY3JlYXRlRnJvbU5leHRSZWFkYWJsZVN0cmVhbSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJ1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIiLCJjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0iLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwicmVxdWlyZSIsInVybCIsInVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJzZWFyY2hQYXJhbXMiLCJkZWxldGUiLCJORVhUX1JTQ19VTklPTl9RVUVSWSIsIk5PREVfRU5WIiwiX19ORVhUX0NPTkZJR19PVVRQVVQiLCJwYXRobmFtZSIsImVuZHNXaXRoIiwibGVuZ3RoIiwic2xpY2UiLCJkb01wYU5hdmlnYXRpb24iLCJmbGlnaHREYXRhIiwidG9TdHJpbmciLCJjYW5vbmljYWxVcmwiLCJ1bmRlZmluZWQiLCJjb3VsZEJlSW50ZXJjZXB0ZWQiLCJwcmVyZW5kZXJlZCIsInBvc3Rwb25lZCIsInN0YWxlVGltZSIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJhYm9ydCIsIm9wdGlvbnMiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIm5leHRVcmwiLCJwcmVmZXRjaEtpbmQiLCJoZWFkZXJzIiwiUlNDX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIiLCJpc0htclJlZnJlc2giLCJORVhUX0hNUl9SRUZSRVNIX0hFQURFUiIsIk5FWFRfVVJMIiwicmVzIiwiZmV0Y2hQcmlvcml0eSIsIlRFTVBPUkFSWSIsInNpZ25hbCIsInJlc3BvbnNlVXJsIiwicmVkaXJlY3RlZCIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiaW50ZXJjZXB0aW9uIiwiaW5jbHVkZXMiLCJORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIiLCJzdGFsZVRpbWVIZWFkZXIiLCJORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUiIsInBhcnNlSW50IiwiaXNGbGlnaHRSZXNwb25zZSIsInN0YXJ0c1dpdGgiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsIm9rIiwiYm9keSIsImhhc2giLCJUVVJCT1BBQ0siLCJ3YWl0Rm9yV2VicGFja1J1bnRpbWVIb3RVcGRhdGUiLCJmbGlnaHRTdHJlYW0iLCJjcmVhdGVVbmNsb3NpbmdQcmVmZXRjaFN0cmVhbSIsInJlc3BvbnNlIiwiZ2V0QXBwQnVpbGRJZCIsImIiLCJub3JtYWxpemVGbGlnaHREYXRhIiwiZiIsIlMiLCJlcnIiLCJhYm9ydGVkIiwiY29uc29sZSIsImVycm9yIiwiZmV0Y2hVcmwiLCJzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSIsIl9fTkVYVF9URVNUX01PREUiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwicHJpb3JpdHkiLCJjYWxsU2VydmVyIiwiZmluZFNvdXJjZU1hcFVSTCIsIm9yaWdpbmFsRmxpZ2h0U3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW0iLCJwdWxsIiwiY29udHJvbGxlciIsImRvbmUiLCJ2YWx1ZSIsInJlYWQiLCJlbnF1ZXVlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    createSeededPrefetchCacheEntry: function() {\n        return createSeededPrefetchCacheEntry;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst INTERCEPTION_CACHE_KEY_MARKER = '%';\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {\n    // Initially we only use the pathname as the cache key. We don't want to include\n    // search params so that multiple URLs with the same search parameter can re-use\n    // loading states.\n    let pathnameFromUrl = url.pathname;\n    // RSC responses can differ based on search params, specifically in the case where we aren't\n    // returning a partial response (ie with `PrefetchKind.AUTO`).\n    // In the auto case, since loading.js & layout.js won't have access to search params,\n    // we can safely re-use that cache entry. But for full prefetches, we should not\n    // re-use the cache entry as the response may differ.\n    if (includeSearchParams) {\n        // if we have a full prefetch, we can include the search param in the key,\n        // as we'll be getting back a full response. The server might have read the search\n        // params when generating the full response.\n        pathnameFromUrl += url.search;\n    }\n    if (prefix) {\n        return \"\" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction createPrefetchCacheKey(url, kind, nextUrl) {\n    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);\n}\nfunction getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {\n    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    for (const maybeNextUrl of [\n        nextUrl,\n        null\n    ]){\n        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);\n        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);\n        // First, we check if we have a cache entry that exactly matches the URL\n        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;\n        const existingEntry = prefetchCache.get(cacheKeyToUse);\n        if (existingEntry && allowAliasing) {\n            // We know we're returning an aliased entry when the pathname matches but the search params don't,\n            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;\n            if (isAliased) {\n                return {\n                    ...existingEntry,\n                    aliased: true\n                };\n            }\n            return existingEntry;\n        }\n        // If the request contains search params, and we're not doing a full prefetch, we can return the\n        // param-less entry if it exists.\n        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n        // but lets us arrive there quicker in the param-full case.\n        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);\n        if (false) {}\n    }\n    // If we've gotten to this point, we didn't find a specific cache entry that matched\n    // the request URL.\n    // We attempt a partial match by checking if there's a cache entry with the same pathname.\n    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n    // This will signal to the router that it should only apply the loading state on the prefetched data.\n    if (false) {}\n    return undefined;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;\n    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n            // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n            // are seeded but without a prefetch intent)\n            existingCacheEntry.data.then((prefetchResponse)=>{\n                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{\n                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n                    return flightData.isRootRender && flightData.seedData !== null;\n                });\n                if (!isFullPrefetch) {\n                    return createLazyPrefetchEntry({\n                        tree,\n                        url,\n                        nextUrl,\n                        prefetchCache,\n                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                        // rather than assuming the same intent as the previous entry, to be consistent with how we\n                        // lazily create prefetch entries when intent is left unspecified.\n                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n                    });\n                }\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        nextUrl,\n        prefetchCache,\n        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache, existingCacheKey } = param;\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);\n    prefetchCache.set(newCacheKey, {\n        ...existingCacheEntry,\n        key: newCacheKey\n    });\n    prefetchCache.delete(existingCacheKey);\n    return newCacheKey;\n}\nfunction createSeededPrefetchCacheEntry(param) {\n    let { nextUrl, tree, prefetchCache, url, data, kind } = param;\n    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url, kind);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: tree,\n            nextUrl,\n            prefetchKind: kind\n        }).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            let newCacheKey;\n            if (prefetchResponse.couldBeIntercepted) {\n                // Determine if we need to prefix the cache key with the nextUrl\n                newCacheKey = prefixExistingPrefetchCacheEntry({\n                    url,\n                    existingCacheKey: prefetchCacheKey,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n            // staleTime.\n            if (prefetchResponse.prerendered) {\n                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);\n                if (existingCacheEntry) {\n                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;\n                    if (prefetchResponse.staleTime !== -1) {\n                        // This is the stale time that was collected by the server during\n                        // static generation. Use this in place of the default stale time.\n                        existingCacheEntry.staleTime = prefetchResponse.staleTime;\n                    }\n                }\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS = Number(\"0\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime, staleTime } = param;\n    if (staleTime !== -1) {\n        // `staleTime` is the value sent by the server during static generation.\n        // When this is available, it takes precedence over any of the heuristics\n        // that follow.\n        //\n        // TODO: When PPR is enabled, the server will *always* return a stale time\n        // when prefetching. We should never use a prefetch entry that hasn't yet\n        // received data from the server. So the only two cases should be 1) we use\n        // the server-generated stale time 2) the unresolved entry is discarded.\n        return Date.now() < prefetchTime + staleTime ? _routerreducertypes.PrefetchCacheEntryStatus.fresh : _routerreducertypes.PrefetchCacheEntryStatus.stale;\n    }\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === _routerreducertypes.PrefetchKind.AUTO) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === _routerreducertypes.PrefetchKind.FULL) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHJlZmV0Y2gtY2FjaGUtdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBK1lhQSxtQkFBbUI7ZUFBbkJBOztJQW5JR0MsOEJBQThCO2VBQTlCQTs7SUE5R0FDLDZCQUE2QjtlQUE3QkE7O0lBK05BQyxrQkFBa0I7ZUFBbEJBOzs7aURBMVhUO2dEQU1BOzZDQUN1QjtBQUU5QixNQUFNQyxnQ0FBZ0M7QUFVdEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsMkJBQ1BDLEdBQVEsRUFDUkMsbUJBQTRCLEVBQzVCQyxNQUFzQjtJQUV0QixnRkFBZ0Y7SUFDaEYsZ0ZBQWdGO0lBQ2hGLGtCQUFrQjtJQUNsQixJQUFJQyxrQkFBa0JILElBQUlJLFFBQVE7SUFFbEMsNEZBQTRGO0lBQzVGLDhEQUE4RDtJQUM5RCxxRkFBcUY7SUFDckYsZ0ZBQWdGO0lBQ2hGLHFEQUFxRDtJQUNyRCxJQUFJSCxxQkFBcUI7UUFDdkIsMEVBQTBFO1FBQzFFLGtGQUFrRjtRQUNsRiw0Q0FBNEM7UUFDNUNFLG1CQUFtQkgsSUFBSUssTUFBTTtJQUMvQjtJQUVBLElBQUlILFFBQVE7UUFDVixPQUFRLEtBQUVBLFNBQVNKLGdDQUFnQ0s7SUFDckQ7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBU0csdUJBQ1BOLEdBQVEsRUFDUk8sSUFBOEIsRUFDOUJDLE9BQXVCO0lBRXZCLE9BQU9ULDJCQUEyQkMsS0FBS08sU0FBU0Usb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUFFRjtBQUNyRTtBQUVBLFNBQVNHLHNCQUNQWCxHQUFRLEVBQ1JPLElBQTJDLEVBQzNDQyxPQUFzQixFQUN0QkksYUFBOEMsRUFDOUNDLGFBQXNCO0lBSHRCTixJQUFBQSxTQUFBQSxLQUFBQSxHQUFBQSxPQUFxQkUsb0JBQUFBLFlBQVksQ0FBQ0ssU0FBUztJQUszQyw4RUFBOEU7SUFDOUUsa0pBQWtKO0lBQ2xKLGlJQUFpSTtJQUNqSSxLQUFLLE1BQU1DLGdCQUFnQjtRQUFDUDtRQUFTO0tBQUssQ0FBRTtRQUMxQyxNQUFNUSxxQkFBcUJqQiwyQkFDekJDLEtBQ0EsTUFDQWU7UUFFRixNQUFNRSx3QkFBd0JsQiwyQkFDNUJDLEtBQ0EsT0FDQWU7UUFHRix3RUFBd0U7UUFDeEUsTUFBTUcsZ0JBQWdCbEIsSUFBSUssTUFBTSxHQUM1QlcscUJBQ0FDO1FBRUosTUFBTUUsZ0JBQWdCUCxjQUFjUSxHQUFHLENBQUNGO1FBQ3hDLElBQUlDLGlCQUFpQk4sZUFBZTtZQUNsQyxrR0FBa0c7WUFDbEcsTUFBTVEsWUFDSkYsY0FBY25CLEdBQUcsQ0FBQ0ksUUFBUSxLQUFLSixJQUFJSSxRQUFRLElBQzNDZSxjQUFjbkIsR0FBRyxDQUFDSyxNQUFNLEtBQUtMLElBQUlLLE1BQU07WUFFekMsSUFBSWdCLFdBQVc7Z0JBQ2IsT0FBTztvQkFDTCxHQUFHRixhQUFhO29CQUNoQkcsU0FBUztnQkFDWDtZQUNGO1lBRUEsT0FBT0g7UUFDVDtRQUVBLGdHQUFnRztRQUNoRyxpQ0FBaUM7UUFDakMsOEdBQThHO1FBQzlHLDJEQUEyRDtRQUMzRCxNQUFNSSxxQkFBcUJYLGNBQWNRLEdBQUcsQ0FBQ0g7UUFDN0MsSUFDRU8sS0FPK0QxQixFQUMvRCxFQUVEO0lBQ0g7SUFFQSxvRkFBb0Y7SUFDcEYsbUJBQW1CO0lBQ25CLDBGQUEwRjtJQUMxRiwyR0FBMkc7SUFDM0cscUdBQXFHO0lBQ3JHLElBQ0UwQixLQUVhWCxFQUNiLEVBV0Q7SUFFRCxPQUFPa0I7QUFDVDtBQU1PLFNBQVNuQyw4QkFBOEIsS0FXN0M7SUFYNkMsTUFDNUNJLEdBQUcsRUFDSFEsT0FBTyxFQUNQd0IsSUFBSSxFQUNKcEIsYUFBYSxFQUNiTCxJQUFJLEVBQ0pNLGdCQUFnQixJQUFJLEVBS3JCLEdBWDZDO0lBWTVDLE1BQU1vQixxQkFBcUJ0QixzQkFDekJYLEtBQ0FPLE1BQ0FDLFNBQ0FJLGVBQ0FDO0lBR0YsSUFBSW9CLG9CQUFvQjtRQUN0QiwwREFBMEQ7UUFDMURBLG1CQUFtQkMsTUFBTSxHQUFHQyw0QkFBNEJGO1FBRXhELCtEQUErRDtRQUMvRCxxSEFBcUg7UUFDckgsTUFBTUcseUJBQ0pILG1CQUFtQjFCLElBQUksS0FBS0Usb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxJQUM3Q0gsU0FBU0Usb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSTtRQUU1QixJQUFJMEIsd0JBQXdCO1lBQzFCLG9HQUFvRztZQUNwRyxxSEFBcUg7WUFDckgsNENBQTRDO1lBQzVDSCxtQkFBbUJJLElBQUksQ0FBQ0MsSUFBSSxDQUFDLENBQUNDO2dCQUM1QixNQUFNQyxpQkFDSkMsTUFBTUMsT0FBTyxDQUFDSCxpQkFBaUJJLFVBQVUsS0FDekNKLGlCQUFpQkksVUFBVSxDQUFDQyxJQUFJLENBQUMsQ0FBQ0Q7b0JBQ2hDLDZHQUE2RztvQkFDN0csT0FBT0EsV0FBV0UsWUFBWSxJQUFJRixXQUFXRyxRQUFRLEtBQUs7Z0JBQzVEO2dCQUVGLElBQUksQ0FBQ04sZ0JBQWdCO29CQUNuQixPQUFPTyx3QkFBd0I7d0JBQzdCZjt3QkFDQWhDO3dCQUNBUTt3QkFDQUk7d0JBQ0EsOEVBQThFO3dCQUM5RSwyRkFBMkY7d0JBQzNGLGtFQUFrRTt3QkFDbEVMLE1BQU1BLFFBQUFBLE9BQUFBLE9BQVFFLG9CQUFBQSxZQUFZLENBQUNLLFNBQVM7b0JBQ3RDO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLHVIQUF1SDtRQUN2SCw0SUFBNEk7UUFDNUksSUFBSVAsUUFBUTBCLG1CQUFtQjFCLElBQUksS0FBS0Usb0JBQUFBLFlBQVksQ0FBQ0ssU0FBUyxFQUFFO1lBQzlEbUIsbUJBQW1CMUIsSUFBSSxHQUFHQTtRQUM1QjtRQUVBLHFGQUFxRjtRQUNyRixPQUFPMEI7SUFDVDtJQUVBLGtEQUFrRDtJQUNsRCxPQUFPYyx3QkFBd0I7UUFDN0JmO1FBQ0FoQztRQUNBUTtRQUNBSTtRQUNBTCxNQUFNQSxRQUFRRSxvQkFBQUEsWUFBWSxDQUFDSyxTQUFTO0lBQ3RDO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTa0MsaUNBQWlDLEtBUXpDO0lBUnlDLE1BQ3hDaEQsR0FBRyxFQUNIUSxPQUFPLEVBQ1BJLGFBQWEsRUFDYnFDLGdCQUFnQixFQUlqQixHQVJ5QztJQVN4QyxNQUFNaEIscUJBQXFCckIsY0FBY1EsR0FBRyxDQUFDNkI7SUFDN0MsSUFBSSxDQUFDaEIsb0JBQW9CO1FBQ3ZCLHlDQUF5QztRQUN6QztJQUNGO0lBRUEsTUFBTWlCLGNBQWM1Qyx1QkFDbEJOLEtBQ0FpQyxtQkFBbUIxQixJQUFJLEVBQ3ZCQztJQUVGSSxjQUFjdUMsR0FBRyxDQUFDRCxhQUFhO1FBQUUsR0FBR2pCLGtCQUFrQjtRQUFFTixLQUFLdUI7SUFBWTtJQUN6RXRDLGNBQWN3QyxNQUFNLENBQUNIO0lBRXJCLE9BQU9DO0FBQ1Q7QUFLTyxTQUFTdkQsK0JBQStCLEtBVzlDO0lBWDhDLE1BQzdDYSxPQUFPLEVBQ1B3QixJQUFJLEVBQ0pwQixhQUFhLEVBQ2JaLEdBQUcsRUFDSHFDLElBQUksRUFDSjlCLElBQUksRUFLTCxHQVg4QztJQVk3QyxpSEFBaUg7SUFDakgsc0dBQXNHO0lBQ3RHLHFHQUFxRztJQUNyRyxNQUFNOEMsbUJBQW1CaEIsS0FBS2lCLGtCQUFrQixHQUM1Q2hELHVCQUF1Qk4sS0FBS08sTUFBTUMsV0FDbENGLHVCQUF1Qk4sS0FBS087SUFFaEMsTUFBTWdELGdCQUFnQjtRQUNwQkMsc0JBQXNCeEI7UUFDdEJLLE1BQU1vQixRQUFRQyxPQUFPLENBQUNyQjtRQUN0QjlCO1FBQ0FvRCxjQUFjQyxLQUFLQyxHQUFHO1FBQ3RCQyxjQUFjRixLQUFLQyxHQUFHO1FBQ3RCRSxXQUFXLENBQUM7UUFDWnBDLEtBQUswQjtRQUNMbkIsUUFBUThCLG9CQUFBQSx3QkFBd0IsQ0FBQ0MsS0FBSztRQUN0Q2pFO0lBQ0Y7SUFFQVksY0FBY3VDLEdBQUcsQ0FBQ0Usa0JBQWtCRTtJQUVwQyxPQUFPQTtBQUNUO0FBRUE7O0NBRUMsR0FDRCxTQUFTUix3QkFBd0IsS0FTaEM7SUFUZ0MsTUFDL0IvQyxHQUFHLEVBQ0hPLElBQUksRUFDSnlCLElBQUksRUFDSnhCLE9BQU8sRUFDUEksYUFBYSxFQUlkLEdBVGdDO0lBVS9CLE1BQU15QyxtQkFBbUIvQyx1QkFBdUJOLEtBQUtPO0lBRXJELHVFQUF1RTtJQUN2RSw2RkFBNkY7SUFDN0YsTUFBTThCLE9BQU82QixpQkFBQUEsYUFBYSxDQUFDQyxPQUFPLENBQUMsSUFDakNDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBQUEsRUFBb0JwRSxLQUFLO1lBQ3ZCcUUsbUJBQW1CckM7WUFDbkJ4QjtZQUNBOEQsY0FBYy9EO1FBQ2hCLEdBQUcrQixJQUFJLENBQUMsQ0FBQ0M7WUFDUCwrRkFBK0Y7WUFDL0Ysd0RBQXdEO1lBQ3hELGtFQUFrRTtZQUNsRSxJQUFJVztZQUVKLElBQUlYLGlCQUFpQmUsa0JBQWtCLEVBQUU7Z0JBQ3ZDLGdFQUFnRTtnQkFDaEVKLGNBQWNGLGlDQUFpQztvQkFDN0NoRDtvQkFDQWlELGtCQUFrQkk7b0JBQ2xCN0M7b0JBQ0FJO2dCQUNGO1lBQ0Y7WUFFQSxzSEFBc0g7WUFDdEgsK0hBQStIO1lBQy9ILGFBQWE7WUFDYixJQUFJMkIsaUJBQWlCZ0MsV0FBVyxFQUFFO2dCQUNoQyxNQUFNdEMscUJBQXFCckIsY0FBY1EsR0FBRyxDQUMxQyxlQUNBOEIsT0FBQUEsY0FBZUc7Z0JBRWpCLElBQUlwQixvQkFBb0I7b0JBQ3RCQSxtQkFBbUIxQixJQUFJLEdBQUdFLG9CQUFBQSxZQUFZLENBQUNDLElBQUk7b0JBQzNDLElBQUk2QixpQkFBaUJ3QixTQUFTLEtBQUssQ0FBQyxHQUFHO3dCQUNyQyxpRUFBaUU7d0JBQ2pFLGtFQUFrRTt3QkFDbEU5QixtQkFBbUI4QixTQUFTLEdBQUd4QixpQkFBaUJ3QixTQUFTO29CQUMzRDtnQkFDRjtZQUNGO1lBRUEsT0FBT3hCO1FBQ1Q7SUFHRixNQUFNZ0IsZ0JBQWdCO1FBQ3BCQyxzQkFBc0J4QjtRQUN0Qks7UUFDQTlCO1FBQ0FvRCxjQUFjQyxLQUFLQyxHQUFHO1FBQ3RCQyxjQUFjO1FBQ2RDLFdBQVcsQ0FBQztRQUNacEMsS0FBSzBCO1FBQ0xuQixRQUFROEIsb0JBQUFBLHdCQUF3QixDQUFDQyxLQUFLO1FBQ3RDakU7SUFDRjtJQUVBWSxjQUFjdUMsR0FBRyxDQUFDRSxrQkFBa0JFO0lBRXBDLE9BQU9BO0FBQ1Q7QUFFTyxTQUFTMUQsbUJBQ2RlLGFBQW9EO0lBRXBELEtBQUssTUFBTSxDQUFDNEQsTUFBTUMsbUJBQW1CLElBQUk3RCxjQUFlO1FBQ3RELElBQ0V1Qiw0QkFBNEJzQyx3QkFDNUJULG9CQUFBQSx3QkFBd0IsQ0FBQ1UsT0FBTyxFQUNoQztZQUNBOUQsY0FBY3dDLE1BQU0sQ0FBQ29CO1FBQ3ZCO0lBQ0Y7QUFDRjtBQUVBLDhGQUE4RjtBQUM5RiwwREFBMEQ7QUFDMUQsTUFBTUcsdUJBQ0pDLE9BQU9wRCxHQUFrRCxJQUFJO0FBRXhELE1BQU05QixzQkFDWGtGLE9BQU9wRCxLQUFpRCxJQUFJO0FBRTlELFNBQVNXLDRCQUE0QixLQUtoQjtJQUxnQixNQUNuQzVCLElBQUksRUFDSm9ELFlBQVksRUFDWkcsWUFBWSxFQUNaQyxTQUFTLEVBQ1UsR0FMZ0I7SUFNbkMsSUFBSUEsY0FBYyxDQUFDLEdBQUc7UUFDcEIsd0VBQXdFO1FBQ3hFLHlFQUF5RTtRQUN6RSxlQUFlO1FBQ2YsRUFBRTtRQUNGLDBFQUEwRTtRQUMxRSx5RUFBeUU7UUFDekUsMkVBQTJFO1FBQzNFLHdFQUF3RTtRQUN4RSxPQUFPSCxLQUFLQyxHQUFHLEtBQUtGLGVBQWVJLFlBQy9CQyxvQkFBQUEsd0JBQXdCLENBQUNDLEtBQUssR0FDOUJELG9CQUFBQSx3QkFBd0IsQ0FBQ2UsS0FBSztJQUNwQztJQUVBLGdGQUFnRjtJQUNoRixJQUFJbkIsS0FBS0MsR0FBRyxLQUFNQyxDQUFBQSxnQkFBQUEsT0FBQUEsZUFBZ0JILFlBQUFBLENBQVcsR0FBS2dCLHNCQUFzQjtRQUN0RSxPQUFPYixlQUNIRSxvQkFBQUEsd0JBQXdCLENBQUNnQixRQUFRLEdBQ2pDaEIsb0JBQUFBLHdCQUF3QixDQUFDQyxLQUFLO0lBQ3BDO0lBRUEsc0dBQXNHO0lBQ3RHLDRFQUE0RTtJQUM1RSxzREFBc0Q7SUFDdEQsSUFBSTFELFNBQVNFLG9CQUFBQSxZQUFZLENBQUN3RSxJQUFJLEVBQUU7UUFDOUIsSUFBSXJCLEtBQUtDLEdBQUcsS0FBS0YsZUFBZWpFLHFCQUFxQjtZQUNuRCxPQUFPc0Usb0JBQUFBLHdCQUF3QixDQUFDZSxLQUFLO1FBQ3ZDO0lBQ0Y7SUFFQSxpR0FBaUc7SUFDakcsSUFBSXhFLFNBQVNFLG9CQUFBQSxZQUFZLENBQUNDLElBQUksRUFBRTtRQUM5QixJQUFJa0QsS0FBS0MsR0FBRyxLQUFLRixlQUFlakUscUJBQXFCO1lBQ25ELE9BQU9zRSxvQkFBQUEsd0JBQXdCLENBQUNnQixRQUFRO1FBQzFDO0lBQ0Y7SUFFQSxPQUFPaEIsb0JBQUFBLHdCQUF3QixDQUFDVSxPQUFPO0FBQ3pDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXHByZWZldGNoLWNhY2hlLXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGZldGNoU2VydmVyUmVzcG9uc2UsXG4gIHR5cGUgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCxcbn0gZnJvbSAnLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQge1xuICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMsXG4gIHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBQcmVmZXRjaEtpbmQsXG4gIHR5cGUgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBwcmVmZXRjaFF1ZXVlIH0gZnJvbSAnLi9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyJ1xuXG5jb25zdCBJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUiA9ICclJ1xuXG5leHBvcnQgdHlwZSBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5ID0gUHJlZmV0Y2hDYWNoZUVudHJ5ICYge1xuICAvKiogVGhpcyBpcyBhIHNwZWNpYWwgcHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgYSBwcmVmZXRjaCBlbnRyeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgVVJMXG4gICAqIHdhcyByZXR1cm5lZCByYXRoZXIgdGhhbiB0aGUgcmVxdWVzdGVkIFVSTC4gVGhpcyBzaWduYWxzIHRvIHRoZSByb3V0ZXIgdGhhdCBpdCBzaG91bGQgb25seVxuICAgKiBhcHBseSB0aGUgcGFydCB0aGF0IGRvZXNuJ3QgZGVwZW5kIG9uIHNlYXJjaFBhcmFtcyAoc3BlY2lmaWNhbGx5IHRoZSBsb2FkaW5nIHN0YXRlKS5cbiAgICovXG4gIGFsaWFzZWQ/OiBib29sZWFuXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNhY2hlIGtleSBmb3IgdGhlIHJvdXRlciBwcmVmZXRjaCBjYWNoZVxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIGJlaW5nIG5hdmlnYXRlZCB0b1xuICogQHBhcmFtIG5leHRVcmwgLSBhbiBpbnRlcm5hbCBVUkwsIHByaW1hcmlseSB1c2VkIGZvciBoYW5kbGluZyByZXdyaXRlcy4gRGVmYXVsdHMgdG8gJy8nLlxuICogQHJldHVybiBUaGUgZ2VuZXJhdGVkIHByZWZldGNoIGNhY2hlIGtleS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwoXG4gIHVybDogVVJMLFxuICBpbmNsdWRlU2VhcmNoUGFyYW1zOiBib29sZWFuLFxuICBwcmVmaXg/OiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgLy8gSW5pdGlhbGx5IHdlIG9ubHkgdXNlIHRoZSBwYXRobmFtZSBhcyB0aGUgY2FjaGUga2V5LiBXZSBkb24ndCB3YW50IHRvIGluY2x1ZGVcbiAgLy8gc2VhcmNoIHBhcmFtcyBzbyB0aGF0IG11bHRpcGxlIFVSTHMgd2l0aCB0aGUgc2FtZSBzZWFyY2ggcGFyYW1ldGVyIGNhbiByZS11c2VcbiAgLy8gbG9hZGluZyBzdGF0ZXMuXG4gIGxldCBwYXRobmFtZUZyb21VcmwgPSB1cmwucGF0aG5hbWVcblxuICAvLyBSU0MgcmVzcG9uc2VzIGNhbiBkaWZmZXIgYmFzZWQgb24gc2VhcmNoIHBhcmFtcywgc3BlY2lmaWNhbGx5IGluIHRoZSBjYXNlIHdoZXJlIHdlIGFyZW4ndFxuICAvLyByZXR1cm5pbmcgYSBwYXJ0aWFsIHJlc3BvbnNlIChpZSB3aXRoIGBQcmVmZXRjaEtpbmQuQVVUT2ApLlxuICAvLyBJbiB0aGUgYXV0byBjYXNlLCBzaW5jZSBsb2FkaW5nLmpzICYgbGF5b3V0LmpzIHdvbid0IGhhdmUgYWNjZXNzIHRvIHNlYXJjaCBwYXJhbXMsXG4gIC8vIHdlIGNhbiBzYWZlbHkgcmUtdXNlIHRoYXQgY2FjaGUgZW50cnkuIEJ1dCBmb3IgZnVsbCBwcmVmZXRjaGVzLCB3ZSBzaG91bGQgbm90XG4gIC8vIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgYXMgdGhlIHJlc3BvbnNlIG1heSBkaWZmZXIuXG4gIGlmIChpbmNsdWRlU2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIGZ1bGwgcHJlZmV0Y2gsIHdlIGNhbiBpbmNsdWRlIHRoZSBzZWFyY2ggcGFyYW0gaW4gdGhlIGtleSxcbiAgICAvLyBhcyB3ZSdsbCBiZSBnZXR0aW5nIGJhY2sgYSBmdWxsIHJlc3BvbnNlLiBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgcmVhZCB0aGUgc2VhcmNoXG4gICAgLy8gcGFyYW1zIHdoZW4gZ2VuZXJhdGluZyB0aGUgZnVsbCByZXNwb25zZS5cbiAgICBwYXRobmFtZUZyb21VcmwgKz0gdXJsLnNlYXJjaFxuICB9XG5cbiAgaWYgKHByZWZpeCkge1xuICAgIHJldHVybiBgJHtwcmVmaXh9JHtJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUn0ke3BhdGhuYW1lRnJvbVVybH1gXG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWVGcm9tVXJsXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkoXG4gIHVybDogVVJMLFxuICBraW5kOiBQcmVmZXRjaEtpbmQgfCB1bmRlZmluZWQsXG4gIG5leHRVcmw/OiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgcmV0dXJuIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKHVybCwga2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwsIG5leHRVcmwpXG59XG5cbmZ1bmN0aW9uIGdldEV4aXN0aW5nQ2FjaGVFbnRyeShcbiAgdXJsOiBVUkwsXG4gIGtpbmQ6IFByZWZldGNoS2luZCA9IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gIG5leHRVcmw6IHN0cmluZyB8IG51bGwsXG4gIHByZWZldGNoQ2FjaGU6IE1hcDxzdHJpbmcsIFByZWZldGNoQ2FjaGVFbnRyeT4sXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbik6IEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkgfCB1bmRlZmluZWQge1xuICAvLyBXZSBmaXJzdCBjaGVjayBpZiB0aGVyZSdzIGEgbW9yZSBzcGVjaWZpYyBpbnRlcmNlcHRpb24gcm91dGUgcHJlZmV0Y2ggZW50cnlcbiAgLy8gVGhpcyBpcyBiZWNhdXNlIHdoZW4gd2UgZGV0ZWN0IGEgcHJlZmV0Y2ggdGhhdCBjb3JyZXNwb25kcyB3aXRoIGFuIGludGVyY2VwdGlvbiByb3V0ZSwgd2UgcHJlZml4IGl0IHdpdGggbmV4dFVybCAoc2VlIGBjcmVhdGVQcmVmZXRjaENhY2hlS2V5YClcbiAgLy8gdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggb3RoZXIgcGFnZXMgdGhhdCBtYXkgaGF2ZSB0aGUgc2FtZSBVUkwgYnV0IHJlbmRlciBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgYE5leHQtVVJMYCBoZWFkZXIuXG4gIGZvciAoY29uc3QgbWF5YmVOZXh0VXJsIG9mIFtuZXh0VXJsLCBudWxsXSkge1xuICAgIGNvbnN0IGNhY2hlS2V5V2l0aFBhcmFtcyA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKFxuICAgICAgdXJsLFxuICAgICAgdHJ1ZSxcbiAgICAgIG1heWJlTmV4dFVybFxuICAgIClcbiAgICBjb25zdCBjYWNoZUtleVdpdGhvdXRQYXJhbXMgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbChcbiAgICAgIHVybCxcbiAgICAgIGZhbHNlLFxuICAgICAgbWF5YmVOZXh0VXJsXG4gICAgKVxuXG4gICAgLy8gRmlyc3QsIHdlIGNoZWNrIGlmIHdlIGhhdmUgYSBjYWNoZSBlbnRyeSB0aGF0IGV4YWN0bHkgbWF0Y2hlcyB0aGUgVVJMXG4gICAgY29uc3QgY2FjaGVLZXlUb1VzZSA9IHVybC5zZWFyY2hcbiAgICAgID8gY2FjaGVLZXlXaXRoUGFyYW1zXG4gICAgICA6IGNhY2hlS2V5V2l0aG91dFBhcmFtc1xuXG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KGNhY2hlS2V5VG9Vc2UpXG4gICAgaWYgKGV4aXN0aW5nRW50cnkgJiYgYWxsb3dBbGlhc2luZykge1xuICAgICAgLy8gV2Uga25vdyB3ZSdyZSByZXR1cm5pbmcgYW4gYWxpYXNlZCBlbnRyeSB3aGVuIHRoZSBwYXRobmFtZSBtYXRjaGVzIGJ1dCB0aGUgc2VhcmNoIHBhcmFtcyBkb24ndCxcbiAgICAgIGNvbnN0IGlzQWxpYXNlZCA9XG4gICAgICAgIGV4aXN0aW5nRW50cnkudXJsLnBhdGhuYW1lID09PSB1cmwucGF0aG5hbWUgJiZcbiAgICAgICAgZXhpc3RpbmdFbnRyeS51cmwuc2VhcmNoICE9PSB1cmwuc2VhcmNoXG5cbiAgICAgIGlmIChpc0FsaWFzZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5leGlzdGluZ0VudHJ5LFxuICAgICAgICAgIGFsaWFzZWQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4aXN0aW5nRW50cnlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcmVxdWVzdCBjb250YWlucyBzZWFyY2ggcGFyYW1zLCBhbmQgd2UncmUgbm90IGRvaW5nIGEgZnVsbCBwcmVmZXRjaCwgd2UgY2FuIHJldHVybiB0aGVcbiAgICAvLyBwYXJhbS1sZXNzIGVudHJ5IGlmIGl0IGV4aXN0cy5cbiAgICAvLyBUaGlzIGlzIHRlY2huaWNhbGx5IGNvdmVyZWQgYnkgdGhlIGNoZWNrIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmdW5jdGlvbiwgd2hpY2ggaXRlcmF0ZXMgb3ZlciBjYWNoZSBlbnRyaWVzLFxuICAgIC8vIGJ1dCBsZXRzIHVzIGFycml2ZSB0aGVyZSBxdWlja2VyIGluIHRoZSBwYXJhbS1mdWxsIGNhc2UuXG4gICAgY29uc3QgZW50cnlXaXRob3V0UGFyYW1zID0gcHJlZmV0Y2hDYWNoZS5nZXQoY2FjaGVLZXlXaXRob3V0UGFyYW1zKVxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICBhbGxvd0FsaWFzaW5nICYmXG4gICAgICB1cmwuc2VhcmNoICYmXG4gICAgICBraW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgICAgZW50cnlXaXRob3V0UGFyYW1zICYmXG4gICAgICAvLyBXZSBzaG91bGRuJ3QgcmV0dXJuIHRoZSBhbGlhc2VkIGVudHJ5IGlmIGl0IHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgY2FjaGUga2V5LlxuICAgICAgLy8gU2luY2UgaXQncyByZXdyaXR0ZW4sIGl0IGNvdWxkIHJlc3BvbmQgd2l0aCBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICAhZW50cnlXaXRob3V0UGFyYW1zLmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUilcbiAgICApIHtcbiAgICAgIHJldHVybiB7IC4uLmVudHJ5V2l0aG91dFBhcmFtcywgYWxpYXNlZDogdHJ1ZSB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UndmUgZ290dGVuIHRvIHRoaXMgcG9pbnQsIHdlIGRpZG4ndCBmaW5kIGEgc3BlY2lmaWMgY2FjaGUgZW50cnkgdGhhdCBtYXRjaGVkXG4gIC8vIHRoZSByZXF1ZXN0IFVSTC5cbiAgLy8gV2UgYXR0ZW1wdCBhIHBhcnRpYWwgbWF0Y2ggYnkgY2hlY2tpbmcgaWYgdGhlcmUncyBhIGNhY2hlIGVudHJ5IHdpdGggdGhlIHNhbWUgcGF0aG5hbWUuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hhdCB3ZSBmaW5kLCBzaW5jZSBpdCBkb2Vzbid0IGNvcnJlc3BvbmQgd2l0aCB0aGUgcmVxdWVzdGVkIFVSTCwgd2UnbGwgbWFyayBpdCBcImFsaWFzZWRcIi5cbiAgLy8gVGhpcyB3aWxsIHNpZ25hbCB0byB0aGUgcm91dGVyIHRoYXQgaXQgc2hvdWxkIG9ubHkgYXBwbHkgdGhlIGxvYWRpbmcgc3RhdGUgb24gdGhlIHByZWZldGNoZWQgZGF0YS5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAga2luZCAhPT0gUHJlZmV0Y2hLaW5kLkZVTEwgJiZcbiAgICBhbGxvd0FsaWFzaW5nXG4gICkge1xuICAgIGZvciAoY29uc3QgY2FjaGVFbnRyeSBvZiBwcmVmZXRjaENhY2hlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhY2hlRW50cnkudXJsLnBhdGhuYW1lID09PSB1cmwucGF0aG5hbWUgJiZcbiAgICAgICAgLy8gV2Ugc2hvdWxkbid0IHJldHVybiB0aGUgYWxpYXNlZCBlbnRyeSBpZiBpdCB3YXMgcmVsb2NhdGVkIHRvIGEgbmV3IGNhY2hlIGtleS5cbiAgICAgICAgLy8gU2luY2UgaXQncyByZXdyaXR0ZW4sIGl0IGNvdWxkIHJlc3BvbmQgd2l0aCBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICFjYWNoZUVudHJ5LmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4geyAuLi5jYWNoZUVudHJ5LCBhbGlhc2VkOiB0cnVlIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByZWZldGNoIGNhY2hlIGVudHJ5IGlmIG9uZSBleGlzdHMuIE90aGVyd2lzZSBjcmVhdGVzIGEgbmV3IG9uZSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0XG4gKiB0byByZXRyaWV2ZSB0aGUgcHJlZmV0Y2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIHVybCxcbiAgbmV4dFVybCxcbiAgdHJlZSxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAga2luZCxcbiAgYWxsb3dBbGlhc2luZyA9IHRydWUsXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAncHJlZmV0Y2hDYWNoZScgfCAndHJlZSc+ICYge1xuICB1cmw6IFVSTFxuICBraW5kPzogUHJlZmV0Y2hLaW5kXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbn0pOiBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5IHtcbiAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gZ2V0RXhpc3RpbmdDYWNoZUVudHJ5KFxuICAgIHVybCxcbiAgICBraW5kLFxuICAgIG5leHRVcmwsXG4gICAgcHJlZmV0Y2hDYWNoZSxcbiAgICBhbGxvd0FsaWFzaW5nXG4gIClcblxuICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgLy8gR3JhYiB0aGUgbGF0ZXN0IHN0YXR1cyBvZiB0aGUgY2FjaGUgZW50cnkgYW5kIHVwZGF0ZSBpdFxuICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5zdGF0dXMgPSBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMoZXhpc3RpbmdDYWNoZUVudHJ5KVxuXG4gICAgLy8gd2hlbiBga2luZGAgaXMgcHJvdmlkZWQsIGFuIGV4cGxpY2l0IHByZWZldGNoIHdhcyByZXF1ZXN0ZWQuXG4gICAgLy8gaWYgdGhlIHJlcXVlc3RlZCBwcmVmZXRjaCBpcyBcImZ1bGxcIiBhbmQgdGhlIGN1cnJlbnQgY2FjaGUgZW50cnkgd2Fzbid0LCB3ZSB3YW50IHRvIHJlLXByZWZldGNoIHdpdGggdGhlIG5ldyBpbnRlbnRcbiAgICBjb25zdCBzd2l0Y2hlZFRvRnVsbFByZWZldGNoID1cbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgICAga2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTExcblxuICAgIGlmIChzd2l0Y2hlZFRvRnVsbFByZWZldGNoKSB7XG4gICAgICAvLyBJZiB3ZSBzd2l0Y2hlZCB0byBhIGZ1bGwgcHJlZmV0Y2gsIHZhbGlkYXRlIHRoYXQgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGNvbnRhaW5lZCBwYXJ0aWFsIGRhdGEuXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNhY2hlIGVudHJ5IHdhcyBzZWVkZWQgd2l0aCBmdWxsIGRhdGEgYnV0IGhhcyBhIGNhY2hlIHR5cGUgb2YgXCJhdXRvXCIgKGllIHdoZW4gY2FjaGUgZW50cmllc1xuICAgICAgLy8gYXJlIHNlZWRlZCBidXQgd2l0aG91dCBhIHByZWZldGNoIGludGVudClcbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5kYXRhLnRoZW4oKHByZWZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNGdWxsUHJlZmV0Y2ggPVxuICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlZmV0Y2hSZXNwb25zZS5mbGlnaHREYXRhKSAmJlxuICAgICAgICAgIHByZWZldGNoUmVzcG9uc2UuZmxpZ2h0RGF0YS5zb21lKChmbGlnaHREYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBzdGFydGVkIHJlbmRlcmluZyBmcm9tIHRoZSByb290IGFuZCB3ZSByZXR1cm5lZCBSU0MgZGF0YSAoc2VlZERhdGEpLCB3ZSBhbHJlYWR5IGhhZCBhIGZ1bGwgcHJlZmV0Y2guXG4gICAgICAgICAgICByZXR1cm4gZmxpZ2h0RGF0YS5pc1Jvb3RSZW5kZXIgJiYgZmxpZ2h0RGF0YS5zZWVkRGF0YSAhPT0gbnVsbFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFpc0Z1bGxQcmVmZXRjaCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbmV4dFVybCxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZ2V0IGFuIGV4cGxpY2l0IHByZWZldGNoIGtpbmQsIHdlIHdhbnQgdG8gc2V0IGEgdGVtcG9yYXJ5IGtpbmRcbiAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGFzc3VtaW5nIHRoZSBzYW1lIGludGVudCBhcyB0aGUgcHJldmlvdXMgZW50cnksIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBob3cgd2VcbiAgICAgICAgICAgIC8vIGxhemlseSBjcmVhdGUgcHJlZmV0Y2ggZW50cmllcyB3aGVuIGludGVudCBpcyBsZWZ0IHVuc3BlY2lmaWVkLlxuICAgICAgICAgICAga2luZDoga2luZCA/PyBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHdhcyBtYXJrZWQgYXMgdGVtcG9yYXJ5LCBpdCBtZWFucyBpdCB3YXMgbGF6aWx5IGNyZWF0ZWQgd2hlbiBhdHRlbXB0aW5nIHRvIGdldCBhbiBlbnRyeSxcbiAgICAvLyB3aGVyZSB3ZSBkaWRuJ3QgaGF2ZSB0aGUgcHJlZmV0Y2ggaW50ZW50LiBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBpbnRlbnQgKGluIGBraW5kYCksIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBlbnRyeSB0byB0aGUgbW9yZSBhY2N1cmF0ZSBraW5kLlxuICAgIGlmIChraW5kICYmIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID09PSBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZKSB7XG4gICAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCA9IGtpbmRcbiAgICB9XG5cbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgdGhlIGV4aXN0aW5nIGVudHJ5IHdlIGZvdW5kIGlzIHN0aWxsIHZhbGlkLCBzbyB3ZSByZXR1cm4gaXQuXG4gICAgcmV0dXJuIGV4aXN0aW5nQ2FjaGVFbnRyeVxuICB9XG5cbiAgLy8gSWYgd2UgZGlkbid0IHJldHVybiBhbiBlbnRyeSwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgcmV0dXJuIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgICB0cmVlLFxuICAgIHVybCxcbiAgICBuZXh0VXJsLFxuICAgIHByZWZldGNoQ2FjaGUsXG4gICAga2luZDoga2luZCB8fCBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICB9KVxufVxuXG4vKlxuICogVXNlZCB0byB0YWtlIGFuIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGFuZCBwcmVmaXggaXQgd2l0aCB0aGUgbmV4dFVybCwgaWYgaXQgZXhpc3RzLlxuICogVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgaGF2ZSBjb25mbGljdGluZyBjYWNoZSBlbnRyaWVzIGZvciB0aGUgc2FtZSBVUkwgKGFzIGlzIHRoZSBjYXNlIHdpdGggcm91dGUgaW50ZXJjZXB0aW9uKS5cbiAqL1xuZnVuY3Rpb24gcHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkoe1xuICB1cmwsXG4gIG5leHRVcmwsXG4gIHByZWZldGNoQ2FjaGUsXG4gIGV4aXN0aW5nQ2FjaGVLZXksXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAncHJlZmV0Y2hDYWNoZSc+ICYge1xuICB1cmw6IFVSTFxuICBleGlzdGluZ0NhY2hlS2V5OiBzdHJpbmdcbn0pIHtcbiAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoZXhpc3RpbmdDYWNoZUtleSlcbiAgaWYgKCFleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAvLyBuby1vcCAtLSB0aGVyZSB3YXNuJ3QgYW4gZW50cnkgdG8gbW92ZVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbmV3Q2FjaGVLZXkgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KFxuICAgIHVybCxcbiAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCxcbiAgICBuZXh0VXJsXG4gIClcbiAgcHJlZmV0Y2hDYWNoZS5zZXQobmV3Q2FjaGVLZXksIHsgLi4uZXhpc3RpbmdDYWNoZUVudHJ5LCBrZXk6IG5ld0NhY2hlS2V5IH0pXG4gIHByZWZldGNoQ2FjaGUuZGVsZXRlKGV4aXN0aW5nQ2FjaGVLZXkpXG5cbiAgcmV0dXJuIG5ld0NhY2hlS2V5XG59XG5cbi8qKlxuICogVXNlIHRvIHNlZWQgdGhlIHByZWZldGNoIGNhY2hlIHdpdGggZGF0YSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZmV0Y2hlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIG5leHRVcmwsXG4gIHRyZWUsXG4gIHByZWZldGNoQ2FjaGUsXG4gIHVybCxcbiAgZGF0YSxcbiAga2luZCxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICd0cmVlJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGRhdGE6IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHRcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59KSB7XG4gIC8vIFRoZSBpbml0aWFsIGNhY2hlIGVudHJ5IHRlY2huaWNhbGx5IGluY2x1ZGVzIGZ1bGwgZGF0YSwgYnV0IGl0IGlzbid0IGV4cGxpY2l0bHkgcHJlZmV0Y2hlZCAtLSB3ZSBqdXN0IHNlZWQgdGhlXG4gIC8vIHByZWZldGNoIGNhY2hlIHNvIHRoYXQgd2UgY2FuIHNraXAgYW4gZXh0cmEgcHJlZmV0Y2ggcmVxdWVzdCBsYXRlciwgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIHRoZSBkYXRhLlxuICAvLyBpZiB0aGUgcHJlZmV0Y2ggY29ycmVzcG9uZHMgd2l0aCBhbiBpbnRlcmNlcHRpb24gcm91dGUsIHdlIHVzZSB0aGUgbmV4dFVybCB0byBwcmVmaXggdGhlIGNhY2hlIGtleVxuICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gZGF0YS5jb3VsZEJlSW50ZXJjZXB0ZWRcbiAgICA/IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBraW5kLCBuZXh0VXJsKVxuICAgIDogY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQpXG5cbiAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogdHJlZSxcbiAgICBkYXRhOiBQcm9taXNlLnJlc29sdmUoZGF0YSksXG4gICAga2luZCxcbiAgICBwcmVmZXRjaFRpbWU6IERhdGUubm93KCksXG4gICAgbGFzdFVzZWRUaW1lOiBEYXRlLm5vdygpLFxuICAgIHN0YWxlVGltZTogLTEsXG4gICAga2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoLFxuICAgIHVybCxcbiAgfSBzYXRpc2ZpZXMgUHJlZmV0Y2hDYWNoZUVudHJ5XG5cbiAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSlcblxuICByZXR1cm4gcHJlZmV0Y2hFbnRyeVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcmVmZXRjaCBlbnRyeSBlbnRyeSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0IHRvIHJldHJpZXZlIHRoZSBkYXRhLlxuICovXG5mdW5jdGlvbiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gIHVybCxcbiAga2luZCxcbiAgdHJlZSxcbiAgbmV4dFVybCxcbiAgcHJlZmV0Y2hDYWNoZSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICd0cmVlJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGtpbmQ6IFByZWZldGNoS2luZFxufSk6IFByZWZldGNoQ2FjaGVFbnRyeSB7XG4gIGNvbnN0IHByZWZldGNoQ2FjaGVLZXkgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwga2luZClcblxuICAvLyBpbml0aWF0ZXMgdGhlIGZldGNoIHJlcXVlc3QgZm9yIHRoZSBwcmVmZXRjaCBhbmQgYXR0YWNoZXMgYSBsaXN0ZW5lclxuICAvLyB0byB0aGUgcHJvbWlzZSB0byB1cGRhdGUgdGhlIHByZWZldGNoIGNhY2hlIGVudHJ5IHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMgKGlmIG5lY2Vzc2FyeSlcbiAgY29uc3QgZGF0YSA9IHByZWZldGNoUXVldWUuZW5xdWV1ZSgoKSA9PlxuICAgIGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCB7XG4gICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogdHJlZSxcbiAgICAgIG5leHRVcmwsXG4gICAgICBwcmVmZXRjaEtpbmQ6IGtpbmQsXG4gICAgfSkudGhlbigocHJlZmV0Y2hSZXNwb25zZSkgPT4ge1xuICAgICAgLy8gVE9ETzogYGZldGNoU2VydmVyUmVzcG9uc2VgIHNob3VsZCBiZSBtb3JlIHRpZ2hseSBjb3VwbGVkIHRvIHRoZXNlIHByZWZldGNoIGNhY2hlIG9wZXJhdGlvbnNcbiAgICAgIC8vIHRvIGF2b2lkIGRyaWZ0IGJldHdlZW4gdGhpcyBjYWNoZSBrZXkgcHJlZml4aW5nIGxvZ2ljXG4gICAgICAvLyAod2hpY2ggaXMgY3VycmVudGx5IGRpcmVjdGx5IGluZmx1ZW5jZWQgYnkgdGhlIHNlcnZlciByZXNwb25zZSlcbiAgICAgIGxldCBuZXdDYWNoZUtleVxuXG4gICAgICBpZiAocHJlZmV0Y2hSZXNwb25zZS5jb3VsZEJlSW50ZXJjZXB0ZWQpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gcHJlZml4IHRoZSBjYWNoZSBrZXkgd2l0aCB0aGUgbmV4dFVybFxuICAgICAgICBuZXdDYWNoZUtleSA9IHByZWZpeEV4aXN0aW5nUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgZXhpc3RpbmdDYWNoZUtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwcmVmZXRjaCB3YXMgYSBjYWNoZSBoaXQsIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSB0byByZWZsZWN0IHRoYXQgaXQgd2FzIGEgZnVsbCBwcmVmZXRjaC5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBrbm93IHRoYXQgYSBzdGF0aWMgcmVzcG9uc2Ugd2lsbCBjb250YWluIHRoZSBmdWxsIFJTQyBwYXlsb2FkLCBhbmQgY2FuIGJlIHVwZGF0ZWQgdG8gcmVzcGVjdCB0aGUgYHN0YXRpY2BcbiAgICAgIC8vIHN0YWxlVGltZS5cbiAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLnByZXJlbmRlcmVkKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KFxuICAgICAgICAgIC8vIGlmIHdlIHByZWZpeGVkIHRoZSBjYWNoZSBrZXkgZHVlIHRvIHJvdXRlIGludGVyY2VwdGlvbiwgd2Ugd2FudCB0byB1c2UgdGhlIG5ldyBrZXkuIE90aGVyd2lzZSB3ZSB1c2UgdGhlIG9yaWdpbmFsIGtleVxuICAgICAgICAgIG5ld0NhY2hlS2V5ID8/IHByZWZldGNoQ2FjaGVLZXlcbiAgICAgICAgKVxuICAgICAgICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPSBQcmVmZXRjaEtpbmQuRlVMTFxuICAgICAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLnN0YWxlVGltZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHN0YWxlIHRpbWUgdGhhdCB3YXMgY29sbGVjdGVkIGJ5IHRoZSBzZXJ2ZXIgZHVyaW5nXG4gICAgICAgICAgICAvLyBzdGF0aWMgZ2VuZXJhdGlvbi4gVXNlIHRoaXMgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgc3RhbGUgdGltZS5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5zdGFsZVRpbWUgPSBwcmVmZXRjaFJlc3BvbnNlLnN0YWxlVGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlZmV0Y2hSZXNwb25zZVxuICAgIH0pXG4gIClcblxuICBjb25zdCBwcmVmZXRjaEVudHJ5ID0ge1xuICAgIHRyZWVBdFRpbWVPZlByZWZldGNoOiB0cmVlLFxuICAgIGRhdGEsXG4gICAga2luZCxcbiAgICBwcmVmZXRjaFRpbWU6IERhdGUubm93KCksXG4gICAgbGFzdFVzZWRUaW1lOiBudWxsLFxuICAgIHN0YWxlVGltZTogLTEsXG4gICAga2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoLFxuICAgIHVybCxcbiAgfVxuXG4gIHByZWZldGNoQ2FjaGUuc2V0KHByZWZldGNoQ2FjaGVLZXksIHByZWZldGNoRW50cnkpXG5cbiAgcmV0dXJuIHByZWZldGNoRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBydW5lUHJlZmV0Y2hDYWNoZShcbiAgcHJlZmV0Y2hDYWNoZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGVbJ3ByZWZldGNoQ2FjaGUnXVxuKSB7XG4gIGZvciAoY29uc3QgW2hyZWYsIHByZWZldGNoQ2FjaGVFbnRyeV0gb2YgcHJlZmV0Y2hDYWNoZSkge1xuICAgIGlmIChcbiAgICAgIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhwcmVmZXRjaENhY2hlRW50cnkpID09PVxuICAgICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWRcbiAgICApIHtcbiAgICAgIHByZWZldGNoQ2FjaGUuZGVsZXRlKGhyZWYpXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZXNlIHZhbHVlcyBhcmUgc2V0IGJ5IGBkZWZpbmUtZW52LXBsdWdpbmAgKGJhc2VkIG9uIGBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5zdGFsZVRpbWVzYClcbi8vIGFuZCBkZWZhdWx0IHRvIDUgbWludXRlcyAoc3RhdGljKSAvIDAgc2Vjb25kcyAoZHluYW1pYylcbmNvbnN0IERZTkFNSUNfU1RBTEVUSU1FX01TID1cbiAgTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FKSAqIDEwMDBcblxuZXhwb3J0IGNvbnN0IFNUQVRJQ19TVEFMRVRJTUVfTVMgPVxuICBOdW1iZXIocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfU1RBVElDX1NUQUxFVElNRSkgKiAxMDAwXG5cbmZ1bmN0aW9uIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyh7XG4gIGtpbmQsXG4gIHByZWZldGNoVGltZSxcbiAgbGFzdFVzZWRUaW1lLFxuICBzdGFsZVRpbWUsXG59OiBQcmVmZXRjaENhY2hlRW50cnkpOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMge1xuICBpZiAoc3RhbGVUaW1lICE9PSAtMSkge1xuICAgIC8vIGBzdGFsZVRpbWVgIGlzIHRoZSB2YWx1ZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgZHVyaW5nIHN0YXRpYyBnZW5lcmF0aW9uLlxuICAgIC8vIFdoZW4gdGhpcyBpcyBhdmFpbGFibGUsIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBhbnkgb2YgdGhlIGhldXJpc3RpY3NcbiAgICAvLyB0aGF0IGZvbGxvdy5cbiAgICAvL1xuICAgIC8vIFRPRE86IFdoZW4gUFBSIGlzIGVuYWJsZWQsIHRoZSBzZXJ2ZXIgd2lsbCAqYWx3YXlzKiByZXR1cm4gYSBzdGFsZSB0aW1lXG4gICAgLy8gd2hlbiBwcmVmZXRjaGluZy4gV2Ugc2hvdWxkIG5ldmVyIHVzZSBhIHByZWZldGNoIGVudHJ5IHRoYXQgaGFzbid0IHlldFxuICAgIC8vIHJlY2VpdmVkIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBTbyB0aGUgb25seSB0d28gY2FzZXMgc2hvdWxkIGJlIDEpIHdlIHVzZVxuICAgIC8vIHRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHN0YWxlIHRpbWUgMikgdGhlIHVucmVzb2x2ZWQgZW50cnkgaXMgZGlzY2FyZGVkLlxuICAgIHJldHVybiBEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgc3RhbGVUaW1lXG4gICAgICA/IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaFxuICAgICAgOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuc3RhbGVcbiAgfVxuXG4gIC8vIFdlIHdpbGwgcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBkYXRhIGZvciB1cCB0byB0aGUgYGR5bmFtaWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIGlmIChEYXRlLm5vdygpIDwgKGxhc3RVc2VkVGltZSA/PyBwcmVmZXRjaFRpbWUpICsgRFlOQU1JQ19TVEFMRVRJTUVfTVMpIHtcbiAgICByZXR1cm4gbGFzdFVzZWRUaW1lXG4gICAgICA/IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZVxuICAgICAgOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2hcbiAgfVxuXG4gIC8vIEZvciBcImF1dG9cIiBwcmVmZXRjaGluZywgd2UnbGwgcmUtdXNlIG9ubHkgdGhlIGxvYWRpbmcgYm91bmRhcnkgZm9yIHVwIHRvIGBzdGF0aWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIC8vIEEgc3RhbGUgZW50cnkgd2lsbCBvbmx5IHJlLXVzZSB0aGUgYGxvYWRpbmdgIGJvdW5kYXJ5LCBub3QgdGhlIGZ1bGwgZGF0YS5cbiAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBcImxhenkgZmV0Y2hcIiBmb3IgdGhlIGZ1bGwgZGF0YS5cbiAgaWYgKGtpbmQgPT09IFByZWZldGNoS2luZC5BVVRPKSB7XG4gICAgaWYgKERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBTVEFUSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlXG4gICAgfVxuICB9XG5cbiAgLy8gZm9yIFwiZnVsbFwiIHByZWZldGNoaW5nLCB3ZSdsbCByZS11c2UgdGhlIGNhY2hlIGVudHJ5IGRhdGEgZm9yIHVwIHRvIGBzdGF0aWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIGlmIChraW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCkge1xuICAgIGlmIChEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgU1RBVElDX1NUQUxFVElNRV9NUykge1xuICAgICAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZXhwaXJlZFxufVxuIl0sIm5hbWVzIjpbIlNUQVRJQ19TVEFMRVRJTUVfTVMiLCJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSIsInBydW5lUHJlZmV0Y2hDYWNoZSIsIklOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSIiwiY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwiLCJ1cmwiLCJpbmNsdWRlU2VhcmNoUGFyYW1zIiwicHJlZml4IiwicGF0aG5hbWVGcm9tVXJsIiwicGF0aG5hbWUiLCJzZWFyY2giLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5Iiwia2luZCIsIm5leHRVcmwiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiZ2V0RXhpc3RpbmdDYWNoZUVudHJ5IiwicHJlZmV0Y2hDYWNoZSIsImFsbG93QWxpYXNpbmciLCJURU1QT1JBUlkiLCJtYXliZU5leHRVcmwiLCJjYWNoZUtleVdpdGhQYXJhbXMiLCJjYWNoZUtleVdpdGhvdXRQYXJhbXMiLCJjYWNoZUtleVRvVXNlIiwiZXhpc3RpbmdFbnRyeSIsImdldCIsImlzQWxpYXNlZCIsImFsaWFzZWQiLCJlbnRyeVdpdGhvdXRQYXJhbXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJrZXkiLCJpbmNsdWRlcyIsImNhY2hlRW50cnkiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJ0cmVlIiwiZXhpc3RpbmdDYWNoZUVudHJ5Iiwic3RhdHVzIiwiZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzIiwic3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCIsImRhdGEiLCJ0aGVuIiwicHJlZmV0Y2hSZXNwb25zZSIsImlzRnVsbFByZWZldGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiZmxpZ2h0RGF0YSIsInNvbWUiLCJpc1Jvb3RSZW5kZXIiLCJzZWVkRGF0YSIsImNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5IiwicHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkiLCJleGlzdGluZ0NhY2hlS2V5IiwibmV3Q2FjaGVLZXkiLCJzZXQiLCJkZWxldGUiLCJwcmVmZXRjaENhY2hlS2V5IiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlZmV0Y2hFbnRyeSIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcmVmZXRjaFRpbWUiLCJEYXRlIiwibm93IiwibGFzdFVzZWRUaW1lIiwic3RhbGVUaW1lIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwiZnJlc2giLCJwcmVmZXRjaFF1ZXVlIiwiZW5xdWV1ZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInByZWZldGNoS2luZCIsInByZXJlbmRlcmVkIiwiaHJlZiIsInByZWZldGNoQ2FjaGVFbnRyeSIsImV4cGlyZWQiLCJEWU5BTUlDX1NUQUxFVElNRV9NUyIsIk51bWJlciIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU1RBVElDX1NUQUxFVElNRSIsInN0YWxlIiwicmV1c2FibGUiLCJBVVRPIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js ***!
  \*************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hmrRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst hmrRefreshReducer =  false ? 0 : hmrRefreshReducerImpl;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hmr-refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3FEQTZIYUE7OztlQUFBQTs7O2lEQTdIdUI7K0NBQ0Y7eURBQ1U7eURBQ0E7NkNBT1Y7MkNBQ0o7NkNBQ0U7dUNBRUs7bURBQ0M7K0RBQ1k7QUFFbEQsd0ZBQXdGO0FBQ3hGLFNBQVNDLHNCQUNQQyxLQUEyQixFQUMzQkMsTUFBd0I7SUFFeEIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Q7SUFDbkIsTUFBTUUsVUFBbUIsQ0FBQztJQUMxQixNQUFNQyxPQUFPSixNQUFNSyxZQUFZO0lBRS9CRixRQUFRRywwQkFBMEIsR0FBRztJQUVyQyxNQUFNQyxRQUFtQkMsQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQUFBO0lBQ3pCLHNGQUFzRjtJQUN0RixzSEFBc0g7SUFDdEgsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSxtQ0FBQUEsaUNBQUFBLEVBQWtDVixNQUFNVyxJQUFJO0lBRW5FLHVEQUF1RDtJQUN2RCx3Q0FBd0M7SUFDeENKLE1BQU1LLFFBQVEsR0FBR0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFBQSxFQUFvQixJQUFJQyxJQUFJVixNQUFNRixTQUFTO1FBQzFEYSxtQkFBbUI7WUFBQ2YsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFBRVgsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFBRVgsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFBRTtTQUFVO1FBQzNFSyxTQUFTUCxpQkFBaUJULE1BQU1nQixPQUFPLEdBQUc7UUFDMUNDLGNBQWM7SUFDaEI7SUFFQSxPQUFPVixNQUFNSyxRQUFRLENBQUNNLElBQUksQ0FDeEI7WUFBQyxFQUFFQyxVQUFVLEVBQUVkLGNBQWNlLG9CQUFvQixFQUFFO1FBQ2pELDREQUE0RDtRQUM1RCxJQUFJLE9BQU9ELGVBQWUsVUFBVTtZQUNsQyxPQUFPRSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQ0xyQixPQUNBRyxTQUNBZ0IsWUFDQW5CLE1BQU1zQixPQUFPLENBQUNDLFdBQVc7UUFFN0I7UUFFQSwrREFBK0Q7UUFDL0RoQixNQUFNSyxRQUFRLEdBQUc7UUFFakIsSUFBSVksY0FBY3hCLE1BQU1XLElBQUk7UUFDNUIsSUFBSWMsZUFBZXpCLE1BQU1PLEtBQUs7UUFFOUIsS0FBSyxNQUFNbUIsd0JBQXdCUCxXQUFZO1lBQzdDLE1BQU0sRUFBRVIsTUFBTWdCLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdGO1lBQzFDLElBQUksQ0FBQ0UsY0FBYztnQkFDakIsb0NBQW9DO2dCQUNwQ0MsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU85QjtZQUNUO1lBRUEsTUFBTStCLFVBQVVDLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFDZDtnQkFDQzthQUFHLEVBQ0pSLGFBQ0FHLFdBQ0EzQixNQUFNSyxZQUFZO1lBR3BCLElBQUkwQixZQUFZLE1BQU07Z0JBQ3BCLE9BQU9FLENBQUFBLEdBQUFBLHVCQUFBQSxxQkFBQUEsRUFBc0JqQyxPQUFPQyxRQUFRMEI7WUFDOUM7WUFFQSxJQUFJTyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQUFBLEVBQTRCVixhQUFhTyxVQUFVO2dCQUNyRCxPQUFPVixDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQ0xyQixPQUNBRyxTQUNBQyxNQUNBSixNQUFNc0IsT0FBTyxDQUFDQyxXQUFXO1lBRTdCO1lBRUEsTUFBTVksMkJBQTJCZix1QkFDN0JnQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCaEIsd0JBQ2xCaUI7WUFFSixJQUFJakIsc0JBQXNCO2dCQUN4QmpCLFFBQVFFLFlBQVksR0FBRzhCO1lBQ3pCO1lBQ0EsTUFBTUcsVUFBVUMsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQ2RkLGNBQ0FsQixPQUNBbUI7WUFHRixJQUFJWSxTQUFTO2dCQUNYbkMsUUFBUUksS0FBSyxHQUFHQTtnQkFDaEJrQixlQUFlbEI7WUFDakI7WUFFQUosUUFBUXFDLFdBQVcsR0FBR1Q7WUFDdEI1QixRQUFRRSxZQUFZLEdBQUdEO1lBRXZCb0IsY0FBY087UUFDaEI7UUFDQSxPQUFPVSxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjekMsT0FBT0c7SUFDOUIsR0FDQSxJQUFNSDtBQUVWO0FBRUEsU0FBUzBDLHNCQUNQMUMsS0FBMkIsRUFDM0IyQyxPQUF5QjtJQUV6QixPQUFPM0M7QUFDVDtBQUVPLE1BQU1GLG9CQS9FRXVCLE1BZ0ZPLEdBQ2hCcUIsQ0FBcUJBLEdBQ3JCM0MiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxyZWR1Y2Vyc1xcaG1yLXJlZnJlc2gtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmZXRjaFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSB9IGZyb20gJy4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQnXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBSZWR1Y2VyU3RhdGUsXG4gIEhtclJlZnJlc2hBY3Rpb24sXG4gIE11dGFibGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBoYW5kbGVNdXRhYmxlIH0gZnJvbSAnLi4vaGFuZGxlLW11dGFibGUnXG5pbXBvcnQgeyBhcHBseUZsaWdodERhdGEgfSBmcm9tICcuLi9hcHBseS1mbGlnaHQtZGF0YSdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBoYW5kbGVTZWdtZW50TWlzbWF0Y2ggfSBmcm9tICcuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaCdcbmltcG9ydCB7IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSB9IGZyb20gJy4vaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUnXG5cbi8vIEEgdmVyc2lvbiBvZiByZWZyZXNoIHJlZHVjZXIgdGhhdCBrZWVwcyB0aGUgY2FjaGUgYXJvdW5kIGluc3RlYWQgb2Ygd2lwaW5nIGFsbCBvZiBpdC5cbmZ1bmN0aW9uIGhtclJlZnJlc2hSZWR1Y2VySW1wbChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IEhtclJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgb3JpZ2luIH0gPSBhY3Rpb25cbiAgY29uc3QgbXV0YWJsZTogTXV0YWJsZSA9IHt9XG4gIGNvbnN0IGhyZWYgPSBzdGF0ZS5jYW5vbmljYWxVcmxcblxuICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2VcblxuICBjb25zdCBjYWNoZTogQ2FjaGVOb2RlID0gY3JlYXRlRW1wdHlDYWNoZU5vZGUoKVxuICAvLyBJZiB0aGUgY3VycmVudCB0cmVlIHdhcyBpbnRlcmNlcHRlZCwgdGhlIG5leHRVcmwgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LlxuICAvLyBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSByZWZyZXNoIHJlcXVlc3QgZG9lc24ndCBnZXQgaW50ZXJjZXB0ZWQsIGFjY2lkZW50YWxseSB0cmlnZ2VyaW5nIHRoZSBpbnRlcmNlcHRpb24gcm91dGUuXG4gIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHN0YXRlLnRyZWUpXG5cbiAgLy8gVE9ETy1BUFA6IHZlcmlmeSB0aGF0IGBocmVmYCBpcyBub3QgYW4gZXh0ZXJuYWwgdXJsLlxuICAvLyBGZXRjaCBkYXRhIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gIGNhY2hlLmxhenlEYXRhID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIG9yaWdpbiksIHtcbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogW3N0YXRlLnRyZWVbMF0sIHN0YXRlLnRyZWVbMV0sIHN0YXRlLnRyZWVbMl0sICdyZWZldGNoJ10sXG4gICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbCxcbiAgICBpc0htclJlZnJlc2g6IHRydWUsXG4gIH0pXG5cbiAgcmV0dXJuIGNhY2hlLmxhenlEYXRhLnRoZW4oXG4gICAgKHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9KSA9PiB7XG4gICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICBjYWNoZS5sYXp5RGF0YSA9IG51bGxcblxuICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG5cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7IHRyZWU6IHRyZWVQYXRjaCwgaXNSb290UmVuZGVyIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuICAgICAgICBpZiAoIWlzUm9vdFJlbmRlcikge1xuICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBbJyddLFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWZcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBsaWVkID0gYXBwbHlGbGlnaHREYXRhKFxuICAgICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICBub3JtYWxpemVkRmxpZ2h0RGF0YVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgICBjdXJyZW50Q2FjaGUgPSBjYWNoZVxuICAgICAgICB9XG5cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWVcbiAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBocmVmXG5cbiAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgICgpID0+IHN0YXRlXG4gIClcbn1cblxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJOb29wKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIF9hY3Rpb246IEhtclJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3QgaG1yUmVmcmVzaFJlZHVjZXIgPVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBobXJSZWZyZXNoUmVkdWNlck5vb3BcbiAgICA6IGhtclJlZnJlc2hSZWR1Y2VySW1wbFxuIl0sIm5hbWVzIjpbImhtclJlZnJlc2hSZWR1Y2VyIiwiaG1yUmVmcmVzaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwidHJlZSIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsImlzSG1yUmVmcmVzaCIsInRoZW4iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwiY3VycmVudENhY2hlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlUGF0Y2giLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiYXBwbGllZCIsImFwcGx5RmxpZ2h0RGF0YSIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSIsImhtclJlZnJlc2hSZWR1Y2VyTm9vcCIsIl9hY3Rpb24iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This file is only used in app router due to the specific error state handling.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    onCaughtError: function() {\n        return onCaughtError;\n    },\n    onUncaughtError: function() {\n        return onUncaughtError;\n    }\n});\nconst _stitchederror = __webpack_require__(/*! ../components/errors/stitched-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/stitched-error.js\");\nconst _useerrorhandler = __webpack_require__(/*! ../components/errors/use-error-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/use-error-handler.js\");\nconst _isnextroutererror = __webpack_require__(/*! ../components/is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _interceptconsoleerror = __webpack_require__(/*! ../components/globals/intercept-console-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/globals/intercept-console-error.js\");\nconst _errorboundary = __webpack_require__(/*! ../components/error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nfunction onCaughtError(err, errorInfo) {\n    var _errorInfo_errorBoundary;\n    const errorBoundaryComponent = (_errorInfo_errorBoundary = errorInfo.errorBoundary) == null ? void 0 : _errorInfo_errorBoundary.constructor;\n    let isImplicitErrorBoundary;\n    if (true) {\n        const { AppDevOverlayErrorBoundary } = __webpack_require__(/*! ../components/react-dev-overlay/app/app-dev-overlay-error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay-error-boundary.js\");\n        isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;\n    }\n    isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === _errorboundary.ErrorBoundaryHandler && errorInfo.errorBoundary.props.errorComponent === _errorboundary.GlobalError;\n    if (isImplicitErrorBoundary) {\n        // We don't consider errors caught unless they're caught by an explicit error\n        // boundary. The built-in ones are considered implicit.\n        // This mimics how the same app would behave without Next.js.\n        return onUncaughtError(err, errorInfo);\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(err) || (0, _isnextroutererror.isNextRouterError)(err)) return;\n    if (true) {\n        var _errorInfo_componentStack;\n        const errorBoundaryName = (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.displayName) || (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.name) || 'Unknown';\n        const componentThatErroredFrame = errorInfo == null ? void 0 : (_errorInfo_componentStack = errorInfo.componentStack) == null ? void 0 : _errorInfo_componentStack.split('\\n')[1];\n        var // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        _componentThatErroredFrame_match;\n        // Match chrome or safari stack trace\n        const matches = (_componentThatErroredFrame_match = componentThatErroredFrame == null ? void 0 : componentThatErroredFrame.match(/\\s+at (\\w+)\\s+|(\\w+)@/)) != null ? _componentThatErroredFrame_match : [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = \"It was handled by the <\" + errorBoundaryName + \"> error boundary.\";\n        const componentErrorMessage = componentThatErroredName ? \"The above error occurred in the <\" + componentThatErroredName + \"> component.\" : \"The above error occurred in one of your components.\";\n        const errorLocation = componentErrorMessage + \" \" + errorBoundaryMessage;\n        const stitchedError = (0, _stitchederror.getReactStitchedError)(err);\n        // TODO: change to passing down errorInfo later\n        // In development mode, pass along the component stack to the error\n        if (errorInfo.componentStack) {\n            ;\n            stitchedError._componentStack = errorInfo.componentStack;\n        }\n        // Log and report the error with location but without modifying the error stack\n        (0, _interceptconsoleerror.originConsoleError)('%o\\n\\n%s', err, errorLocation);\n        (0, _useerrorhandler.handleClientError)(stitchedError, []);\n    } else {}\n}\nfunction onUncaughtError(err, errorInfo) {\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(err) || (0, _isnextroutererror.isNextRouterError)(err)) return;\n    if (true) {\n        const stitchedError = (0, _stitchederror.getReactStitchedError)(err);\n        // TODO: change to passing down errorInfo later\n        // In development mode, pass along the component stack to the error\n        if (errorInfo.componentStack) {\n            ;\n            stitchedError._componentStack = errorInfo.componentStack;\n        }\n        // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n        (0, _reportglobalerror.reportGlobalError)(stitchedError);\n    } else {}\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary-callbacks.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3MvZXJyb3ItYm91bmRhcnktY2FsbGJhY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlGQUFpRjs7Ozs7Ozs7Ozs7OztJQWNqRUEsYUFBYTtlQUFiQTs7SUF5RUFDLGVBQWU7ZUFBZkE7OzsyQ0FwRnNCOzZDQUNKOytDQUNBOzBDQUNFOytDQUNGO21EQUNDOzJDQUk1QjtBQUVBLFNBQVNELGNBQ2RFLEdBQVksRUFDWkMsU0FBMEQ7UUFFM0JBO0lBQS9CLE1BQU1DLHlCQUFBQSxDQUF5QkQsMkJBQUFBLFVBQVVFLGFBQWEscUJBQXZCRix5QkFBeUJHLFdBQVc7SUFFbkUsSUFBSUM7SUFFSixJQUFJQyxJQUFvQixFQUFtQjtRQUN6QyxNQUFNLEVBQUVHLDBCQUEwQixFQUFFLEdBQ2xDQyxtQkFBT0EsQ0FBQyxrTUFBb0U7UUFFOUVMLDBCQUNFSCwyQkFBMkJPO0lBQy9CO0lBRUFKLDBCQUNFQSwyQkFDQ0gsMkJBQTJCUyxlQUFBQSxvQkFBb0IsSUFDN0NWLFVBQVVFLGFBQWEsQ0FDckJTLEtBQUssQ0FBQ0MsY0FBYyxLQUFLQyxlQUFBQSxXQUFvQjtJQUVwRCxJQUFJVCx5QkFBeUI7UUFDM0IsNkVBQTZFO1FBQzdFLHVEQUF1RDtRQUN2RCw2REFBNkQ7UUFDN0QsT0FBT04sZ0JBQWdCQyxLQUFLQztJQUM5QjtJQUVBLDZFQUE2RTtJQUM3RSxJQUFJYyxDQUFBQSxHQUFBQSxjQUFBQSxtQkFBQUEsRUFBb0JmLFFBQVFnQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCaEIsTUFBTTtJQUV4RCxJQUFJTSxJQUFvQixFQUFtQjtZQU9QTDtRQU5sQyxNQUFNZ0Isb0JBRUosQ0FEQSwwQkFDQ2YsT0FBQUEsRUFEa0MsR0FDbENBLElBQUFBLHVCQUFnQ2dCLFdBQUFBLE1BQ2pDaEIsMEJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLHVCQUF3QmlCLElBQUFBLEtBQ3hCO1FBRUYsTUFBTUMsNEJBQTRCbkIsYUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsNEJBQUFBLFVBQVdvQixjQUFBQSxLQUFjLGdCQUF6QnBCLDBCQUEyQnFCLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUl6RSxzREFBc0QsK0NBQytDO1FBQ3JHLGdHQUFnRztRQUNoR0Y7UUFMRixxQ0FBcUM7UUFDckMsTUFBTUcsVUFJSkgsQ0FBQUEsbUNBQUFBLDZCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSwwQkFBMkJJLEtBQUssQ0FBQyxvQ0FBakNKLG1DQUE2RCxFQUFFO1FBQ2pFLE1BQU1LLDJCQUEyQkYsT0FBTyxDQUFDLEVBQUUsSUFBSUEsT0FBTyxDQUFDLEVBQUUsSUFBSTtRQUU3RCxpSUFBaUk7UUFDakksTUFBTUcsdUJBQXdCLDRCQUF5QlQsb0JBQWtCO1FBQ3pFLE1BQU1VLHdCQUF3QkYsMkJBQ3pCLHNDQUFtQ0EsMkJBQXlCLGlCQUM1RDtRQUVMLE1BQU1HLGdCQUFtQkQsd0JBQXNCLE1BQUdEO1FBRWxELE1BQU1HLGdCQUFnQkMsQ0FBQUEsR0FBQUEsZUFBQUEscUJBQUFBLEVBQXNCOUI7UUFDNUMsK0NBQStDO1FBQy9DLG1FQUFtRTtRQUNuRSxJQUFJQyxVQUFVb0IsY0FBYyxFQUFFOztZQUMxQlEsY0FBc0JFLGVBQWUsR0FBRzlCLFVBQVVvQixjQUFjO1FBQ3BFO1FBRUEsK0VBQStFO1FBQy9FVyxDQUFBQSxHQUFBQSx1QkFBQUEsa0JBQUFBLEVBQW1CLFlBQVloQyxLQUFLNEI7UUFFcENLLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFBa0JKLGVBQWUsRUFBRTtJQUNyQyxPQUFPLEVBRU47QUFDSDtBQUVPLFNBQVM5QixnQkFBZ0JDLEdBQVksRUFBRUMsU0FBMEI7SUFDdEUsNkVBQTZFO0lBQzdFLElBQUljLENBQUFBLEdBQUFBLGNBQUFBLG1CQUFBQSxFQUFvQmYsUUFBUWdCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JoQixNQUFNO0lBRXhELElBQUlNLElBQW9CLEVBQW1CO1FBQ3pDLE1BQU11QixnQkFBZ0JDLENBQUFBLEdBQUFBLGVBQUFBLHFCQUFBQSxFQUFzQjlCO1FBQzVDLCtDQUErQztRQUMvQyxtRUFBbUU7UUFDbkUsSUFBSUMsVUFBVW9CLGNBQWMsRUFBRTs7WUFDMUJRLGNBQXNCRSxlQUFlLEdBQUc5QixVQUFVb0IsY0FBYztRQUNwRTtRQUVBLG9GQUFvRjtRQUNwRmEsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQkw7SUFDcEIsT0FBTyxFQUVOO0FBQ0giLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXE9uZURyaXZlXFxzcmNcXGNsaWVudFxccmVhY3QtY2xpZW50LWNhbGxiYWNrc1xcZXJyb3ItYm91bmRhcnktY2FsbGJhY2tzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBvbmx5IHVzZWQgaW4gYXBwIHJvdXRlciBkdWUgdG8gdGhlIHNwZWNpZmljIGVycm9yIHN0YXRlIGhhbmRsaW5nLlxuXG5pbXBvcnQgdHlwZSB7IEVycm9ySW5mbyB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgZ2V0UmVhY3RTdGl0Y2hlZEVycm9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9lcnJvcnMvc3RpdGNoZWQtZXJyb3InXG5pbXBvcnQgeyBoYW5kbGVDbGllbnRFcnJvciB9IGZyb20gJy4uL2NvbXBvbmVudHMvZXJyb3JzL3VzZS1lcnJvci1oYW5kbGVyJ1xuaW1wb3J0IHsgaXNOZXh0Um91dGVyRXJyb3IgfSBmcm9tICcuLi9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuaW1wb3J0IHsgaXNCYWlsb3V0VG9DU1JFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2JhaWxvdXQtdG8tY3NyJ1xuaW1wb3J0IHsgcmVwb3J0R2xvYmFsRXJyb3IgfSBmcm9tICcuL3JlcG9ydC1nbG9iYWwtZXJyb3InXG5pbXBvcnQgeyBvcmlnaW5Db25zb2xlRXJyb3IgfSBmcm9tICcuLi9jb21wb25lbnRzL2dsb2JhbHMvaW50ZXJjZXB0LWNvbnNvbGUtZXJyb3InXG5pbXBvcnQge1xuICBFcnJvckJvdW5kYXJ5SGFuZGxlcixcbiAgR2xvYmFsRXJyb3IgYXMgRGVmYXVsdEVycm9yQm91bmRhcnksXG59IGZyb20gJy4uL2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnknXG5cbmV4cG9ydCBmdW5jdGlvbiBvbkNhdWdodEVycm9yKFxuICBlcnI6IHVua25vd24sXG4gIGVycm9ySW5mbzogRXJyb3JJbmZvICYgeyBlcnJvckJvdW5kYXJ5PzogUmVhY3QuQ29tcG9uZW50IH1cbikge1xuICBjb25zdCBlcnJvckJvdW5kYXJ5Q29tcG9uZW50ID0gZXJyb3JJbmZvLmVycm9yQm91bmRhcnk/LmNvbnN0cnVjdG9yXG5cbiAgbGV0IGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IEFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5IH0gPVxuICAgICAgcmVxdWlyZSgnLi4vY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9hcHAvYXBwLWRldi1vdmVybGF5LWVycm9yLWJvdW5kYXJ5JykgYXMgdHlwZW9mIGltcG9ydCgnLi4vY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9hcHAvYXBwLWRldi1vdmVybGF5LWVycm9yLWJvdW5kYXJ5JylcblxuICAgIGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5ID1cbiAgICAgIGVycm9yQm91bmRhcnlDb21wb25lbnQgPT09IEFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5XG4gIH1cblxuICBpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSA9XG4gICAgaXNJbXBsaWNpdEVycm9yQm91bmRhcnkgfHxcbiAgICAoZXJyb3JCb3VuZGFyeUNvbXBvbmVudCA9PT0gRXJyb3JCb3VuZGFyeUhhbmRsZXIgJiZcbiAgICAgIChlcnJvckluZm8uZXJyb3JCb3VuZGFyeSEgYXMgSW5zdGFuY2VUeXBlPHR5cGVvZiBFcnJvckJvdW5kYXJ5SGFuZGxlcj4pXG4gICAgICAgIC5wcm9wcy5lcnJvckNvbXBvbmVudCA9PT0gRGVmYXVsdEVycm9yQm91bmRhcnkpXG5cbiAgaWYgKGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5KSB7XG4gICAgLy8gV2UgZG9uJ3QgY29uc2lkZXIgZXJyb3JzIGNhdWdodCB1bmxlc3MgdGhleSdyZSBjYXVnaHQgYnkgYW4gZXhwbGljaXQgZXJyb3JcbiAgICAvLyBib3VuZGFyeS4gVGhlIGJ1aWx0LWluIG9uZXMgYXJlIGNvbnNpZGVyZWQgaW1wbGljaXQuXG4gICAgLy8gVGhpcyBtaW1pY3MgaG93IHRoZSBzYW1lIGFwcCB3b3VsZCBiZWhhdmUgd2l0aG91dCBOZXh0LmpzLlxuICAgIHJldHVybiBvblVuY2F1Z2h0RXJyb3IoZXJyLCBlcnJvckluZm8pXG4gIH1cblxuICAvLyBTa2lwIGNlcnRhaW4gY3VzdG9tIGVycm9ycyB3aGljaCBhcmUgbm90IGV4cGVjdGVkIHRvIGJlIHJlcG9ydGVkIG9uIGNsaWVudFxuICBpZiAoaXNCYWlsb3V0VG9DU1JFcnJvcihlcnIpIHx8IGlzTmV4dFJvdXRlckVycm9yKGVycikpIHJldHVyblxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgZXJyb3JCb3VuZGFyeU5hbWUgPVxuICAgICAgLy8gcmVhZCByZWFjdCBjb21wb25lbnQgZGlzcGxheU5hbWVcbiAgICAgIChlcnJvckJvdW5kYXJ5Q29tcG9uZW50IGFzIGFueSk/LmRpc3BsYXlOYW1lIHx8XG4gICAgICBlcnJvckJvdW5kYXJ5Q29tcG9uZW50Py5uYW1lIHx8XG4gICAgICAnVW5rbm93bidcblxuICAgIGNvbnN0IGNvbXBvbmVudFRoYXRFcnJvcmVkRnJhbWUgPSBlcnJvckluZm8/LmNvbXBvbmVudFN0YWNrPy5zcGxpdCgnXFxuJylbMV1cblxuICAgIC8vIE1hdGNoIGNocm9tZSBvciBzYWZhcmkgc3RhY2sgdHJhY2VcbiAgICBjb25zdCBtYXRjaGVzID1cbiAgICAgIC8vIHJlZ2V4IHRvIG1hdGNoIHRoZSBmdW5jdGlvbiBuYW1lIGluIHRoZSBzdGFjayB0cmFjZVxuICAgICAgLy8gZXhhbXBsZSAxOiBhdCBQYWdlIChodHRwOi8vbG9jYWxob3N0OjMwMDAvX25leHQvc3RhdGljL2NodW5rcy9wYWdlcy9pbmRleC5qcz90cz0xNjMxNjAwMDAwMDAwOjI6MSlcbiAgICAgIC8vIGV4YW1wbGUgMjogUGFnZUBodHRwOi8vbG9jYWxob3N0OjMwMDAvX25leHQvc3RhdGljL2NodW5rcy9wYWdlcy9pbmRleC5qcz90cz0xNjMxNjAwMDAwMDAwOjI6MVxuICAgICAgY29tcG9uZW50VGhhdEVycm9yZWRGcmFtZT8ubWF0Y2goL1xccythdCAoXFx3KylcXHMrfChcXHcrKUAvKSA/PyBbXVxuICAgIGNvbnN0IGNvbXBvbmVudFRoYXRFcnJvcmVkTmFtZSA9IG1hdGNoZXNbMV0gfHwgbWF0Y2hlc1syXSB8fCAnVW5rbm93bidcblxuICAgIC8vIENyZWF0ZSBlcnJvciBsb2NhdGlvbiB3aXRoIGVycm9yZWQgY29tcG9uZW50IGFuZCBlcnJvciBib3VuZGFyeSwgdG8gbWF0Y2ggdGhlIGJlaGF2aW9yIG9mIGRlZmF1bHQgUmVhY3Qgb25DYXVnaHRFcnJvciBoYW5kbGVyLlxuICAgIGNvbnN0IGVycm9yQm91bmRhcnlNZXNzYWdlID0gYEl0IHdhcyBoYW5kbGVkIGJ5IHRoZSA8JHtlcnJvckJvdW5kYXJ5TmFtZX0+IGVycm9yIGJvdW5kYXJ5LmBcbiAgICBjb25zdCBjb21wb25lbnRFcnJvck1lc3NhZ2UgPSBjb21wb25lbnRUaGF0RXJyb3JlZE5hbWVcbiAgICAgID8gYFRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCR7Y29tcG9uZW50VGhhdEVycm9yZWROYW1lfT4gY29tcG9uZW50LmBcbiAgICAgIDogYFRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBjb21wb25lbnRzLmBcblxuICAgIGNvbnN0IGVycm9yTG9jYXRpb24gPSBgJHtjb21wb25lbnRFcnJvck1lc3NhZ2V9ICR7ZXJyb3JCb3VuZGFyeU1lc3NhZ2V9YFxuXG4gICAgY29uc3Qgc3RpdGNoZWRFcnJvciA9IGdldFJlYWN0U3RpdGNoZWRFcnJvcihlcnIpXG4gICAgLy8gVE9ETzogY2hhbmdlIHRvIHBhc3NpbmcgZG93biBlcnJvckluZm8gbGF0ZXJcbiAgICAvLyBJbiBkZXZlbG9wbWVudCBtb2RlLCBwYXNzIGFsb25nIHRoZSBjb21wb25lbnQgc3RhY2sgdG8gdGhlIGVycm9yXG4gICAgaWYgKGVycm9ySW5mby5jb21wb25lbnRTdGFjaykge1xuICAgICAgOyhzdGl0Y2hlZEVycm9yIGFzIGFueSkuX2NvbXBvbmVudFN0YWNrID0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrXG4gICAgfVxuXG4gICAgLy8gTG9nIGFuZCByZXBvcnQgdGhlIGVycm9yIHdpdGggbG9jYXRpb24gYnV0IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBlcnJvciBzdGFja1xuICAgIG9yaWdpbkNvbnNvbGVFcnJvcignJW9cXG5cXG4lcycsIGVyciwgZXJyb3JMb2NhdGlvbilcblxuICAgIGhhbmRsZUNsaWVudEVycm9yKHN0aXRjaGVkRXJyb3IsIFtdKVxuICB9IGVsc2Uge1xuICAgIG9yaWdpbkNvbnNvbGVFcnJvcihlcnIpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uVW5jYXVnaHRFcnJvcihlcnI6IHVua25vd24sIGVycm9ySW5mbzogUmVhY3QuRXJyb3JJbmZvKSB7XG4gIC8vIFNraXAgY2VydGFpbiBjdXN0b20gZXJyb3JzIHdoaWNoIGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgcmVwb3J0ZWQgb24gY2xpZW50XG4gIGlmIChpc0JhaWxvdXRUb0NTUkVycm9yKGVycikgfHwgaXNOZXh0Um91dGVyRXJyb3IoZXJyKSkgcmV0dXJuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBzdGl0Y2hlZEVycm9yID0gZ2V0UmVhY3RTdGl0Y2hlZEVycm9yKGVycilcbiAgICAvLyBUT0RPOiBjaGFuZ2UgdG8gcGFzc2luZyBkb3duIGVycm9ySW5mbyBsYXRlclxuICAgIC8vIEluIGRldmVsb3BtZW50IG1vZGUsIHBhc3MgYWxvbmcgdGhlIGNvbXBvbmVudCBzdGFjayB0byB0aGUgZXJyb3JcbiAgICBpZiAoZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrKSB7XG4gICAgICA7KHN0aXRjaGVkRXJyb3IgYXMgYW55KS5fY29tcG9uZW50U3RhY2sgPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2tcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBBZGQgYW4gYWRlbmR1bSB0byB0aGUgb3ZlcmxheSB0ZWxsaW5nIHBlb3BsZSBhYm91dCBjdXN0b20gZXJyb3IgYm91bmRhcmllcy5cbiAgICByZXBvcnRHbG9iYWxFcnJvcihzdGl0Y2hlZEVycm9yKVxuICB9IGVsc2Uge1xuICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycilcbiAgfVxufVxuIl0sIm5hbWVzIjpbIm9uQ2F1Z2h0RXJyb3IiLCJvblVuY2F1Z2h0RXJyb3IiLCJlcnIiLCJlcnJvckluZm8iLCJlcnJvckJvdW5kYXJ5Q29tcG9uZW50IiwiZXJyb3JCb3VuZGFyeSIsImNvbnN0cnVjdG9yIiwiaXNJbXBsaWNpdEVycm9yQm91bmRhcnkiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSIsInJlcXVpcmUiLCJFcnJvckJvdW5kYXJ5SGFuZGxlciIsInByb3BzIiwiZXJyb3JDb21wb25lbnQiLCJEZWZhdWx0RXJyb3JCb3VuZGFyeSIsImlzQmFpbG91dFRvQ1NSRXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsImVycm9yQm91bmRhcnlOYW1lIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiY29tcG9uZW50VGhhdEVycm9yZWRGcmFtZSIsImNvbXBvbmVudFN0YWNrIiwic3BsaXQiLCJtYXRjaGVzIiwibWF0Y2giLCJjb21wb25lbnRUaGF0RXJyb3JlZE5hbWUiLCJlcnJvckJvdW5kYXJ5TWVzc2FnZSIsImNvbXBvbmVudEVycm9yTWVzc2FnZSIsImVycm9yTG9jYXRpb24iLCJzdGl0Y2hlZEVycm9yIiwiZ2V0UmVhY3RTdGl0Y2hlZEVycm9yIiwiX2NvbXBvbmVudFN0YWNrIiwib3JpZ2luQ29uc29sZUVycm9yIiwiaGFuZGxlQ2xpZW50RXJyb3IiLCJyZXBvcnRHbG9iYWxFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This module can be shared between both pages router and app router\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"onRecoverableError\", ({\n    enumerable: true,\n    get: function() {\n        return onRecoverableError;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _stitchederror = __webpack_require__(/*! ../components/errors/stitched-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/stitched-error.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../lib/is-error */ \"(app-pages-browser)/./node_modules/next/dist/lib/is-error.js\"));\nconst onRecoverableError = (error, errorInfo)=>{\n    // x-ref: https://github.com/facebook/react/pull/28736\n    const cause = (0, _iserror.default)(error) && 'cause' in error ? error.cause : error;\n    const stitchedError = (0, _stitchederror.getReactStitchedError)(cause);\n    // In development mode, pass along the component stack to the error\n    if ( true && errorInfo.componentStack) {\n        ;\n        stitchedError._componentStack = errorInfo.componentStack;\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(cause)) return;\n    (0, _reportglobalerror.reportGlobalError)(stitchedError);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=on-recoverable-error.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3Mvb24tcmVjb3ZlcmFibGUtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUEscUVBQXFFOzs7OztzREFReERBOzs7ZUFBQUE7Ozs7MENBTHVCOytDQUNGOzJDQUNJOzhFQUNsQjtBQUViLE1BQU1BLHFCQUE2RCxDQUN4RUMsT0FDQUM7SUFFQSxzREFBc0Q7SUFDdEQsTUFBTUMsUUFBUUMsQ0FBQUEsR0FBQUEsU0FBQUEsT0FBQUEsRUFBUUgsVUFBVSxXQUFXQSxRQUFRQSxNQUFNRSxLQUFLLEdBQUdGO0lBQ2pFLE1BQU1JLGdCQUFnQkMsQ0FBQUEsR0FBQUEsZUFBQUEscUJBQUFBLEVBQXNCSDtJQUM1QyxtRUFBbUU7SUFDbkUsSUFBSUksS0FBb0IsSUFBc0JMLFVBQVVRLGNBQWMsRUFBRTs7UUFDcEVMLGNBQXNCTSxlQUFlLEdBQUdULFVBQVVRLGNBQWM7SUFDcEU7SUFDQSw2RUFBNkU7SUFDN0UsSUFBSUUsQ0FBQUEsR0FBQUEsY0FBQUEsbUJBQUFBLEVBQW9CVCxRQUFRO0lBRWhDVSxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCUjtBQUNwQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcT25lRHJpdmVcXHNyY1xcY2xpZW50XFxyZWFjdC1jbGllbnQtY2FsbGJhY2tzXFxvbi1yZWNvdmVyYWJsZS1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIG1vZHVsZSBjYW4gYmUgc2hhcmVkIGJldHdlZW4gYm90aCBwYWdlcyByb3V0ZXIgYW5kIGFwcCByb3V0ZXJcblxuaW1wb3J0IHR5cGUgeyBIeWRyYXRpb25PcHRpb25zIH0gZnJvbSAncmVhY3QtZG9tL2NsaWVudCdcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IHJlcG9ydEdsb2JhbEVycm9yIH0gZnJvbSAnLi9yZXBvcnQtZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHsgZ2V0UmVhY3RTdGl0Y2hlZEVycm9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9lcnJvcnMvc3RpdGNoZWQtZXJyb3InXG5pbXBvcnQgaXNFcnJvciBmcm9tICcuLi8uLi9saWIvaXMtZXJyb3InXG5cbmV4cG9ydCBjb25zdCBvblJlY292ZXJhYmxlRXJyb3I6IEh5ZHJhdGlvbk9wdGlvbnNbJ29uUmVjb3ZlcmFibGVFcnJvciddID0gKFxuICBlcnJvcixcbiAgZXJyb3JJbmZvXG4pID0+IHtcbiAgLy8geC1yZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI4NzM2XG4gIGNvbnN0IGNhdXNlID0gaXNFcnJvcihlcnJvcikgJiYgJ2NhdXNlJyBpbiBlcnJvciA/IGVycm9yLmNhdXNlIDogZXJyb3JcbiAgY29uc3Qgc3RpdGNoZWRFcnJvciA9IGdldFJlYWN0U3RpdGNoZWRFcnJvcihjYXVzZSlcbiAgLy8gSW4gZGV2ZWxvcG1lbnQgbW9kZSwgcGFzcyBhbG9uZyB0aGUgY29tcG9uZW50IHN0YWNrIHRvIHRoZSBlcnJvclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrKSB7XG4gICAgOyhzdGl0Y2hlZEVycm9yIGFzIGFueSkuX2NvbXBvbmVudFN0YWNrID0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrXG4gIH1cbiAgLy8gU2tpcCBjZXJ0YWluIGN1c3RvbSBlcnJvcnMgd2hpY2ggYXJlIG5vdCBleHBlY3RlZCB0byBiZSByZXBvcnRlZCBvbiBjbGllbnRcbiAgaWYgKGlzQmFpbG91dFRvQ1NSRXJyb3IoY2F1c2UpKSByZXR1cm5cblxuICByZXBvcnRHbG9iYWxFcnJvcihzdGl0Y2hlZEVycm9yKVxufVxuIl0sIm5hbWVzIjpbIm9uUmVjb3ZlcmFibGVFcnJvciIsImVycm9yIiwiZXJyb3JJbmZvIiwiY2F1c2UiLCJpc0Vycm9yIiwic3RpdGNoZWRFcnJvciIsImdldFJlYWN0U3RpdGNoZWRFcnJvciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNvbXBvbmVudFN0YWNrIiwiX2NvbXBvbmVudFN0YWNrIiwiaXNCYWlsb3V0VG9DU1JFcnJvciIsInJlcG9ydEdsb2JhbEVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    PathParamsContext: function() {\n        return PathParamsContext;\n    },\n    PathnameContext: function() {\n        return PathnameContext;\n    },\n    SearchParamsContext: function() {\n        return SearchParamsContext;\n    }\n});\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst SearchParamsContext = (0, _react.createContext)(null);\nconst PathnameContext = (0, _react.createContext)(null);\nconst PathParamsContext = (0, _react.createContext)(null);\nif (true) {\n    SearchParamsContext.displayName = 'SearchParamsContext';\n    PathnameContext.displayName = 'PathnameContext';\n    PathParamsContext.displayName = 'PathParamsContext';\n} //# sourceMappingURL=hooks-client-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFPYUEsaUJBQWlCO2VBQWpCQTs7SUFEQUMsZUFBZTtlQUFmQTs7SUFEQUMsbUJBQW1CO2VBQW5CQTs7O21DQUhpQjtBQUd2QixNQUFNQSxzQkFBc0JDLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBQXNDO0FBQ2xFLE1BQU1GLGtCQUFrQkUsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBQUEsRUFBNkI7QUFDckQsTUFBTUgsb0JBQW9CRyxDQUFBQSxHQUFBQSxPQUFBQSxhQUFBQSxFQUE2QjtBQUU5RCxJQUFJQyxJQUFvQixFQUFtQjtJQUN6Q0Ysb0JBQW9CSyxXQUFXLEdBQUc7SUFDbENOLGdCQUFnQk0sV0FBVyxHQUFHO0lBQzlCUCxrQkFBa0JPLFdBQVcsR0FBRztBQUNsQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcT25lRHJpdmVcXHNyY1xcc2hhcmVkXFxsaWJcXGhvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcblxuZXhwb3J0IGNvbnN0IFNlYXJjaFBhcmFtc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVSTFNlYXJjaFBhcmFtcyB8IG51bGw+KG51bGwpXG5leHBvcnQgY29uc3QgUGF0aG5hbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxzdHJpbmcgfCBudWxsPihudWxsKVxuZXhwb3J0IGNvbnN0IFBhdGhQYXJhbXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxQYXJhbXMgfCBudWxsPihudWxsKVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBTZWFyY2hQYXJhbXNDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1NlYXJjaFBhcmFtc0NvbnRleHQnXG4gIFBhdGhuYW1lQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdQYXRobmFtZUNvbnRleHQnXG4gIFBhdGhQYXJhbXNDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1BhdGhQYXJhbXNDb250ZXh0J1xufVxuIl0sIm5hbWVzIjpbIlBhdGhQYXJhbXNDb250ZXh0IiwiUGF0aG5hbWVDb250ZXh0IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkaXNwbGF5TmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\n"));

/***/ })

});